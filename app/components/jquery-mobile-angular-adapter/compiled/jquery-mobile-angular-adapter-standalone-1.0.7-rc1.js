/**
* jQuery Mobile angularJS adaper standalone v1.0.7-rc1
* http://github.com/tigbro/jquery-mobile-angular-adapter
*
* Copyright 2011, Tobias Bosch (OPITZ CONSULTING GmbH)
* Licensed under the MIT license.
*
* Includes jQuery JavaScript Library
* http://jquery.com/
*
* Copyright 2011, John Resig
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*
* Includes Sizzle.js
* http://sizzlejs.com/
* Copyright 2011, The Dojo Foundation
* Released under the MIT, BSD, and GPL Licenses.
*
* Includes jQuery Mobile Framework
* http://jquerymobile.com
*
* Copyright 2011 (c) jQuery Project
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*
* Includes  AngularJS
* @license AngularJS v1.0.0rc1
* (c) 2010-2012 AngularJS http://angularjs.org
* License: MIT
*/
/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!memory;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = marginDiv = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Figure out if the W3C box model works as expected
		div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

					// See #9699 for explanation of this approach (setting first, then removal)
					jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Determine handlers that should run if there are delegated events
		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						// If form was submitted by the user, bubble the event up the tree
						if ( this.parentNode && !event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					doneName = match[0];
					parent = elem.parentNode;
	
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent[ expando ] = doneName;
					}
					
					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( 
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ? 
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i++ ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret ) ? ret : orig;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );

/**
 * Helper function to be able to use the jquery mobile mobileinit event
 * in the standalone build, that already includes jquery and jquery mobile.
 */
(function(window) {
    if (window.mobileinit) {
        $(window.document).bind("mobileinit", function() {
            window.mobileinit.apply(this, arguments);
        });
    }

})(window);

/*
* jQuery Mobile Framework 1.1.0-rc.1-oc1
* http://jquerymobile.com
*
* Copyright 2011 (c) jQuery Project
* Dual licensed under the MIT or GPL Version 2 licenses.
* http://jquery.org/license
*
*/
(function ( root, doc, factory ) {
	if ( typeof define === "function" && define.amd ) {
		// AMD. Register as an anonymous module.
		define( [ "jquery" ], function ( $ ) {
			factory( $, root, doc );
			return $.mobile;
		});
	} else {
		// Browser globals
		factory( root.jQuery, root, doc );
	}
}( this, document, function ( $, window, document, undefined ) {


// This plugin is an experiment for abstracting away the touch and mouse
// events so that developers don't have to worry about which method of input
// the device their document is loaded on supports.
//
// The idea here is to allow the developer to register listeners for the
// basic mouse events, such as mousedown, mousemove, mouseup, and click,
// and the plugin will take care of registering the correct listeners
// behind the scenes to invoke the listener at the fastest possible time
// for that device, while still retaining the order of event firing in
// the traditional mouse environment, should multiple handlers be registered
// on the same element for different events.
//
// The current version exposes the following virtual events to jQuery bind methods:
// "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

(function( $, window, document, undefined ) {

var dataPropertyName = "virtualMouseBindings",
	touchTargetPropertyName = "virtualTouchID",
	virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split( " " ),
	touchEventProps = "clientX clientY pageX pageY screenX screenY".split( " " ),
	mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
	mouseEventProps = $.event.props.concat( mouseHookProps ),
	activeDocHandlers = {},
	resetTimerID = 0,
	startX = 0,
	startY = 0,
	didScroll = false,
	clickBlockList = [],
	blockMouseTriggers = false,
	blockTouchTriggers = false,
	eventCaptureSupported = "addEventListener" in document,
	$document = $( document ),
	nextTouchID = 1,
	lastTouchID = 0;

$.vmouse = {
	moveDistanceThreshold: 10,
	clickDistanceThreshold: 10,
	resetTimerDuration: 1500
};

function getNativeEvent( event ) {

	while ( event && typeof event.originalEvent !== "undefined" ) {
		event = event.originalEvent;
	}
	return event;
}

function createVirtualEvent( event, eventType ) {

	var t = event.type,
		oe, props, ne, prop, ct, touch, i, j;

	event = $.Event(event);
	event.type = eventType;

	oe = event.originalEvent;
	props = $.event.props;

	// addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
	// https://github.com/jquery/jquery-mobile/issues/3280
	if ( t.search(/mouse/) >-1 ) {
		props = mouseEventProps;
	}

	// copy original event properties over to the new event
	// this would happen if we could call $.event.fix instead of $.Event
	// but we don't have a way to force an event to be fixed multiple times
	if ( oe ) {
		for ( i = props.length, prop; i; ) {
			prop = props[ --i ];
			event[ prop ] = oe[ prop ];
		}
	}

	// make sure that if the mouse and click virtual events are generated
	// without a .which one is defined
	if ( t.search(/mouse(down|up)|click/) > -1 && !event.which ){
		event.which = 1;
	}

	if ( t.search(/^touch/) !== -1 ) {
		ne = getNativeEvent( oe );
		t = ne.touches;
		ct = ne.changedTouches;
		touch = ( t && t.length ) ? t[0] : ( (ct && ct.length) ? ct[ 0 ] : undefined );

		if ( touch ) {
			for ( j = 0, len = touchEventProps.length; j < len; j++){
				prop = touchEventProps[ j ];
				event[ prop ] = touch[ prop ];
			}
		}
	}

	return event;
}

function getVirtualBindingFlags( element ) {

	var flags = {},
		b, k;

	while ( element ) {

		b = $.data( element, dataPropertyName );

		for (  k in b ) {
			if ( b[ k ] ) {
				flags[ k ] = flags.hasVirtualBinding = true;
			}
		}
		element = element.parentNode;
	}
	return flags;
}

function getClosestElementWithVirtualBinding( element, eventType ) {
	var b;
	while ( element ) {

		b = $.data( element, dataPropertyName );

		if ( b && ( !eventType || b[ eventType ] ) ) {
			return element;
		}
		element = element.parentNode;
	}
	return null;
}

function enableTouchBindings() {
	blockTouchTriggers = false;
}

function disableTouchBindings() {
	blockTouchTriggers = true;
}

function enableMouseBindings() {
	lastTouchID = 0;
	clickBlockList.length = 0;
	blockMouseTriggers = false;

	// When mouse bindings are enabled, our
	// touch bindings are disabled.
	disableTouchBindings();
}

function disableMouseBindings() {
	// When mouse bindings are disabled, our
	// touch bindings are enabled.
	enableTouchBindings();
}

function startResetTimer() {
	clearResetTimer();
	resetTimerID = setTimeout(function(){
		resetTimerID = 0;
		enableMouseBindings();
	}, $.vmouse.resetTimerDuration );
}

function clearResetTimer() {
	if ( resetTimerID ){
		clearTimeout( resetTimerID );
		resetTimerID = 0;
	}
}

function triggerVirtualEvent( eventType, event, flags ) {
	var ve;

	if ( ( flags && flags[ eventType ] ) ||
				( !flags && getClosestElementWithVirtualBinding( event.target, eventType ) ) ) {

		ve = createVirtualEvent( event, eventType );

		$( event.target).trigger( ve );
	}

	return ve;
}

// Workaround for jquery issue 10192,
// by which the mouseout event receives an event with type mosueleave
// if at least one listener for mouseleave is registered.
var jqueryEventTypeFixes = {
   mouseenter: 'mouseover',
   mouseleave: 'mouseout'
};

function mouseEventCallback( event ) {
	var touchID = $.data(event.target, touchTargetPropertyName);

	if ( !blockMouseTriggers && ( !lastTouchID || lastTouchID !== touchID ) ){
        var newType = jqueryEventTypeFixes[event.type];
        if (!newType) {
            newType = event.type;
        }
		var ve = triggerVirtualEvent( "v" + newType, event );
		if ( ve ) {
			if ( ve.isDefaultPrevented() ) {
				event.preventDefault();
			}
			if ( ve.isPropagationStopped() ) {
				event.stopPropagation();
			}
			if ( ve.isImmediatePropagationStopped() ) {
				event.stopImmediatePropagation();
			}
		}
	}
}

function handleTouchStart( event ) {

	var touches = getNativeEvent( event ).touches,
		target, flags;

	if ( touches && touches.length === 1 ) {

		target = event.target;
		flags = getVirtualBindingFlags( target );

		if ( flags.hasVirtualBinding ) {

			lastTouchID = nextTouchID++;
			$.data( target, touchTargetPropertyName, lastTouchID );

			clearResetTimer();

			disableMouseBindings();
			didScroll = false;

			var t = getNativeEvent( event ).touches[ 0 ];
			startX = t.pageX;
			startY = t.pageY;

			triggerVirtualEvent( "vmouseover", event, flags );
			triggerVirtualEvent( "vmousedown", event, flags );
		}
	}
}

function handleScroll( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	if ( !didScroll ) {
		triggerVirtualEvent( "vmousecancel", event, getVirtualBindingFlags( event.target ) );
	}

	didScroll = true;
	startResetTimer();
}

function handleTouchMove( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	var t = getNativeEvent( event ).touches[ 0 ],
		didCancel = didScroll,
		moveThreshold = $.vmouse.moveDistanceThreshold;
		didScroll = didScroll ||
			( Math.abs(t.pageX - startX) > moveThreshold ||
				Math.abs(t.pageY - startY) > moveThreshold ),
		flags = getVirtualBindingFlags( event.target );

	if ( didScroll && !didCancel ) {
		triggerVirtualEvent( "vmousecancel", event, flags );
	}

	triggerVirtualEvent( "vmousemove", event, flags );
	startResetTimer();
}

function handleTouchEnd( event ) {
	if ( blockTouchTriggers ) {
		return;
	}

	disableTouchBindings();

	var flags = getVirtualBindingFlags( event.target ),
		t;
	triggerVirtualEvent( "vmouseup", event, flags );

	if ( !didScroll ) {
		var ve = triggerVirtualEvent( "vclick", event, flags );
		if ( ve && ve.isDefaultPrevented() ) {
			// The target of the mouse events that follow the touchend
			// event don't necessarily match the target used during the
			// touch. This means we need to rely on coordinates for blocking
			// any click that is generated.
			t = getNativeEvent( event ).changedTouches[ 0 ];
			clickBlockList.push({
				touchID: lastTouchID,
				x: t.clientX,
				y: t.clientY
			});

			// Prevent any mouse events that follow from triggering
			// virtual event notifications.
			blockMouseTriggers = true;
		}
	}
	triggerVirtualEvent( "vmouseout", event, flags);
	didScroll = false;

	startResetTimer();
}

function hasVirtualBindings( ele ) {
	var bindings = $.data( ele, dataPropertyName ),
		k;

	if ( bindings ) {
		for ( k in bindings ) {
			if ( bindings[ k ] ) {
				return true;
			}
		}
	}
	return false;
}

function dummyMouseHandler(){}

function getSpecialEventObject( eventType ) {
	var realType = eventType.substr( 1 );

	return {
		setup: function( data, namespace ) {
			// If this is the first virtual mouse binding for this element,
			// add a bindings object to its data.

			if ( !hasVirtualBindings( this ) ) {
				$.data( this, dataPropertyName, {});
			}

			// If setup is called, we know it is the first binding for this
			// eventType, so initialize the count for the eventType to zero.
			var bindings = $.data( this, dataPropertyName );
			bindings[ eventType ] = true;

			// If this is the first virtual mouse event for this type,
			// register a global handler on the document.

			activeDocHandlers[ eventType ] = ( activeDocHandlers[ eventType ] || 0 ) + 1;

			if ( activeDocHandlers[ eventType ] === 1 ) {
				$document.bind( realType, mouseEventCallback );
			}

			// Some browsers, like Opera Mini, won't dispatch mouse/click events
			// for elements unless they actually have handlers registered on them.
			// To get around this, we register dummy handlers on the elements.

			$( this ).bind( realType, dummyMouseHandler );

			// For now, if event capture is not supported, we rely on mouse handlers.
			if ( eventCaptureSupported ) {
				// If this is the first virtual mouse binding for the document,
				// register our touchstart handler on the document.

				activeDocHandlers[ "touchstart" ] = ( activeDocHandlers[ "touchstart" ] || 0) + 1;

				if (activeDocHandlers[ "touchstart" ] === 1) {
					$document.bind( "touchstart", handleTouchStart )
						.bind( "touchend", handleTouchEnd )

						// On touch platforms, touching the screen and then dragging your finger
						// causes the window content to scroll after some distance threshold is
						// exceeded. On these platforms, a scroll prevents a click event from being
						// dispatched, and on some platforms, even the touchend is suppressed. To
						// mimic the suppression of the click event, we need to watch for a scroll
						// event. Unfortunately, some platforms like iOS don't dispatch scroll
						// events until *AFTER* the user lifts their finger (touchend). This means
						// we need to watch both scroll and touchmove events to figure out whether
						// or not a scroll happenens before the touchend event is fired.

						.bind( "touchmove", handleTouchMove )
						.bind( "scroll", handleScroll );
				}
			}
		},

		teardown: function( data, namespace ) {
			// If this is the last virtual binding for this eventType,
			// remove its global handler from the document.

			--activeDocHandlers[ eventType ];

			if ( !activeDocHandlers[ eventType ] ) {
				$document.unbind( realType, mouseEventCallback );
			}

			if ( eventCaptureSupported ) {
				// If this is the last virtual mouse binding in existence,
				// remove our document touchstart listener.

				--activeDocHandlers[ "touchstart" ];

				if ( !activeDocHandlers[ "touchstart" ] ) {
					$document.unbind( "touchstart", handleTouchStart )
						.unbind( "touchmove", handleTouchMove )
						.unbind( "touchend", handleTouchEnd )
						.unbind( "scroll", handleScroll );
				}
			}

			var $this = $( this ),
				bindings = $.data( this, dataPropertyName );

			// teardown may be called when an element was
			// removed from the DOM. If this is the case,
			// jQuery core may have already stripped the element
			// of any data bindings so we need to check it before
			// using it.
			if ( bindings ) {
				bindings[ eventType ] = false;
			}

			// Unregister the dummy event handler.

			$this.unbind( realType, dummyMouseHandler );

			// If this is the last virtual mouse binding on the
			// element, remove the binding data from the element.

			if ( !hasVirtualBindings( this ) ) {
				$this.removeData( dataPropertyName );
			}
		}
	};
}

// Expose our custom events to the jQuery bind/unbind mechanism.

for ( var i = 0; i < virtualEventNames.length; i++ ){
	$.event.special[ virtualEventNames[ i ] ] = getSpecialEventObject( virtualEventNames[ i ] );
}

// Add a capture click handler to block clicks.
// Note that we require event capture support for this so if the device
// doesn't support it, we punt for now and rely solely on mouse events.
if ( eventCaptureSupported ) {
	document.addEventListener( "click", function( e ){
		var cnt = clickBlockList.length,
			target = e.target,
			x, y, ele, i, o, touchID;

		if ( cnt ) {
			x = e.clientX;
			y = e.clientY;
			threshold = $.vmouse.clickDistanceThreshold;

			// The idea here is to run through the clickBlockList to see if
			// the current click event is in the proximity of one of our
			// vclick events that had preventDefault() called on it. If we find
			// one, then we block the click.
			//
			// Why do we have to rely on proximity?
			//
			// Because the target of the touch event that triggered the vclick
			// can be different from the target of the click event synthesized
			// by the browser. The target of a mouse/click event that is syntehsized
			// from a touch event seems to be implementation specific. For example,
			// some browsers will fire mouse/click events for a link that is near
			// a touch event, even though the target of the touchstart/touchend event
			// says the user touched outside the link. Also, it seems that with most
			// browsers, the target of the mouse/click event is not calculated until the
			// time it is dispatched, so if you replace an element that you touched
			// with another element, the target of the mouse/click will be the new
			// element underneath that point.
			//
			// Aside from proximity, we also check to see if the target and any
			// of its ancestors were the ones that blocked a click. This is necessary
			// because of the strange mouse/click target calculation done in the
			// Android 2.1 browser, where if you click on an element, and there is a
			// mouse/click handler on one of its ancestors, the target will be the
			// innermost child of the touched element, even if that child is no where
			// near the point of touch.

			ele = target;

			while ( ele ) {
				for ( i = 0; i < cnt; i++ ) {
					o = clickBlockList[ i ];
					touchID = 0;

					if ( ( ele === target && Math.abs( o.x - x ) < threshold && Math.abs( o.y - y ) < threshold ) ||
								$.data( ele, touchTargetPropertyName ) === o.touchID ) {
						// XXX: We may want to consider removing matches from the block list
						//      instead of waiting for the reset timer to fire.
						e.preventDefault();
						e.stopPropagation();
						return;
					}
				}
				ele = ele.parentNode;
			}
		}
	}, true);
}
})( jQuery, window, document );



// Script: jQuery hashchange event
// 
// *Version: 1.3, Last updated: 7/21/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (0.8kb gzipped)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// document.domain - http://benalman.com/code/projects/jquery-hashchange/examples/document_domain/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.2.6, 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-4, Chrome 5-6, Safari 3.2-5,
//                   Opera 9.6-10.60, iPhone 3.1, Android 1.6-2.2, BlackBerry 4.6-5.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and
// robust, there are a few unfortunate browser bugs surrounding expected
// hashchange event-based behaviors, independent of any JavaScript
// window.onhashchange abstraction. See the following examples for more
// information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// Also note that should a browser natively support the window.onhashchange 
// event, but not report that it does, the fallback polling loop will be used.
// 
// About: Release History
// 
// 1.3   - (7/21/2010) Reorganized IE6/7 Iframe code to make it more
//         "removable" for mobile-only development. Added IE6/7 document.title
//         support. Attempted to make Iframe as hidden as possible by using
//         techniques from http://www.paciellogroup.com/blog/?p=604. Added 
//         support for the "shortcut" format $(window).hashchange( fn ) and
//         $(window).hashchange() like jQuery provides for built-in events.
//         Renamed jQuery.hashchangeDelay to <jQuery.fn.hashchange.delay> and
//         lowered its default value to 50. Added <jQuery.fn.hashchange.domain>
//         and <jQuery.fn.hashchange.src> properties plus document-domain.html
//         file to address access denied issues when setting document.domain in
//         IE6/7.
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  // Reused string.
  var str_hashchange = 'hashchange',
    
    // Method / object references.
    doc = document,
    fake_onhashchange,
    special = $.event.special,
    
    // Does the browser support window.onhashchange? Note that IE8 running in
    // IE7 compatibility mode reports true for 'onhashchange' in window, even
    // though the event isn't supported, so also test document.documentMode.
    doc_mode = doc.documentMode,
    supports_onhashchange = 'on' + str_hashchange in window && ( doc_mode === undefined || doc_mode > 7 );
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || location.href;
    return '#' + url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Method: jQuery.fn.hashchange
  // 
  // Bind a handler to the window.onhashchange event or trigger all bound
  // window.onhashchange event handlers. This behavior is consistent with
  // jQuery's built-in event handlers.
  // 
  // Usage:
  // 
  // > jQuery(window).hashchange( [ handler ] );
  // 
  // Arguments:
  // 
  //  handler - (Function) Optional handler to be bound to the hashchange
  //    event. This is a "shortcut" for the more verbose form:
  //    jQuery(window).bind( 'hashchange', handler ). If handler is omitted,
  //    all bound window.onhashchange event handlers will be triggered. This
  //    is a shortcut for the more verbose
  //    jQuery(window).trigger( 'hashchange' ). These forms are described in
  //    the <hashchange event> section.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements.
  
  // Allow the "shortcut" format $(elem).hashchange( fn ) for binding and
  // $(elem).hashchange() for triggering, like jQuery does for built-in events.
  $.fn[ str_hashchange ] = function( fn ) {
    return fn ? this.bind( str_hashchange, fn ) : this.trigger( str_hashchange );
  };
  
  // Property: jQuery.fn.hashchange.delay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 50.
  
  // Property: jQuery.fn.hashchange.domain
  // 
  // If you're setting document.domain in your JavaScript, and you want hash
  // history to work in IE6/7, not only must this property be set, but you must
  // also set document.domain BEFORE jQuery is loaded into the page. This
  // property is only applicable if you are supporting IE6/7 (or IE8 operating
  // in "IE7 compatibility" mode).
  // 
  // In addition, the <jQuery.fn.hashchange.src> property must be set to the
  // path of the included "document-domain.html" file, which can be renamed or
  // modified if necessary (note that the document.domain specified must be the
  // same in both your main JavaScript as well as in this file).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.domain = document.domain;
  
  // Property: jQuery.fn.hashchange.src
  // 
  // If, for some reason, you need to specify an Iframe src file (for example,
  // when setting document.domain as in <jQuery.fn.hashchange.domain>), you can
  // do so using this property. Note that when using this property, history
  // won't be recorded in IE6/7 until the Iframe src file loads. This property
  // is only applicable if you are supporting IE6/7 (or IE8 operating in "IE7
  // compatibility" mode).
  // 
  // Usage:
  // 
  // jQuery.fn.hashchange.src = 'path/to/file.html';
  
  $.fn[ str_hashchange ].delay = 50;
  /*
  $.fn[ str_hashchange ].domain = null;
  $.fn[ str_hashchange ].src = null;
  */
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // HTML5 window.onhashchange event is used, otherwise a polling loop is
  // initialized, running every <jQuery.fn.hashchange.delay> milliseconds to
  // see if the hash has changed. In IE6/7 (and IE8 operating in "IE7
  // compatibility" mode), a hidden Iframe is created to allow the back button
  // and hash-based history to work.
  // 
  // Usage as described in <jQuery.fn.hashchange>:
  // 
  // > // Bind an event handler.
  // > jQuery(window).hashchange( function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).hashchange();
  // 
  // A more verbose usage that allows for event namespacing:
  // 
  // > // Bind an event handler.
  // > jQuery(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // > 
  // > // Manually trigger the event handler.
  // > jQuery(window).trigger( 'hashchange' );
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one handler
  //   is actually bound to the 'hashchange' event.
  // * If you need the bound handler(s) to execute immediately, in cases where
  //   a location.hash exists on page load, via bookmark or page refresh for
  //   example, use jQuery(window).hashchange() or the more verbose 
  //   jQuery(window).trigger( 'hashchange' ).
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a DOM ready handler.
  
  // Override existing $.event.special.hashchange methods (allowing this plugin
  // to be defined after jQuery BBQ in BBQ's source code).
  special[ str_hashchange ] = $.extend( special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      
      // Remember the initial hash so it doesn't get triggered immediately.
      last_hash = get_fragment(),
      
      fn_retval = function(val){ return val; },
      history_set = fn_retval,
      history_get = fn_retval;
    
    // Start the polling loop.
    self.start = function() {
      timeout_id || poll();
    };
    
    // Stop the polling loop.
    self.stop = function() {
      timeout_id && clearTimeout( timeout_id );
      timeout_id = undefined;
    };
    
    // This polling loop checks every $.fn.hashchange.delay milliseconds to see
    // if location.hash has changed, and triggers the 'hashchange' event on
    // window when necessary.
    function poll() {
      var hash = get_fragment(),
        history_hash = history_get( last_hash );
      
      if ( hash !== last_hash ) {
        history_set( last_hash = hash, history_hash );
        
        $(window).trigger( str_hashchange );
        
      } else if ( history_hash !== last_hash ) {
        location.href = location.href.replace( /#.*/, '' ) + history_hash;
      }
      
      timeout_id = setTimeout( poll, $.fn[ str_hashchange ].delay );
    };
    
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvv REMOVE IF NOT SUPPORTING IE6/7/8 vvvvvvvvvvvvvvvvvvv
    // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
    $.browser.msie && !supports_onhashchange && (function(){
      // Not only do IE6/7 need the "magical" Iframe treatment, but so does IE8
      // when running in "IE7 compatibility" mode.
      
      var iframe,
        iframe_src;
      
      // When the event is bound and polling starts in IE 6/7, create a hidden
      // Iframe for history handling.
      self.start = function(){
        if ( !iframe ) {
          iframe_src = $.fn[ str_hashchange ].src;
          iframe_src = iframe_src && iframe_src + get_fragment();
          
          // Create hidden Iframe. Attempt to make Iframe as hidden as possible
          // by using techniques from http://www.paciellogroup.com/blog/?p=604.
          iframe = $('<iframe tabindex="-1" title="empty"/>').hide()
            
            // When Iframe has completely loaded, initialize the history and
            // start polling.
            .one( 'load', function(){
              iframe_src || history_set( get_fragment() );
              poll();
            })
            
            // Load Iframe src if specified, otherwise nothing.
            .attr( 'src', iframe_src || 'javascript:0' )
            
            // Append Iframe after the end of the body to prevent unnecessary
            // initial page scrolling (yes, this works).
            .insertAfter( 'body' )[0].contentWindow;
          
          // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with "Unspecified error" the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.
          doc.onpropertychange = function(){
            try {
              if ( event.propertyName === 'title' ) {
                iframe.document.title = doc.title;
              }
            } catch(e) {}
          };
          
        }
      };
      
      // Override the "stop" method since an IE6/7 Iframe was created. Even
      // if there are no longer any bound event handlers, the polling loop
      // is still necessary for back/next to work at all!
      self.stop = fn_retval;
      
      // Get history by looking at the hidden Iframe's location.hash.
      history_get = function() {
        return get_fragment( iframe.location.href );
      };
      
      // Set a new history item by opening and then closing the Iframe
      // document, *then* setting its location.hash. If document.domain has
      // been set, update that as well.
      history_set = function( hash, history_hash ) {
        var iframe_doc = iframe.document,
          domain = $.fn[ str_hashchange ].domain;
        
        if ( hash !== history_hash ) {
          // Update Iframe with any initial `document.title` that might be set.
          iframe_doc.title = doc.title;
          
          // Opening the Iframe's document after it has been closed is what
          // actually adds a history entry.
          iframe_doc.open();
          
          // Set document.domain for the Iframe document as well, if necessary.
          domain && iframe_doc.write( '<script>document.domain="' + domain + '"</script>' );
          
          iframe_doc.close();
          
          // Update the Iframe's hash, for great justice.
          iframe.location.hash = hash;
        }
      };
      
    })();
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^ REMOVE IF NOT SUPPORTING IE6/7/8 ^^^^^^^^^^^^^^^^^^^
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    
    return self;
  })();
  
})(jQuery,this);

/*!
 * jQuery UI Widget @VERSION
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */

(function( $, undefined ) {

// jQuery 1.4+
if ( $.cleanData ) {
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			$( elem ).triggerHandler( "remove" );
		}
		_cleanData( elems );
	};
} else {
	var _remove = $.fn.remove;
	$.fn.remove = function( selector, keepData ) {
		return this.each(function() {
			if ( !keepData ) {
				if ( !selector || $.filter( selector, [ this ] ).length ) {
					$( "*", this ).add( [ this ] ).each(function() {
						$( this ).triggerHandler( "remove" );
					});
				}
			}
			return _remove.call( $(this), selector, keepData );
		});
	};
}

$.widget = function( name, base, prototype ) {
	var namespace = name.split( "." )[ 0 ],
		fullName;
	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName ] = function( elem ) {
		return !!$.data( elem, name );
	};

	$[ namespace ] = $[ namespace ] || {};
	$[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	var basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
//	$.each( basePrototype, function( key, val ) {
//		if ( $.isPlainObject(val) ) {
//			basePrototype[ key ] = $.extend( {}, val );
//		}
//	});
	basePrototype.options = $.extend( true, {}, basePrototype.options );
	$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
		namespace: namespace,
		widgetName: name,
		widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
		widgetBaseClass: fullName
	}, prototype );

	$.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		// prevent calls to internal methods
		if ( isMethodCall && options.charAt( 0 ) === "_" ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
				var instance = $.data( this, name );
				if ( !instance ) {
					throw "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'";
				}
				if ( !$.isFunction( instance[options] ) ) {
					throw "no such method '" + options + "' for " + name + " widget instance";
				}
				var methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, name );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, name, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {
	// allow instantiation without initializing for simple inheritance
	if ( arguments.length ) {
		this._createWidget( options, element );
	}
};

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	options: {
		disabled: false
	},
	_createWidget: function( options, element ) {
		// $.widget.bridge stores the plugin instance, but we do it anyway
		// so that it's stored even before the _create function runs
		$.data( element, this.widgetName, this );
		this.element = $( element );
		this.options = $.extend( true, {},
			this.options,
			this._getCreateOptions(),
			options );

		var self = this;
		this.element.bind( "remove." + this.widgetName, function() {
			self.destroy();
		});

		this._create();
		this._trigger( "create" );
		this._init();
	},
	_getCreateOptions: function() {
		var options = {};
		if ( $.metadata ) {
			options = $.metadata.get( element )[ this.widgetName ];
		}
		return options;
	},
	_create: function() {},
	_init: function() {},

	destroy: function() {
		this.element
			.unbind( "." + this.widgetName )
			.removeData( this.widgetName );
		this.widget()
			.unbind( "." + this.widgetName )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetBaseClass + "-disabled " +
				"ui-state-disabled" );
	},

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === "string" ) {
			if ( value === undefined ) {
				return this.options[ key ];
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			self._setOption( key, value );
		});

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				[ value ? "addClass" : "removeClass"](
					this.widgetBaseClass + "-disabled" + " " +
					"ui-state-disabled" )
				.attr( "aria-disabled", value );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_trigger: function( type, event, data ) {
		var callback = this.options[ type ];

		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		data = data || {};

		// copy original event properties over to the new event
		// this would happen if we could call $.event.fix instead of $.Event
		// but we don't have a way to force an event to be fixed multiple times
		if ( event.originalEvent ) {
			for ( var i = $.event.props.length, prop; i; ) {
				prop = $.event.props[ --i ];
				event[ prop ] = event.originalEvent[ prop ];
			}
		}

		this.element.trigger( event, data );

		return !( $.isFunction(callback) &&
			callback.call( this.element[0], event, data ) === false ||
			event.isDefaultPrevented() );
	}
};

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.widget", {
	// decorate the parent _createWidget to trigger `widgetinit` for users
	// who wish to do post post `widgetcreate` alterations/additions
	//
	// TODO create a pull request for jquery ui to trigger this event
	// in the original _createWidget
	_createWidget: function() {
		$.Widget.prototype._createWidget.apply( this, arguments );
		this._trigger( 'init' );
	},

	_getCreateOptions: function() {

		var elem = this.element,
			options = {};

		$.each( this.options, function( option ) {

			var value = elem.jqmData( option.replace( /[A-Z]/g, function( c ) {
							return "-" + c.toLowerCase();
						})
					);

			if ( value !== undefined ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	enhanceWithin: function( target, useKeepNative ) {
		this.enhance( $( this.options.initSelector, $( target )), useKeepNative );
	},

	enhance: function( targets, useKeepNative ) {
		var page, keepNative, $widgetElements = $( targets ), self = this;

		// if ignoreContentEnabled is set to true the framework should
		// only enhance the selected elements when they do NOT have a
		// parent with the data-namespace-ignore attribute
		$widgetElements = $.mobile.enhanceable( $widgetElements );

		if ( useKeepNative && $widgetElements.length ) {
			// TODO remove dependency on the page widget for the keepNative.
			// Currently the keepNative value is defined on the page prototype so
			// the method is as well
			page = $.mobile.closestPageData( $widgetElements );
			keepNative = (page && page.keepNativeSelector()) || "";

			$widgetElements = $widgetElements.not( keepNative );
		}

		$widgetElements[ this.widgetName ]();
	}
});

})( jQuery );

(function( $, window, undefined ) {

	var nsNormalizeDict = {};

	// jQuery.mobile configurable options
	$.mobile = $.extend( {}, {

		// Version of the jQuery Mobile Framework
		version: "1.1.0-rc.1-oc1",

		// Namespace used framework-wide for data-attrs. Default is no namespace
		ns: "",

		// Define the url parameter used for referencing widget-generated sub-pages.
		// Translates to to example.html&ui-page=subpageIdentifier
		// hash segment before &ui-page= is used to make Ajax request
		subPageUrlKey: "ui-page",

		// Class assigned to page currently in view, and during transitions
		activePageClass: "ui-page-active",

		// Class used for "active" button state, from CSS framework
		activeBtnClass: "ui-btn-active",

		// Class used for "focus" form element state, from CSS framework
		focusClass: "ui-focus",

		// Automatically handle clicks and form submissions through Ajax, when same-domain
		ajaxEnabled: true,

		// Automatically load and show pages based on location.hash
		hashListeningEnabled: true,

		// disable to prevent jquery from bothering with links
		linkBindingEnabled: true,

		// Set default page transition - 'none' for no transitions
		defaultPageTransition: "fade",

		// Set maximum window width for transitions to apply - 'false' for no limit
		maxTransitionWidth: false,

		// Minimum scroll distance that will be remembered when returning to a page
		minScrollBack: 10,

		// DEPRECATED: the following property is no longer in use, but defined until 2.0 to prevent conflicts
		touchOverflowEnabled: false,

		// Set default dialog transition - 'none' for no transitions
		defaultDialogTransition: "pop",

		// Show loading message during Ajax requests
		// if false, message will not appear, but loading classes will still be toggled on html el
		loadingMessage: "loading",

		// Error response message - appears when an Ajax page request fails
		pageLoadErrorMessage: "Error Loading Page",

		// Should the text be visble in the loading message?
		loadingMessageTextVisible: false,

		// When the text is visible, what theme does the loading box use?
		loadingMessageTheme: "a",

		// For error messages, which theme does the box uses?
		pageLoadErrorMessageTheme: "e",

		//automatically initialize the DOM when it's ready
		autoInitializePage: true,

		pushStateEnabled: true,

		// allows users to opt in to ignoring content by marking a parent element as
		// data-ignored
		ignoreContentEnabled: false,

		// turn of binding to the native orientationchange due to android orientation behavior
		orientationChangeEnabled: true,

		// TODO might be useful upstream in jquery itself ?
		keyCode: {
			ALT: 18,
			BACKSPACE: 8,
			CAPS_LOCK: 20,
			COMMA: 188,
			COMMAND: 91,
			COMMAND_LEFT: 91, // COMMAND
			COMMAND_RIGHT: 93,
			CONTROL: 17,
			DELETE: 46,
			DOWN: 40,
			END: 35,
			ENTER: 13,
			ESCAPE: 27,
			HOME: 36,
			INSERT: 45,
			LEFT: 37,
			MENU: 93, // COMMAND_RIGHT
			NUMPAD_ADD: 107,
			NUMPAD_DECIMAL: 110,
			NUMPAD_DIVIDE: 111,
			NUMPAD_ENTER: 108,
			NUMPAD_MULTIPLY: 106,
			NUMPAD_SUBTRACT: 109,
			PAGE_DOWN: 34,
			PAGE_UP: 33,
			PERIOD: 190,
			RIGHT: 39,
			SHIFT: 16,
			SPACE: 32,
			TAB: 9,
			UP: 38,
			WINDOWS: 91 // COMMAND
		},

		// Scroll page vertically: scroll to 0 to hide iOS address bar, or pass a Y value
		silentScroll: function( ypos ) {
			if ( $.type( ypos ) !== "number" ) {
				ypos = $.mobile.defaultHomeScroll;
			}

			// prevent scrollstart and scrollstop events
			$.event.special.scrollstart.enabled = false;

			setTimeout(function() {
				window.scrollTo( 0, ypos );
				$( document ).trigger( "silentscroll", { x: 0, y: ypos });
			}, 20 );

			setTimeout(function() {
				$.event.special.scrollstart.enabled = true;
			}, 150 );
		},

		// Expose our cache for testing purposes.
		nsNormalizeDict: nsNormalizeDict,

		// Take a data attribute property, prepend the namespace
		// and then camel case the attribute string. Add the result
		// to our nsNormalizeDict so we don't have to do this again.
		nsNormalize: function( prop ) {
			if ( !prop ) {
				return;
			}

			return nsNormalizeDict[ prop ] || ( nsNormalizeDict[ prop ] = $.camelCase( $.mobile.ns + prop ) );
		},

		getInheritedTheme: function( el, defaultTheme ) {

			// Find the closest parent with a theme class on it. Note that
			// we are not using $.fn.closest() on purpose here because this
			// method gets called quite a bit and we need it to be as fast
			// as possible.

			var e = el[ 0 ],
				ltr = "",
				re = /ui-(bar|body)-([a-z])\b/,
				c, m;

			while ( e ) {
				var c = e.className || "";
				if ( ( m = re.exec( c ) ) && ( ltr = m[ 2 ] ) ) {
					// We found a parent with a theme class
					// on it so bail from this loop.
					break;
				}
				e = e.parentNode;
			}

			// Return the theme letter we found, if none, return the
			// specified default.

			return ltr || defaultTheme || "a";
		},

		// TODO the following $ and $.fn extensions can/probably should be moved into jquery.mobile.core.helpers
		//
		// Find the closest javascript page element to gather settings data jsperf test
		// http://jsperf.com/single-complex-selector-vs-many-complex-selectors/edit
		// possibly naive, but it shows that the parsing overhead for *just* the page selector vs
		// the page and dialog selector is negligable. This could probably be speed up by
		// doing a similar parent node traversal to the one found in the inherited theme code above
		closestPageData: function( $target ) {
			return $target
				.closest(':jqmData(role="page"), :jqmData(role="dialog")')
				.data("page");
		},

		enhanceable: function( $set ) {
			return this.haveParents( $set, "enhance" );
		},

		hijackable: function( $set ) {
			return this.haveParents( $set, "ajax" );
		},

		haveParents: function( $set, attr ) {
			if( !$.mobile.ignoreContentEnabled ){
				return $set;
			}

			var count = $set.length,
				$newSet = $(),
				e, $element, excluded;

			for ( var i = 0; i < count; i++ ) {
				$element = $set.eq( i );
				excluded = false;
				e = $set[ i ];

				while ( e ) {
					var c = e.getAttribute ? e.getAttribute( "data-" + $.mobile.ns + attr ) : "";

					if ( c === "false" ) {
						excluded = true;
						break;
					}

					e = e.parentNode;
				}

				if ( !excluded ) {
					$newSet = $newSet.add( $element );
				}
			}

			return $newSet;
		}
	}, $.mobile );

	// Mobile version of data and removeData and hasData methods
	// ensures all data is set and retrieved using jQuery Mobile's data namespace
	$.fn.jqmData = function( prop, value ) {
		var result;
		if ( typeof prop != "undefined" ) {
			result = this.data( prop ? $.mobile.nsNormalize( prop ) : prop, value );
		}
		return result;
	};

	$.jqmData = function( elem, prop, value ) {
		var result;
		if ( typeof prop != "undefined" ) {
			result = $.data( elem, prop ? $.mobile.nsNormalize( prop ) : prop, value );
		}
		return result;
	};

	$.fn.jqmRemoveData = function( prop ) {
		return this.removeData( $.mobile.nsNormalize( prop ) );
	};

	$.jqmRemoveData = function( elem, prop ) {
		return $.removeData( elem, $.mobile.nsNormalize( prop ) );
	};

	$.fn.removeWithDependents = function() {
		$.removeWithDependents( this );
	};

	$.removeWithDependents = function( elem ) {
		var $elem = $( elem );

		( $elem.jqmData('dependents') || $() ).remove();
		$elem.remove();
	};

	$.fn.addDependents = function( newDependents ) {
		$.addDependents( $(this), newDependents );
	};

	$.addDependents = function( elem, newDependents ) {
		var dependents = $(elem).jqmData( 'dependents' ) || $();

		$(elem).jqmData( 'dependents', $.merge(dependents, newDependents) );
	};

	// note that this helper doesn't attempt to handle the callback
	// or setting of an html elements text, its only purpose is
	// to return the html encoded version of the text in all cases. (thus the name)
	$.fn.getEncodedText = function() {
		return $( "<div/>" ).text( $(this).text() ).html();
	};

	// fluent helper function for the mobile namespaced equivalent
	$.fn.jqmEnhanceable = function() {
		return $.mobile.enhanceable( this );
	};

	$.fn.jqmHijackable = function() {
		return $.mobile.hijackable( this );
	};

	// Monkey-patching Sizzle to filter the :jqmData selector
	var oldFind = $.find,
		jqmDataRE = /:jqmData\(([^)]*)\)/g;

	$.find = function( selector, context, ret, extra ) {
		selector = selector.replace( jqmDataRE, "[data-" + ( $.mobile.ns || "" ) + "$1]" );

		return oldFind.call( this, selector, context, ret, extra );
	};

	$.extend( $.find, oldFind );

	$.find.matches = function( expr, set ) {
		return $.find( expr, null, null, set );
	};

	$.find.matchesSelector = function( node, expr ) {
		return $.find( expr, null, null, [ node ] ).length > 0;
	};
})( jQuery, this );


(function( $, undefined ) {

var $window = $( window ),
	$html = $( "html" );

/* $.mobile.media method: pass a CSS media type or query and get a bool return
	note: this feature relies on actual media query support for media queries, though types will work most anywhere
	examples:
		$.mobile.media('screen') // tests for screen media type
		$.mobile.media('screen and (min-width: 480px)') // tests for screen media type with window width > 480px
		$.mobile.media('@media screen and (-webkit-min-device-pixel-ratio: 2)') // tests for webkit 2x pixel ratio (iPhone 4)
*/
$.mobile.media = (function() {
	// TODO: use window.matchMedia once at least one UA implements it
	var cache = {},
		testDiv = $( "<div id='jquery-mediatest'>" ),
		fakeBody = $( "<body>" ).append( testDiv );

	return function( query ) {
		if ( !( query in cache ) ) {
			var styleBlock = document.createElement( "style" ),
				cssrule = "@media " + query + " { #jquery-mediatest { position:absolute; } }";

			//must set type for IE!
			styleBlock.type = "text/css";

			if ( styleBlock.styleSheet  ){
				styleBlock.styleSheet.cssText = cssrule;
			} else {
				styleBlock.appendChild( document.createTextNode(cssrule) );
			}

			$html.prepend( fakeBody ).prepend( styleBlock );
			cache[ query ] = testDiv.css( "position" ) === "absolute";
			fakeBody.add( styleBlock ).remove();
		}
		return cache[ query ];
	};
})();

})(jQuery);

(function( $, undefined ) {

var fakeBody = $( "<body>" ).prependTo( "html" ),
	fbCSS = fakeBody[ 0 ].style,
	vendors = [ "Webkit", "Moz", "O" ],
	webos = "palmGetResource" in window, //only used to rule out scrollTop
	operamini = window.operamini && ({}).toString.call( window.operamini ) === "[object OperaMini]",
	bb = window.blackberry; //only used to rule out box shadow, as it's filled opaque on BB

// thx Modernizr
function propExists( prop ) {
	var uc_prop = prop.charAt( 0 ).toUpperCase() + prop.substr( 1 ),
		props = ( prop + " " + vendors.join( uc_prop + " " ) + uc_prop ).split( " " );

	for ( var v in props ){
		if ( fbCSS[ props[ v ] ] !== undefined ) {
			return true;
		}
	}
}

function validStyle( prop, value, check_vend ) {
	var div = document.createElement('div'),
		uc = function( txt ) {
			return txt.charAt( 0 ).toUpperCase() + txt.substr( 1 )
		},
		vend_pref = function( vend ) {
			return  "-" + vend.charAt( 0 ).toLowerCase() + vend.substr( 1 ) + "-";
		},
		check_style = function( vend ) {
			var vend_prop = vend_pref( vend ) + prop + ": " + value + ";",
				uc_vend = uc( vend ),
				propStyle = uc_vend + uc( prop );
		
			div.setAttribute( "style", vend_prop );
		
			if( !!div.style[ propStyle ] ) {
				ret = true;
			}
		},
		check_vends = check_vend ? [ check_vend ] : vendors,
		ret;

	for( i = 0; i < check_vends.length; i++ ) {
		check_style( check_vends[i] );
	}
	return !!ret;
}

// Thanks to Modernizr src for this test idea. `perspective` check is limited to Moz to prevent a false positive for 3D transforms on Android.
function transform3dTest() {
	var prop = "transform-3d";
	return validStyle( 'perspective', '10px', 'moz' ) || $.mobile.media( "(-" + vendors.join( "-" + prop + "),(-" ) + "-" + prop + "),(" + prop + ")" );
}

// Test for dynamic-updating base tag support ( allows us to avoid href,src attr rewriting )
function baseTagTest() {
	var fauxBase = location.protocol + "//" + location.host + location.pathname + "ui-dir/",
		base = $( "head base" ),
		fauxEle = null,
		href = "",
		link, rebase;

	if ( !base.length ) {
		base = fauxEle = $( "<base>", { "href": fauxBase }).appendTo( "head" );
	} else {
		href = base.attr( "href" );
	}

	link = $( "<a href='testurl' />" ).prependTo( fakeBody );
	rebase = link[ 0 ].href;
	base[ 0 ].href = href || location.pathname;

	if ( fauxEle ) {
		fauxEle.remove();
	}
	return rebase.indexOf( fauxBase ) === 0;
}


// non-UA-based IE version check by James Padolsey, modified by jdalton - from http://gist.github.com/527683
// allows for inclusion of IE 6+, including Windows Mobile 7
$.extend( $.mobile, { browser: {} } );
$.mobile.browser.ie = (function() {
	var v = 3,
	div = document.createElement( "div" ),
	a = div.all || [];

	// added {} to silence closure compiler warnings. registering my dislike of all things
	// overly clever here for future reference
	while ( div.innerHTML = "<!--[if gt IE " + ( ++v ) + "]><br><![endif]-->", a[ 0 ] ){};

	return v > 4 ? v : !v;
})();


$.extend( $.support, {
	orientation: "orientation" in window && "onorientationchange" in window,
	touch: "ontouchend" in document,
	cssTransitions: "WebKitTransitionEvent" in window || validStyle( 'transition', 'height 100ms linear' ),
	pushState: "pushState" in history && "replaceState" in history,
	mediaquery: $.mobile.media( "only all" ),
	cssPseudoElement: !!propExists( "content" ),
	touchOverflow: !!propExists( "overflowScrolling" ),
	cssTransform3d: transform3dTest(),
	boxShadow: !!propExists( "boxShadow" ) && !bb,
	scrollTop: ( "pageXOffset" in window || "scrollTop" in document.documentElement || "scrollTop" in fakeBody[ 0 ] ) && !webos && !operamini,
	dynamicBaseTag: baseTagTest()
});

fakeBody.remove();


// $.mobile.ajaxBlacklist is used to override ajaxEnabled on platforms that have known conflicts with hash history updates (BB5, Symbian)
// or that generally work better browsing in regular http for full page refreshes (Opera Mini)
// Note: This detection below is used as a last resort.
// We recommend only using these detection methods when all other more reliable/forward-looking approaches are not possible
var nokiaLTE7_3 = (function(){

	var ua = window.navigator.userAgent;

	//The following is an attempt to match Nokia browsers that are running Symbian/s60, with webkit, version 7.3 or older
	return ua.indexOf( "Nokia" ) > -1 &&
			( ua.indexOf( "Symbian/3" ) > -1 || ua.indexOf( "Series60/5" ) > -1 ) &&
			ua.indexOf( "AppleWebKit" ) > -1 &&
			ua.match( /(BrowserNG|NokiaBrowser)\/7\.[0-3]/ );
})();

// Support conditions that must be met in order to proceed
// default enhanced qualifications are media query support OR IE 7+
$.mobile.gradeA = function(){
	return $.support.mediaquery || $.mobile.browser.ie && $.mobile.browser.ie >= 7;
};

$.mobile.ajaxBlacklist =
			// BlackBerry browsers, pre-webkit
			window.blackberry && !window.WebKitPoint ||
			// Opera Mini
			operamini ||
			// Symbian webkits pre 7.3
			nokiaLTE7_3;

// Lastly, this workaround is the only way we've found so far to get pre 7.3 Symbian webkit devices
// to render the stylesheets when they're referenced before this script, as we'd recommend doing.
// This simply reappends the CSS in place, which for some reason makes it apply
if ( nokiaLTE7_3 ) {
	$(function() {
		$( "head link[rel='stylesheet']" ).attr( "rel", "alternate stylesheet" ).attr( "rel", "stylesheet" );
	});
}

// For ruling out shadows via css
if ( !$.support.boxShadow ) {
	$( "html" ).addClass( "ui-mobile-nosupport-boxshadow" );
}

})( jQuery );

(function( $, window, undefined ) {

// add new event shortcuts
$.each( ( "touchstart touchmove touchend orientationchange throttledresize " +
					"tap taphold swipe swipeleft swiperight scrollstart scrollstop" ).split( " " ), function( i, name ) {

	$.fn[ name ] = function( fn ) {
		return fn ? this.bind( name, fn ) : this.trigger( name );
	};

	$.attrFn[ name ] = true;
});

var supportTouch = $.support.touch,
	scrollEvent = "touchmove scroll",
	touchStartEvent = supportTouch ? "touchstart" : "mousedown",
	touchStopEvent = supportTouch ? "touchend" : "mouseup",
	touchMoveEvent = supportTouch ? "touchmove" : "mousemove";

function triggerCustomEvent( obj, eventType, event ) {
	var originalType = event.type;
	event.type = eventType;
	$.event.handle.call( obj, event );
	event.type = originalType;
}

// also handles scrollstop
$.event.special.scrollstart = {

	enabled: true,

	setup: function() {

		var thisObject = this,
			$this = $( thisObject ),
			scrolling,
			timer;

		function trigger( event, state ) {
			scrolling = state;
			triggerCustomEvent( thisObject, scrolling ? "scrollstart" : "scrollstop", event );
		}

		// iPhone triggers scroll after a small delay; use touchmove instead
		$this.bind( scrollEvent, function( event ) {

			if ( !$.event.special.scrollstart.enabled ) {
				return;
			}

			if ( !scrolling ) {
				trigger( event, true );
			}

			clearTimeout( timer );
			timer = setTimeout(function() {
				trigger( event, false );
			}, 50 );
		});
	}
};

// also handles taphold
$.event.special.tap = {
	setup: function() {
		var thisObject = this,
			$this = $( thisObject );

		$this.bind( "vmousedown", function( event ) {

			if ( event.which && event.which !== 1 ) {
				return false;
			}

			var origTarget = event.target,
				origEvent = event.originalEvent,
				timer;

			function clearTapTimer() {
				clearTimeout( timer );
			}

			function clearTapHandlers() {
				clearTapTimer();

				$this.unbind( "vclick", clickHandler )
					.unbind( "vmouseup", clearTapTimer );
				$( document ).unbind( "vmousecancel", clearTapHandlers );
			}

			function clickHandler(event) {
				clearTapHandlers();

				// ONLY trigger a 'tap' event if the start target is
				// the same as the stop target.
				if ( origTarget == event.target ) {
					triggerCustomEvent( thisObject, "tap", event );
				}
			}

			$this.bind( "vmouseup", clearTapTimer )
				.bind( "vclick", clickHandler );
			$( document ).bind( "vmousecancel", clearTapHandlers );

			timer = setTimeout(function() {
					triggerCustomEvent( thisObject, "taphold", $.Event( "taphold", { target: origTarget } ) );
			}, 750 );
		});
	}
};

// also handles swipeleft, swiperight
$.event.special.swipe = {
	scrollSupressionThreshold: 10, // More than this horizontal displacement, and we will suppress scrolling.

	durationThreshold: 1000, // More time than this, and it isn't a swipe.

	horizontalDistanceThreshold: 30,  // Swipe horizontal displacement must be more than this.

	verticalDistanceThreshold: 75,  // Swipe vertical displacement must be less than this.

	setup: function() {
		var thisObject = this,
			$this = $( thisObject );

		$this.bind( touchStartEvent, function( event ) {
			var data = event.originalEvent.touches ?
								event.originalEvent.touches[ 0 ] : event,
				start = {
					time: ( new Date() ).getTime(),
					coords: [ data.pageX, data.pageY ],
					origin: $( event.target )
				},
				stop;

			function moveHandler( event ) {

				if ( !start ) {
					return;
				}

				var data = event.originalEvent.touches ?
						event.originalEvent.touches[ 0 ] : event;

				stop = {
					time: ( new Date() ).getTime(),
					coords: [ data.pageX, data.pageY ]
				};

				// prevent scrolling
				if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
					event.preventDefault();
				}
			}

			$this.bind( touchMoveEvent, moveHandler )
				.one( touchStopEvent, function( event ) {
					$this.unbind( touchMoveEvent, moveHandler );

					if ( start && stop ) {
						if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
								Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
								Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {

							start.origin.trigger( "swipe" )
								.trigger( start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight" );
						}
					}
					start = stop = undefined;
				});
		});
	}
};

(function( $, window ) {
	// "Cowboy" Ben Alman

	var win = $( window ),
		special_event,
		get_orientation,
		last_orientation,
		initial_orientation_is_landscape,
		initial_orientation_is_default,
		portrait_map = { "0": true, "180": true };

	// It seems that some device/browser vendors use window.orientation values 0 and 180 to
	// denote the "default" orientation. For iOS devices, and most other smart-phones tested,
	// the default orientation is always "portrait", but in some Android and RIM based tablets,
	// the default orientation is "landscape". The following code injects a landscape orientation
	// media query into the document to figure out what the current orientation is, and then
	// makes adjustments to the portrait_map if necessary, so that we can properly
	// decode the window.orientation value whenever get_orientation() is called.
	if ( $.support.orientation ) {

		// Use a media query to figure out the true orientation of the device at this moment.
		// Note that we've initialized the portrait map values to 0 and 180, *AND* we purposely
		// use a landscape media query so that if the device/browser does not support this particular
		// media query, we default to the assumption that portrait is the default orientation.
		initial_orientation_is_landscape = $.mobile.media("all and (orientation: landscape)");

		// Now check to see if the current window.orientation is 0 or 180.
		initial_orientation_is_default = portrait_map[ window.orientation ];

		// If the initial orientation is landscape, but window.orientation reports 0 or 180, *OR*
		// if the initial orientation is portrait, but window.orientation reports 90 or -90, we
		// need to flip our portrait_map values because landscape is the default orientation for
		// this device/browser.
		if ( ( initial_orientation_is_landscape && initial_orientation_is_default ) || ( !initial_orientation_is_landscape && !initial_orientation_is_default ) ) {
			portrait_map = { "-90": true, "90": true };
		}
	}

	$.event.special.orientationchange = special_event = {
		setup: function() {
			// If the event is supported natively, return false so that jQuery
			// will bind to the event using DOM methods.
			if ( $.support.orientation && $.mobile.orientationChangeEnabled ) {
				return false;
			}

			// Get the current orientation to avoid initial double-triggering.
			last_orientation = get_orientation();

			// Because the orientationchange event doesn't exist, simulate the
			// event by testing window dimensions on resize.
			win.bind( "throttledresize", handler );
		},
		teardown: function(){
			// If the event is not supported natively, return false so that
			// jQuery will unbind the event using DOM methods.
			if ( $.support.orientation && $.mobile.orientationChangeEnabled ) {
				return false;
			}

			// Because the orientationchange event doesn't exist, unbind the
			// resize event handler.
			win.unbind( "throttledresize", handler );
		},
		add: function( handleObj ) {
			// Save a reference to the bound event handler.
			var old_handler = handleObj.handler;


			handleObj.handler = function( event ) {
				// Modify event object, adding the .orientation property.
				event.orientation = get_orientation();

				// Call the originally-bound event handler and return its result.
				return old_handler.apply( this, arguments );
			};
		}
	};

	// If the event is not supported natively, this handler will be bound to
	// the window resize event to simulate the orientationchange event.
	function handler() {
		// Get the current orientation.
		var orientation = get_orientation();

		if ( orientation !== last_orientation ) {
			// The orientation has changed, so trigger the orientationchange event.
			last_orientation = orientation;
			win.trigger( "orientationchange" );
		}
	}

	// Get the current page orientation. This method is exposed publicly, should it
	// be needed, as jQuery.event.special.orientationchange.orientation()
	$.event.special.orientationchange.orientation = get_orientation = function() {
		var isPortrait = true, elem = document.documentElement;

		// prefer window orientation to the calculation based on screensize as
		// the actual screen resize takes place before or after the orientation change event
		// has been fired depending on implementation (eg android 2.3 is before, iphone after).
		// More testing is required to determine if a more reliable method of determining the new screensize
		// is possible when orientationchange is fired. (eg, use media queries + element + opacity)
		if ( $.support.orientation ) {
			// if the window orientation registers as 0 or 180 degrees report
			// portrait, otherwise landscape
			isPortrait = portrait_map[ window.orientation ];
		} else {
			isPortrait = elem && elem.clientWidth / elem.clientHeight < 1.1;
		}

		return isPortrait ? "portrait" : "landscape";
	};

})( jQuery, window );


// throttled resize event
(function() {

	$.event.special.throttledresize = {
		setup: function() {
			$( this ).bind( "resize", handler );
		},
		teardown: function(){
			$( this ).unbind( "resize", handler );
		}
	};

	var throttle = 250,
		handler = function() {
			curr = ( new Date() ).getTime();
			diff = curr - lastCall;

			if ( diff >= throttle ) {

				lastCall = curr;
				$( this ).trigger( "throttledresize" );

			} else {

				if ( heldCall ) {
					clearTimeout( heldCall );
				}

				// Promise a held call will still execute
				heldCall = setTimeout( handler, throttle - diff );
			}
		},
		lastCall = 0,
		heldCall,
		curr,
		diff;
})();


$.each({
	scrollstop: "scrollstart",
	taphold: "tap",
	swipeleft: "swipe",
	swiperight: "swipe"
}, function( event, sourceEvent ) {

	$.event.special[ event ] = {
		setup: function() {
			$( this ).bind( sourceEvent, $.noop );
		}
	};
});

})( jQuery, this );

(function( $, undefined ) {

$.widget( "mobile.page", $.mobile.widget, {
	options: {
		theme: "c",
		domCache: false,
		keepNativeDefault: ":jqmData(role='none'), :jqmData(role='nojs')"
	},

	_create: function() {

		// if false is returned by the callbacks do not create the page
		if( this._trigger( "beforecreate" ) === false ){
			return false;
		}

		this.element
			.attr( "tabindex", "0" )
			.addClass( "ui-page ui-body-" + this.options.theme );
	},

	keepNativeSelector: function() {
		var options = this.options,
			keepNativeDefined = options.keepNative && $.trim(options.keepNative);

		if( keepNativeDefined && options.keepNative !== options.keepNativeDefault ){
			return [options.keepNative, options.keepNativeDefault].join(", ");
		}

		return options.keepNativeDefault;
	}
});
})( jQuery );


(function( $, window, undefined ) {

function outInTransitionHandler( name, reverse, $to, $from ) {
	
	// override name if there's no 3D transform support and a fallback is defined, or if not, to "none"
	if( name && !$.support.cssTransform3d && $.mobile.transitionFallbacks[ name ] ){
		name = $.mobile.transitionFallbacks[ name ];
	}
	
	var deferred = new $.Deferred(),
		reverseClass = reverse ? " reverse" : "",
		active	= $.mobile.urlHistory.getActive(),
		toScroll = active.lastScroll || $.mobile.defaultHomeScroll,
		screenHeight = $.mobile.getScreenHeight(),
		viewportClass = "ui-mobile-viewport-transitioning viewport-" + name,
		maxTransitionOverride = $.mobile.maxTransitionWidth !== false && $( window ).width() > $.mobile.maxTransitionWidth,
		none = !$.support.cssTransitions || maxTransitionOverride || !name || name === "none",
		doneOut = function() {

			if ( $from ) {
				$from
					.removeClass( $.mobile.activePageClass + " out in reverse " + name )
					.height( "" );
			}
			
			$to.addClass( $.mobile.activePageClass );
			
			if( !none ){
				$to.animationComplete( doneIn );
			}
			
			// Send focus to page as it is now display: block
			$.mobile.focusPage( $to );

			// Jump to top or prev scroll, sometimes on iOS the page has not rendered yet.
			$to.height( screenHeight + toScroll );
				
			$.mobile.silentScroll( toScroll );
			
			$to.addClass( name + " in" + reverseClass );
			
			if( none ){
				doneIn();
			}
			
		},
		
		doneIn = function() {
			$to
				.removeClass( "out in reverse " + name )
				.height( "" )
				.parent().removeClass( viewportClass );

			deferred.resolve( name, reverse, $to, $from, true );
		};
		
	$to
		.parent().addClass( viewportClass );
	
	if ( $from && !none ) {
		$from
			.animationComplete( doneOut )
			.height( screenHeight + $(window ).scrollTop() )
			.addClass( name + " out" + reverseClass );
	}
	else {	
		doneOut();
	}

	return deferred.promise();
}

// Make our transition handler the public default.
$.mobile.defaultTransitionHandler = outInTransitionHandler;

//transition handler dictionary for 3rd party transitions
$.mobile.transitionHandlers = {
	"default": $.mobile.defaultTransitionHandler
};

$.mobile.transitionFallbacks = {};

})( jQuery, this );

( function( $, undefined ) {

	//define vars for interal use
	var $window = $( window ),
		$html = $( 'html' ),
		$head = $( 'head' ),

		//url path helpers for use in relative url management
		path = {

			// This scary looking regular expression parses an absolute URL or its relative
			// variants (protocol, site, document, query, and hash), into the various
			// components (protocol, host, path, query, fragment, etc that make up the
			// URL as well as some other commonly used sub-parts. When used with RegExp.exec()
			// or String.match, it parses the URL into a results array that looks like this:
			//
			//     [0]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread#msg-content
			//     [1]: http://jblas:password@mycompany.com:8080/mail/inbox?msg=1234&type=unread
			//     [2]: http://jblas:password@mycompany.com:8080/mail/inbox
			//     [3]: http://jblas:password@mycompany.com:8080
			//     [4]: http:
			//     [5]: //
			//     [6]: jblas:password@mycompany.com:8080
			//     [7]: jblas:password
			//     [8]: jblas
			//     [9]: password
			//    [10]: mycompany.com:8080
			//    [11]: mycompany.com
			//    [12]: 8080
			//    [13]: /mail/inbox
			//    [14]: /mail/
			//    [15]: inbox
			//    [16]: ?msg=1234&type=unread
			//    [17]: #msg-content
			//
			urlParseRE: /^(((([^:\/#\?]+:)?(?:(\/\/)((?:(([^:@\/#\?]+)(?:\:([^:@\/#\?]+))?)@)?(([^:\/#\?\]\[]+|\[[^\/\]@#?]+\])(?:\:([0-9]+))?))?)?)?((\/?(?:[^\/\?#]+\/+)*)([^\?#]*)))?(\?[^#]+)?)(#.*)?/,

			//Parse a URL into a structure that allows easy access to
			//all of the URL components by name.
			parseUrl: function( url ) {
				// If we're passed an object, we'll assume that it is
				// a parsed url object and just return it back to the caller.
				if ( $.type( url ) === "object" ) {
					return url;
				}

				var matches = path.urlParseRE.exec( url || "" ) || [];

					// Create an object that allows the caller to access the sub-matches
					// by name. Note that IE returns an empty string instead of undefined,
					// like all other browsers do, so we normalize everything so its consistent
					// no matter what browser we're running on.
					return {
						href:         matches[  0 ] || "",
						hrefNoHash:   matches[  1 ] || "",
						hrefNoSearch: matches[  2 ] || "",
						domain:       matches[  3 ] || "",
						protocol:     matches[  4 ] || "",
						doubleSlash:  matches[  5 ] || "",
						authority:    matches[  6 ] || "",
						username:     matches[  8 ] || "",
						password:     matches[  9 ] || "",
						host:         matches[ 10 ] || "",
						hostname:     matches[ 11 ] || "",
						port:         matches[ 12 ] || "",
						pathname:     matches[ 13 ] || "",
						directory:    matches[ 14 ] || "",
						filename:     matches[ 15 ] || "",
						search:       matches[ 16 ] || "",
						hash:         matches[ 17 ] || ""
					};
			},

			//Turn relPath into an asbolute path. absPath is
			//an optional absolute path which describes what
			//relPath is relative to.
			makePathAbsolute: function( relPath, absPath ) {
				if ( relPath && relPath.charAt( 0 ) === "/" ) {
					return relPath;
				}

				relPath = relPath || "";
				absPath = absPath ? absPath.replace( /^\/|(\/[^\/]*|[^\/]+)$/g, "" ) : "";

				var absStack = absPath ? absPath.split( "/" ) : [],
					relStack = relPath.split( "/" );
				for ( var i = 0; i < relStack.length; i++ ) {
					var d = relStack[ i ];
					switch ( d ) {
						case ".":
							break;
						case "..":
							if ( absStack.length ) {
								absStack.pop();
							}
							break;
						default:
							absStack.push( d );
							break;
					}
				}
				return "/" + absStack.join( "/" );
			},

			//Returns true if both urls have the same domain.
			isSameDomain: function( absUrl1, absUrl2 ) {
				return path.parseUrl( absUrl1 ).domain === path.parseUrl( absUrl2 ).domain;
			},

			//Returns true for any relative variant.
			isRelativeUrl: function( url ) {
				// All relative Url variants have one thing in common, no protocol.
				return path.parseUrl( url ).protocol === "";
			},

			//Returns true for an absolute url.
			isAbsoluteUrl: function( url ) {
				return path.parseUrl( url ).protocol !== "";
			},

			//Turn the specified realtive URL into an absolute one. This function
			//can handle all relative variants (protocol, site, document, query, fragment).
			makeUrlAbsolute: function( relUrl, absUrl ) {
				if ( !path.isRelativeUrl( relUrl ) ) {
					return relUrl;
				}

				var relObj = path.parseUrl( relUrl ),
					absObj = path.parseUrl( absUrl ),
					protocol = relObj.protocol || absObj.protocol,
					doubleSlash = relObj.protocol ? relObj.doubleSlash : ( relObj.doubleSlash || absObj.doubleSlash ),
					authority = relObj.authority || absObj.authority,
					hasPath = relObj.pathname !== "",
					pathname = path.makePathAbsolute( relObj.pathname || absObj.filename, absObj.pathname ),
					search = relObj.search || ( !hasPath && absObj.search ) || "",
					hash = relObj.hash;

				return protocol + doubleSlash + authority + pathname + search + hash;
			},

			//Add search (aka query) params to the specified url.
			addSearchParams: function( url, params ) {
				var u = path.parseUrl( url ),
					p = ( typeof params === "object" ) ? $.param( params ) : params,
					s = u.search || "?";
				return u.hrefNoSearch + s + ( s.charAt( s.length - 1 ) !== "?" ? "&" : "" ) + p + ( u.hash || "" );
			},

			convertUrlToDataUrl: function( absUrl ) {
				var u = path.parseUrl( absUrl );
				if ( path.isEmbeddedPage( u ) ) {
				    // For embedded pages, remove the dialog hash key as in getFilePath(),
				    // otherwise the Data Url won't match the id of the embedded Page.
					return u.hash.split( dialogHashKey )[0].replace( /^#/, "" );
				} else if ( path.isSameDomain( u, documentBase ) ) {
					return u.hrefNoHash.replace( documentBase.domain, "" );
				}
				return absUrl;
			},

			//get path from current hash, or from a file path
			get: function( newPath ) {
				if( newPath === undefined ) {
					newPath = location.hash;
				}
				return path.stripHash( newPath ).replace( /[^\/]*\.[^\/*]+$/, '' );
			},

			//return the substring of a filepath before the sub-page key, for making a server request
			getFilePath: function( path ) {
				var splitkey = '&' + $.mobile.subPageUrlKey;
				return path && path.split( splitkey )[0].split( dialogHashKey )[0];
			},

			//set location hash to path
			set: function( path ) {
				location.hash = path;
			},

			//test if a given url (string) is a path
			//NOTE might be exceptionally naive
			isPath: function( url ) {
				return ( /\// ).test( url );
			},

			//return a url path with the window's location protocol/hostname/pathname removed
			clean: function( url ) {
				return url.replace( documentBase.domain, "" );
			},

			//just return the url without an initial #
			stripHash: function( url ) {
				return url.replace( /^#/, "" );
			},

			//remove the preceding hash, any query params, and dialog notations
			cleanHash: function( hash ) {
				return path.stripHash( hash.replace( /\?.*$/, "" ).replace( dialogHashKey, "" ) );
			},

			//check whether a url is referencing the same domain, or an external domain or different protocol
			//could be mailto, etc
			isExternal: function( url ) {
				var u = path.parseUrl( url );
				return u.protocol && u.domain !== documentUrl.domain ? true : false;
			},

			hasProtocol: function( url ) {
				return ( /^(:?\w+:)/ ).test( url );
			},

			//check if the specified url refers to the first page in the main application document.
			isFirstPageUrl: function( url ) {
				// We only deal with absolute paths.
				var u = path.parseUrl( path.makeUrlAbsolute( url, documentBase ) ),

					// Does the url have the same path as the document?
					samePath = u.hrefNoHash === documentUrl.hrefNoHash || ( documentBaseDiffers && u.hrefNoHash === documentBase.hrefNoHash ),

					// Get the first page element.
					fp = $.mobile.firstPage,

					// Get the id of the first page element if it has one.
					fpId = fp && fp[0] ? fp[0].id : undefined;

					// The url refers to the first page if the path matches the document and
					// it either has no hash value, or the hash is exactly equal to the id of the
					// first page element.
					return samePath && ( !u.hash || u.hash === "#" || ( fpId && u.hash.replace( /^#/, "" ) === fpId ) );
			},

			isEmbeddedPage: function( url ) {
				var u = path.parseUrl( url );

				//if the path is absolute, then we need to compare the url against
				//both the documentUrl and the documentBase. The main reason for this
				//is that links embedded within external documents will refer to the
				//application document, whereas links embedded within the application
				//document will be resolved against the document base.
				if ( u.protocol !== "" ) {
					return ( u.hash && ( u.hrefNoHash === documentUrl.hrefNoHash || ( documentBaseDiffers && u.hrefNoHash === documentBase.hrefNoHash ) ) );
				}
				return (/^#/).test( u.href );
			}
		},

		//will be defined when a link is clicked and given an active class
		$activeClickedLink = null,

		//urlHistory is purely here to make guesses at whether the back or forward button was clicked
		//and provide an appropriate transition
		urlHistory = {
			// Array of pages that are visited during a single page load.
			// Each has a url and optional transition, title, and pageUrl (which represents the file path, in cases where URL is obscured, such as dialogs)
			stack: [],

			//maintain an index number for the active page in the stack
			activeIndex: 0,

			//get active
			getActive: function() {
				return urlHistory.stack[ urlHistory.activeIndex ];
			},

			getPrev: function() {
				return urlHistory.stack[ urlHistory.activeIndex - 1 ];
			},

			getNext: function() {
				return urlHistory.stack[ urlHistory.activeIndex + 1 ];
			},

			// addNew is used whenever a new page is added
			addNew: function( url, transition, title, pageUrl, role ) {
				//if there's forward history, wipe it
				if( urlHistory.getNext() ) {
					urlHistory.clearForward();
				}

				urlHistory.stack.push( {url : url, transition: transition, title: title, pageUrl: pageUrl, role: role } );

				urlHistory.activeIndex = urlHistory.stack.length - 1;
			},

			//wipe urls ahead of active index
			clearForward: function() {
				urlHistory.stack = urlHistory.stack.slice( 0, urlHistory.activeIndex + 1 );
			},

			directHashChange: function( opts ) {
				var back , forward, newActiveIndex, prev = this.getActive();

				// check if url isp in history and if it's ahead or behind current page
				$.each( urlHistory.stack, function( i, historyEntry ) {

					//if the url is in the stack, it's a forward or a back
					if( opts.currentUrl === historyEntry.url ) {
						//define back and forward by whether url is older or newer than current page
						back = i < urlHistory.activeIndex;
						forward = !back;
						newActiveIndex = i;
					}
				});

				// save new page index, null check to prevent falsey 0 result
				this.activeIndex = newActiveIndex !== undefined ? newActiveIndex : this.activeIndex;

				if( back ) {
					( opts.either || opts.isBack )( true );
				} else if( forward ) {
					( opts.either || opts.isForward )( false );
				}
			},

			//disable hashchange event listener internally to ignore one change
			//toggled internally when location.hash is updated to match the url of a successful page load
			ignoreNextHashChange: false
		},

		//define first selector to receive focus when a page is shown
		focusable = "[tabindex],a,button:visible,select:visible,input",

		//queue to hold simultanious page transitions
		pageTransitionQueue = [],

		//indicates whether or not page is in process of transitioning
		isPageTransitioning = false,

		//nonsense hash change key for dialogs, so they create a history entry
		dialogHashKey = "&ui-state=dialog",

		//existing base tag?
		$base = $head.children( "base" ),

		//tuck away the original document URL minus any fragment.
		documentUrl = path.parseUrl( location.href ),

		//if the document has an embedded base tag, documentBase is set to its
		//initial value. If a base tag does not exist, then we default to the documentUrl.
		documentBase = $base.length ? path.parseUrl( path.makeUrlAbsolute( $base.attr( "href" ), documentUrl.href ) ) : documentUrl,

		//cache the comparison once.
		documentBaseDiffers = ( documentUrl.hrefNoHash !== documentBase.hrefNoHash );

		//base element management, defined depending on dynamic base tag support
		var base = $.support.dynamicBaseTag ? {

			//define base element, for use in routing asset urls that are referenced in Ajax-requested markup
			element: ( $base.length ? $base : $( "<base>", { href: documentBase.hrefNoHash } ).prependTo( $head ) ),

			//set the generated BASE element's href attribute to a new page's base path
			set: function( href ) {
				base.element.attr( "href", path.makeUrlAbsolute( href, documentBase ) );
			},

			//set the generated BASE element's href attribute to a new page's base path
			reset: function() {
				base.element.attr( "href", documentBase.hrefNoHash );
			}

		} : undefined;

/*
	internal utility functions
--------------------------------------*/


	//direct focus to the page title, or otherwise first focusable element
	$.mobile.focusPage = function ( page ) {
		var autofocus = page.find("[autofocus]"),
			pageTitle = page.find( ".ui-title:eq(0)" );

		if( autofocus.length ) {
			autofocus.focus();
			return;
		}

		if( pageTitle.length ) {
			pageTitle.focus();
		}
		else{
			page.focus();
		}
	}

	//remove active classes after page transition or error
	function removeActiveLinkClass( forceRemoval ) {
		if( !!$activeClickedLink && ( !$activeClickedLink.closest( '.ui-page-active' ).length || forceRemoval ) ) {
			$activeClickedLink.removeClass( $.mobile.activeBtnClass );
		}
		$activeClickedLink = null;
	}

	function releasePageTransitionLock() {
		isPageTransitioning = false;
		if( pageTransitionQueue.length > 0 ) {
			$.mobile.changePage.apply( null, pageTransitionQueue.pop() );
		}
	}

	// Save the last scroll distance per page, before it is hidden
	var setLastScrollEnabled = true,
		setLastScroll, delayedSetLastScroll;

	setLastScroll = function() {
		// this barrier prevents setting the scroll value based on the browser
		// scrolling the window based on a hashchange
		if( !setLastScrollEnabled ) {
			return;
		}

		var active = $.mobile.urlHistory.getActive();

		if( active ) {
			var lastScroll = $window.scrollTop();

			// Set active page's lastScroll prop.
			// If the location we're scrolling to is less than minScrollBack, let it go.
			active.lastScroll = lastScroll < $.mobile.minScrollBack ? $.mobile.defaultHomeScroll : lastScroll;
		}
	};

	// bind to scrollstop to gather scroll position. The delay allows for the hashchange
	// event to fire and disable scroll recording in the case where the browser scrolls
	// to the hash targets location (sometimes the top of the page). once pagechange fires
	// getLastScroll is again permitted to operate
	delayedSetLastScroll = function() {
		setTimeout( setLastScroll, 100 );
	};

	// disable an scroll setting when a hashchange has been fired, this only works
	// because the recording of the scroll position is delayed for 100ms after
	// the browser might have changed the position because of the hashchange
	$window.bind( $.support.pushState ? "popstate" : "hashchange", function() {
	 	setLastScrollEnabled = false;
	});

	// handle initial hashchange from chrome :(
	$window.one( $.support.pushState ? "popstate" : "hashchange", function() {
		setLastScrollEnabled = true;
	});

	// wait until the mobile page container has been determined to bind to pagechange
	$window.one( "pagecontainercreate", function(){
		// once the page has changed, re-enable the scroll recording
		$.mobile.pageContainer.bind( "pagechange", function() {

	 		setLastScrollEnabled = true;

			// remove any binding that previously existed on the get scroll
			// which may or may not be different than the scroll element determined for
			// this page previously
			$window.unbind( "scrollstop", delayedSetLastScroll );

			// determine and bind to the current scoll element which may be the window
			// or in the case of touch overflow the element with touch overflow
			$window.bind( "scrollstop", delayedSetLastScroll );
		});
	});

	// bind to scrollstop for the first page as "pagechange" won't be fired in that case
	$window.bind( "scrollstop", delayedSetLastScroll );

	//function for transitioning between two existing pages
	function transitionPages( toPage, fromPage, transition, reverse ) {

		if( fromPage ) {
			//trigger before show/hide events
			fromPage.data( "page" )._trigger( "beforehide", null, { nextPage: toPage } );
		}

		toPage.data( "page" )._trigger( "beforeshow", null, { prevPage: fromPage || $( "" ) } );

		//clear page loader
		$.mobile.hidePageLoadingMsg();

		//find the transition handler for the specified transition. If there
		//isn't one in our transitionHandlers dictionary, use the default one.
		//call the handler immediately to kick-off the transition.
		var th = $.mobile.transitionHandlers[ transition || "default" ] || $.mobile.defaultTransitionHandler,
			promise = th( transition, reverse, toPage, fromPage );

		promise.done(function() {

			//trigger show/hide events
			if( fromPage ) {
				fromPage.data( "page" )._trigger( "hide", null, { nextPage: toPage } );
			}

			//trigger pageshow, define prevPage as either fromPage or empty jQuery obj
			toPage.data( "page" )._trigger( "show", null, { prevPage: fromPage || $( "" ) } );
		});

		return promise;
	}

	//simply set the active page's minimum height to screen height, depending on orientation
	function getScreenHeight(){
		var orientation 	= $.event.special.orientationchange.orientation(),
			port			= orientation === "portrait",
			winMin			= port ? 480 : 320,
			screenHeight	= port ? screen.availHeight : screen.availWidth,
			winHeight		= Math.max( winMin, $( window ).height() ),
			pageMin			= Math.min( screenHeight, winHeight );

		return pageMin;
	}

	$.mobile.getScreenHeight = getScreenHeight;

	//simply set the active page's minimum height to screen height, depending on orientation
	function resetActivePageHeight(){
		$( "." + $.mobile.activePageClass ).css( "min-height", getScreenHeight() );
	}

	//shared page enhancements
	function enhancePage( $page, role ) {
		// If a role was specified, make sure the data-role attribute
		// on the page element is in sync.
		if( role ) {
			$page.attr( "data-" + $.mobile.ns + "role", role );
		}

		//run page plugin
		$page.page();
	}

/* exposed $.mobile methods	 */

	//animation complete callback
	$.fn.animationComplete = function( callback ) {
		if( $.support.cssTransitions ) {
			return $( this ).one( 'webkitAnimationEnd animationend', callback );
		}
		else{
			// defer execution for consistency between webkit/non webkit
			setTimeout( callback, 0 );
			return $( this );
		}
	};

	//expose path object on $.mobile
	$.mobile.path = path;

	//expose base object on $.mobile
	$.mobile.base = base;

	//history stack
	$.mobile.urlHistory = urlHistory;

	$.mobile.dialogHashKey = dialogHashKey;



	//enable cross-domain page support
	$.mobile.allowCrossDomainPages = false;

	//return the original document url
	$.mobile.getDocumentUrl = function(asParsedObject) {
		return asParsedObject ? $.extend( {}, documentUrl ) : documentUrl.href;
	};

	//return the original document base url
	$.mobile.getDocumentBase = function(asParsedObject) {
		return asParsedObject ? $.extend( {}, documentBase ) : documentBase.href;
	};

	$.mobile._bindPageRemove = function() {
		var page = $(this);

		// when dom caching is not enabled or the page is embedded bind to remove the page on hide
		if( !page.data("page").options.domCache
				&& page.is(":jqmData(external-page='true')") ) {

			page.bind( 'pagehide.remove', function() {
				var $this = $( this ),
					prEvent = new $.Event( "pageremove" );

				$this.trigger( prEvent );

				if( !prEvent.isDefaultPrevented() ){
					$this.removeWithDependents();
				}
			});
		}
	};

	// Load a page into the DOM.
	$.mobile.loadPage = function( url, options ) {
		// This function uses deferred notifications to let callers
		// know when the page is done loading, or if an error has occurred.
		var deferred = $.Deferred(),

			// The default loadPage options with overrides specified by
			// the caller.
			settings = $.extend( {}, $.mobile.loadPage.defaults, options ),

			// The DOM element for the page after it has been loaded.
			page = null,

			// If the reloadPage option is true, and the page is already
			// in the DOM, dupCachedPage will be set to the page element
			// so that it can be removed after the new version of the
			// page is loaded off the network.
			dupCachedPage = null,

			// determine the current base url
			findBaseWithDefault = function(){
				var closestBase = ( $.mobile.activePage && getClosestBaseUrl( $.mobile.activePage ) );
				return closestBase || documentBase.hrefNoHash;
			},

			// The absolute version of the URL passed into the function. This
			// version of the URL may contain dialog/subpage params in it.
			absUrl = path.makeUrlAbsolute( url, findBaseWithDefault() );


		// If the caller provided data, and we're using "get" request,
		// append the data to the URL.
		if ( settings.data && settings.type === "get" ) {
			absUrl = path.addSearchParams( absUrl, settings.data );
			settings.data = undefined;
		}

		// If the caller is using a "post" request, reloadPage must be true
		if(  settings.data && settings.type === "post" ){
			settings.reloadPage = true;
		}

			// The absolute version of the URL minus any dialog/subpage params.
			// In otherwords the real URL of the page to be loaded.
		var fileUrl = path.getFilePath( absUrl ),

			// The version of the Url actually stored in the data-url attribute of
			// the page. For embedded pages, it is just the id of the page. For pages
			// within the same domain as the document base, it is the site relative
			// path. For cross-domain pages (Phone Gap only) the entire absolute Url
			// used to load the page.
			dataUrl = path.convertUrlToDataUrl( absUrl );

		// Make sure we have a pageContainer to work with.
		settings.pageContainer = settings.pageContainer || $.mobile.pageContainer;

		// Check to see if the page already exists in the DOM.
		page = settings.pageContainer.children( ":jqmData(url='" + dataUrl + "')" );

		// If we failed to find the page, check to see if the url is a
		// reference to an embedded page. If so, it may have been dynamically
		// injected by a developer, in which case it would be lacking a data-url
		// attribute and in need of enhancement.
		if ( page.length === 0 && dataUrl && !path.isPath( dataUrl ) ) {
			page = settings.pageContainer.children( "#" + dataUrl )
				.attr( "data-" + $.mobile.ns + "url", dataUrl );
		}

		// If we failed to find a page in the DOM, check the URL to see if it
		// refers to the first page in the application. If it isn't a reference
		// to the first page and refers to non-existent embedded page, error out.
		if ( page.length === 0 ) {
			if ( $.mobile.firstPage && path.isFirstPageUrl( fileUrl ) ) {
				// Check to make sure our cached-first-page is actually
				// in the DOM. Some user deployed apps are pruning the first
				// page from the DOM for various reasons, we check for this
				// case here because we don't want a first-page with an id
				// falling through to the non-existent embedded page error
				// case. If the first-page is not in the DOM, then we let
				// things fall through to the ajax loading code below so
				// that it gets reloaded.
				if ( $.mobile.firstPage.parent().length ) {
					page = $( $.mobile.firstPage );
				}
			} else if ( path.isEmbeddedPage( fileUrl )  ) {
				deferred.reject( absUrl, options );
				return deferred.promise();
			}
		}

		// Reset base to the default document base.
		if ( base ) {
			base.reset();
		}

		// If the page we are interested in is already in the DOM,
		// and the caller did not indicate that we should force a
		// reload of the file, we are done. Otherwise, track the
		// existing page as a duplicated.
		if ( page.length ) {
			if ( !settings.reloadPage ) {
				enhancePage( page, settings.role );
				deferred.resolve( absUrl, options, page );
				return deferred.promise();
			}
			dupCachedPage = page;
		}

		var mpc = settings.pageContainer,
			pblEvent = new $.Event( "pagebeforeload" ),
			triggerData = { url: url, absUrl: absUrl, dataUrl: dataUrl, deferred: deferred, options: settings };

		// Let listeners know we're about to load a page.
		mpc.trigger( pblEvent, triggerData );

		// If the default behavior is prevented, stop here!
		if( pblEvent.isDefaultPrevented() ){
			return deferred.promise();
		}

		if ( settings.showLoadMsg ) {

			// This configurable timeout allows cached pages a brief delay to load without showing a message
			var loadMsgDelay = setTimeout(function(){
					$.mobile.showPageLoadingMsg();
				}, settings.loadMsgDelay ),

				// Shared logic for clearing timeout and removing message.
				hideMsg = function(){

					// Stop message show timer
					clearTimeout( loadMsgDelay );

					// Hide loading message
					$.mobile.hidePageLoadingMsg();
				};
		}

		if ( !( $.mobile.allowCrossDomainPages || path.isSameDomain( documentUrl, absUrl ) ) ) {
			deferred.reject( absUrl, options );
		} else {
			// Load the new page.
			$.ajax({
				url: fileUrl,
				type: settings.type,
				data: settings.data,
				dataType: "html",
				success: function( html, textStatus, xhr ) {
					//pre-parse html to check for a data-url,
					//use it as the new fileUrl, base path, etc
					var all = $( "<div></div>" ),

						//page title regexp
						newPageTitle = html.match( /<title[^>]*>([^<]*)/ ) && RegExp.$1,

						// TODO handle dialogs again
						pageElemRegex = new RegExp( "(<[^>]+\\bdata-" + $.mobile.ns + "role=[\"']?page[\"']?[^>]*>)" ),
						dataUrlRegex = new RegExp( "\\bdata-" + $.mobile.ns + "url=[\"']?([^\"'>]*)[\"']?" );


					// data-url must be provided for the base tag so resource requests can be directed to the
					// correct url. loading into a temprorary element makes these requests immediately
					if( pageElemRegex.test( html )
							&& RegExp.$1
							&& dataUrlRegex.test( RegExp.$1 )
							&& RegExp.$1 ) {
						url = fileUrl = path.getFilePath( RegExp.$1 );
					}

					if ( base ) {
						base.set( fileUrl );
					}

					//workaround to allow scripts to execute when included in page divs
					all.get( 0 ).innerHTML = html;
					page = all.find( ":jqmData(role='page'), :jqmData(role='dialog')" ).first();

					//if page elem couldn't be found, create one and insert the body element's contents
					if( !page.length ){
						page = $( "<div data-" + $.mobile.ns + "role='page'>" + html.split( /<\/?body[^>]*>/gmi )[1] + "</div>" );
					}

					if ( newPageTitle && !page.jqmData( "title" ) ) {
						if ( ~newPageTitle.indexOf( "&" ) ) {
							newPageTitle = $( "<div>" + newPageTitle + "</div>" ).text();
						}
						page.jqmData( "title", newPageTitle );
					}

					//rewrite src and href attrs to use a base url
					if( !$.support.dynamicBaseTag ) {
						var newPath = path.get( fileUrl );
						page.find( "[src], link[href], a[rel='external'], :jqmData(ajax='false'), a[target]" ).each(function() {
							var thisAttr = $( this ).is( '[href]' ) ? 'href' :
									$(this).is('[src]') ? 'src' : 'action',
								thisUrl = $( this ).attr( thisAttr );

							// XXX_jblas: We need to fix this so that it removes the document
							//            base URL, and then prepends with the new page URL.
							//if full path exists and is same, chop it - helps IE out
							thisUrl = thisUrl.replace( location.protocol + '//' + location.host + location.pathname, '' );

							if( !/^(\w+:|#|\/)/.test( thisUrl ) ) {
								$( this ).attr( thisAttr, newPath + thisUrl );
							}
						});
					}

					//append to page and enhance
					// TODO taging a page with external to make sure that embedded pages aren't removed
					//      by the various page handling code is bad. Having page handling code in many
					//      places is bad. Solutions post 1.0
					page
						.attr( "data-" + $.mobile.ns + "url", path.convertUrlToDataUrl( fileUrl ) )
						.attr( "data-" + $.mobile.ns + "external-page", true )
						.appendTo( settings.pageContainer );

					// wait for page creation to leverage options defined on widget
					page.one( 'pagecreate', $.mobile._bindPageRemove );

					enhancePage( page, settings.role );

					// Enhancing the page may result in new dialogs/sub pages being inserted
					// into the DOM. If the original absUrl refers to a sub-page, that is the
					// real page we are interested in.
					if ( absUrl.indexOf( "&" + $.mobile.subPageUrlKey ) > -1 ) {
						page = settings.pageContainer.children( ":jqmData(url='" + dataUrl + "')" );
					}

					//bind pageHide to removePage after it's hidden, if the page options specify to do so

					// Remove loading message.
					if ( settings.showLoadMsg ) {
						hideMsg();
					}

					// Add the page reference and xhr to our triggerData.
					triggerData.xhr = xhr;
					triggerData.textStatus = textStatus;
					triggerData.page = page;

					// Let listeners know the page loaded successfully.
					settings.pageContainer.trigger( "pageload", triggerData );

					deferred.resolve( absUrl, options, page, dupCachedPage );
				},
				error: function( xhr, textStatus, errorThrown ) {
					//set base back to current path
					if( base ) {
						base.set( path.get() );
					}

					// Add error info to our triggerData.
					triggerData.xhr = xhr;
					triggerData.textStatus = textStatus;
					triggerData.errorThrown = errorThrown;

					var plfEvent = new $.Event( "pageloadfailed" );

					// Let listeners know the page load failed.
					settings.pageContainer.trigger( plfEvent, triggerData );

					// If the default behavior is prevented, stop here!
					// Note that it is the responsibility of the listener/handler
					// that called preventDefault(), to resolve/reject the
					// deferred object within the triggerData.
					if( plfEvent.isDefaultPrevented() ){
						return;
					}

					// Remove loading message.
					if ( settings.showLoadMsg ) {

						// Remove loading message.
						hideMsg();

						// show error message
						$.mobile.showPageLoadingMsg( $.mobile.pageLoadErrorMessageTheme, $.mobile.pageLoadErrorMessage, true );

						// hide after delay
						setTimeout( $.mobile.hidePageLoadingMsg, 1500 );
					}

					deferred.reject( absUrl, options );
				}
			});
		}

		return deferred.promise();
	};

	$.mobile.loadPage.defaults = {
		type: "get",
		data: undefined,
		reloadPage: false,
		role: undefined, // By default we rely on the role defined by the @data-role attribute.
		showLoadMsg: false,
		pageContainer: undefined,
		loadMsgDelay: 50 // This delay allows loads that pull from browser cache to occur without showing the loading message.
	};

	// Show a specific page in the page container.
	$.mobile.changePage = function( toPage, options ) {
		// If we are in the midst of a transition, queue the current request.
		// We'll call changePage() once we're done with the current transition to
		// service the request.
		if( isPageTransitioning ) {
			pageTransitionQueue.unshift( arguments );
			return;
		}

		var settings = $.extend( {}, $.mobile.changePage.defaults, options );

		// Make sure we have a pageContainer to work with.
		settings.pageContainer = settings.pageContainer || $.mobile.pageContainer;

		// Make sure we have a fromPage.
		settings.fromPage = settings.fromPage || $.mobile.activePage;

		var mpc = settings.pageContainer,
			pbcEvent = new $.Event( "pagebeforechange" ),
			triggerData = { toPage: toPage, options: settings };

		// Let listeners know we're about to change the current page.
		mpc.trigger( pbcEvent, triggerData );

		// If the default behavior is prevented, stop here!
		if( pbcEvent.isDefaultPrevented() ){
			return;
		}

		// We allow "pagebeforechange" observers to modify the toPage in the trigger
		// data to allow for redirects. Make sure our toPage is updated.

		toPage = triggerData.toPage;

		// Set the isPageTransitioning flag to prevent any requests from
		// entering this method while we are in the midst of loading a page
		// or transitioning.

		isPageTransitioning = true;

		// If the caller passed us a url, call loadPage()
		// to make sure it is loaded into the DOM. We'll listen
		// to the promise object it returns so we know when
		// it is done loading or if an error ocurred.
		if ( typeof toPage == "string" ) {
			$.mobile.loadPage( toPage, settings )
				.done(function( url, options, newPage, dupCachedPage ) {
					isPageTransitioning = false;
					options.duplicateCachedPage = dupCachedPage;
					$.mobile.changePage( newPage, options );
				})
				.fail(function( url, options ) {
					isPageTransitioning = false;

					//clear out the active button state
					removeActiveLinkClass( true );

					//release transition lock so navigation is free again
					releasePageTransitionLock();
					settings.pageContainer.trigger( "pagechangefailed", triggerData );
				});
			return;
		}

		// If we are going to the first-page of the application, we need to make
		// sure settings.dataUrl is set to the application document url. This allows
		// us to avoid generating a document url with an id hash in the case where the
		// first-page of the document has an id attribute specified.
		if ( toPage[ 0 ] === $.mobile.firstPage[ 0 ] && !settings.dataUrl ) {
			settings.dataUrl = documentUrl.hrefNoHash;
		}

		// The caller passed us a real page DOM element. Update our
		// internal state and then trigger a transition to the page.
		var fromPage = settings.fromPage,
			url = ( settings.dataUrl && path.convertUrlToDataUrl( settings.dataUrl ) ) || toPage.jqmData( "url" ),
			// The pageUrl var is usually the same as url, except when url is obscured as a dialog url. pageUrl always contains the file path
			pageUrl = url,
			fileUrl = path.getFilePath( url ),
			active = urlHistory.getActive(),
			activeIsInitialPage = urlHistory.activeIndex === 0,
			historyDir = 0,
			pageTitle = document.title,
			isDialog = settings.role === "dialog" || toPage.jqmData( "role" ) === "dialog";

		// By default, we prevent changePage requests when the fromPage and toPage
		// are the same element, but folks that generate content manually/dynamically
		// and reuse pages want to be able to transition to the same page. To allow
		// this, they will need to change the default value of allowSamePageTransition
		// to true, *OR*, pass it in as an option when they manually call changePage().
		// It should be noted that our default transition animations assume that the
		// formPage and toPage are different elements, so they may behave unexpectedly.
		// It is up to the developer that turns on the allowSamePageTransitiona option
		// to either turn off transition animations, or make sure that an appropriate
		// animation transition is used.
		if( fromPage && fromPage[0] === toPage[0] && !settings.allowSamePageTransition ) {
			isPageTransitioning = false;
			mpc.trigger( "pagechange", triggerData );
			return;
		}

		// We need to make sure the page we are given has already been enhanced.
		enhancePage( toPage, settings.role );

		// If the changePage request was sent from a hashChange event, check to see if the
		// page is already within the urlHistory stack. If so, we'll assume the user hit
		// the forward/back button and will try to match the transition accordingly.
		if( settings.fromHashChange ) {
			urlHistory.directHashChange({
				currentUrl:	url,
				isBack:		function() { historyDir = -1; },
				isForward:	function() { historyDir = 1; }
			});
		}

		// Kill the keyboard.
		// XXX_jblas: We need to stop crawling the entire document to kill focus. Instead,
		//            we should be tracking focus with a delegate() handler so we already have
		//            the element in hand at this point.
		// Wrap this in a try/catch block since IE9 throw "Unspecified error" if document.activeElement
		// is undefined when we are in an IFrame.
		try {
			if(document.activeElement && document.activeElement.nodeName.toLowerCase() != 'body') {
				$(document.activeElement).blur();
			} else {
				$( "input:focus, textarea:focus, select:focus" ).blur();
			}
		} catch(e) {}

		// If we're displaying the page as a dialog, we don't want the url
		// for the dialog content to be used in the hash. Instead, we want
		// to append the dialogHashKey to the url of the current page.
		if ( isDialog && active ) {
			// on the initial page load active.url is undefined and in that case should
			// be an empty string. Moving the undefined -> empty string back into
			// urlHistory.addNew seemed imprudent given undefined better represents
			// the url state
			url = ( active.url || "" ) + dialogHashKey;
		}

		// Set the location hash.
		if( settings.changeHash !== false && url ) {
			//disable hash listening temporarily
			urlHistory.ignoreNextHashChange = true;
			//update hash and history
			path.set( url );
		}

		// if title element wasn't found, try the page div data attr too
		// If this is a deep-link or a reload ( active === undefined ) then just use pageTitle
		var newPageTitle = ( !active )? pageTitle : toPage.jqmData( "title" ) || toPage.children(":jqmData(role='header')").find(".ui-title" ).getEncodedText();
		if( !!newPageTitle && pageTitle == document.title ) {
			pageTitle = newPageTitle;
		}
		if ( !toPage.jqmData( "title" ) ) {
			toPage.jqmData( "title", pageTitle );
		}

		// Make sure we have a transition defined.
		settings.transition = settings.transition
			|| ( ( historyDir && !activeIsInitialPage ) ? active.transition : undefined )
			|| ( isDialog ? $.mobile.defaultDialogTransition : $.mobile.defaultPageTransition );

		//add page to history stack if it's not back or forward
		if( !historyDir ) {
			urlHistory.addNew( url, settings.transition, pageTitle, pageUrl, settings.role );
		}

		//set page title
		document.title = urlHistory.getActive().title;

		//set "toPage" as activePage
		$.mobile.activePage = toPage;

		// If we're navigating back in the URL history, set reverse accordingly.
		settings.reverse = settings.reverse || historyDir < 0;

		transitionPages( toPage, fromPage, settings.transition, settings.reverse )
			.done(function( name, reverse, $to, $from, alreadyFocused ) {
				removeActiveLinkClass();

				//if there's a duplicateCachedPage, remove it from the DOM now that it's hidden
				if ( settings.duplicateCachedPage ) {
					settings.duplicateCachedPage.remove();
				}

				// Send focus to the newly shown page. Moved from promise .done binding in transitionPages
				// itself to avoid ie bug that reports offsetWidth as > 0 (core check for visibility)
				// despite visibility: hidden addresses issue #2965
				// https://github.com/jquery/jquery-mobile/issues/2965
				if( !alreadyFocused ){
					$.mobile.focusPage( toPage );
				}

				releasePageTransitionLock();

				// Let listeners know we're all done changing the current page.
				mpc.trigger( "pagechange", triggerData );
			});
	};

	$.mobile.changePage.defaults = {
		transition: undefined,
		reverse: false,
		changeHash: true,
		fromHashChange: false,
		role: undefined, // By default we rely on the role defined by the @data-role attribute.
		duplicateCachedPage: undefined,
		pageContainer: undefined,
		showLoadMsg: true, //loading message shows by default when pages are being fetched during changePage
		dataUrl: undefined,
		fromPage: undefined,
		allowSamePageTransition: false
	};

/* Event Bindings - hashchange, submit, and click */
	function findClosestLink( ele )
	{
		while ( ele ) {
			// Look for the closest element with a nodeName of "a".
			// Note that we are checking if we have a valid nodeName
			// before attempting to access it. This is because the
			// node we get called with could have originated from within
			// an embedded SVG document where some symbol instance elements
			// don't have nodeName defined on them, or strings are of type
			// SVGAnimatedString.
			if ( ( typeof ele.nodeName === "string" ) && ele.nodeName.toLowerCase() == "a" ) {
				break;
			}
			ele = ele.parentNode;
		}
		return ele;
	}

	// The base URL for any given element depends on the page it resides in.
	function getClosestBaseUrl( ele )
	{
		// Find the closest page and extract out its url.
		var url = $( ele ).closest( ".ui-page" ).jqmData( "url" ),
			base = documentBase.hrefNoHash;

		if ( !url || !path.isPath( url ) ) {
			url = base;
		}

		return path.makeUrlAbsolute( url, base);
	}


	//The following event bindings should be bound after mobileinit has been triggered
	//the following function is called in the init file
	$.mobile._registerInternalEvents = function(){

		//bind to form submit events, handle with Ajax
		$( document ).delegate( "form", "submit", function( event ) {
			var $this = $( this );

			if( !$.mobile.ajaxEnabled ||
					// test that the form is, itself, ajax false
					$this.is(":jqmData(ajax='false')") ||
					// test that $.mobile.ignoreContentEnabled is set and
					// the form or one of it's parents is ajax=false
					!$this.jqmHijackable().length ) {
				return;
			}

			var type = $this.attr( "method" ),
				target = $this.attr( "target" ),
				url = $this.attr( "action" );

			// If no action is specified, browsers default to using the
			// URL of the document containing the form. Since we dynamically
			// pull in pages from external documents, the form should submit
			// to the URL for the source document of the page containing
			// the form.
			if ( !url ) {
				// Get the @data-url for the page containing the form.
				url = getClosestBaseUrl( $this );
				if ( url === documentBase.hrefNoHash ) {
					// The url we got back matches the document base,
					// which means the page must be an internal/embedded page,
					// so default to using the actual document url as a browser
					// would.
					url = documentUrl.hrefNoSearch;
				}
			}

			url = path.makeUrlAbsolute(  url, getClosestBaseUrl($this) );

			//external submits use regular HTTP
			if( path.isExternal( url ) || target ) {
				return;
			}

			$.mobile.changePage(
				url,
				{
					type:		type && type.length && type.toLowerCase() || "get",
					data:		$this.serialize(),
					transition:	$this.jqmData( "transition" ),
					direction:	$this.jqmData( "direction" ),
					reloadPage:	true
				}
			);
			event.preventDefault();
		});

		//add active state on vclick
		$( document ).bind( "vclick", function( event ) {
			// if this isn't a left click we don't care. Its important to note
			// that when the virtual event is generated it will create the which attr
			if ( event.which > 1 || !$.mobile.linkBindingEnabled ) {
				return;
			}

			var link = findClosestLink( event.target );

			// split from the previous return logic to avoid find closest where possible
			// TODO teach $.mobile.hijackable to operate on raw dom elements so the link wrapping
			// can be avoided
			if ( !$(link).jqmHijackable().length ) {
				return;
			}

			if ( link ) {
				if ( path.parseUrl( link.getAttribute( "href" ) || "#" ).hash !== "#" ) {
					removeActiveLinkClass( true );
					$activeClickedLink = $( link ).closest( ".ui-btn" ).not( ".ui-disabled" );
					$activeClickedLink.addClass( $.mobile.activeBtnClass );
					$( "." + $.mobile.activePageClass + " .ui-btn" ).not( link ).blur();

					// By caching the href value to data and switching the href to a #, we can avoid address bar showing in iOS. The click handler resets the href during its initial steps if this data is present
					$( link )
						.jqmData( "href", $( link  ).attr( "href" )  )
						.attr( "href", "#" );
				}
			}
		});

		// click routing - direct to HTTP or Ajax, accordingly
		$( document ).bind( "click", function( event ) {
			if( !$.mobile.linkBindingEnabled ){
				return;
			}

			var link = findClosestLink( event.target ), $link = $( link ), httpCleanup;

			// If there is no link associated with the click or its not a left
			// click we want to ignore the click
			// TODO teach $.mobile.hijackable to operate on raw dom elements so the link wrapping
			// can be avoided
			if ( !link || event.which > 1 || !$link.jqmHijackable().length ) {
				return;
			}

			//remove active link class if external (then it won't be there if you come back)
			httpCleanup = function(){
				window.setTimeout( function() { removeActiveLinkClass( true ); }, 200 );
			};

			// If there's data cached for the real href value, set the link's href back to it again. This pairs with an address bar workaround from the vclick handler
			if( $link.jqmData( "href" ) ){
				$link.attr( "href", $link.jqmData( "href" ) );
			}

			//if there's a data-rel=back attr, go back in history
			if( $link.is( ":jqmData(rel='back')" ) ) {
				window.history.back();
				return false;
			}

			var baseUrl = getClosestBaseUrl( $link ),

				//get href, if defined, otherwise default to empty hash
				href = path.makeUrlAbsolute( $link.attr( "href" ) || "#", baseUrl );

			//if ajax is disabled, exit early
			if( !$.mobile.ajaxEnabled && !path.isEmbeddedPage( href ) ){
				httpCleanup();
				//use default click handling
				return;
			}

			// XXX_jblas: Ideally links to application pages should be specified as
			//            an url to the application document with a hash that is either
			//            the site relative path or id to the page. But some of the
			//            internal code that dynamically generates sub-pages for nested
			//            lists and select dialogs, just write a hash in the link they
			//            create. This means the actual URL path is based on whatever
			//            the current value of the base tag is at the time this code
			//            is called. For now we are just assuming that any url with a
			//            hash in it is an application page reference.
			if ( href.search( "#" ) != -1 ) {
				href = href.replace( /[^#]*#/, "" );
				if ( !href ) {
					//link was an empty hash meant purely
					//for interaction, so we ignore it.
					event.preventDefault();
					return;
				} else if ( path.isPath( href ) ) {
					//we have apath so make it the href we want to load.
					href = path.makeUrlAbsolute( href, baseUrl );
				} else {
					//we have a simple id so use the documentUrl as its base.
					href = path.makeUrlAbsolute( "#" + href, documentUrl.hrefNoHash );
				}
			}

				// Should we handle this link, or let the browser deal with it?
			var useDefaultUrlHandling = $link.is( "[rel='external']" ) || $link.is( ":jqmData(ajax='false')" ) || $link.is( "[target]" ),

				// Some embedded browsers, like the web view in Phone Gap, allow cross-domain XHR
				// requests if the document doing the request was loaded via the file:// protocol.
				// This is usually to allow the application to "phone home" and fetch app specific
				// data. We normally let the browser handle external/cross-domain urls, but if the
				// allowCrossDomainPages option is true, we will allow cross-domain http/https
				// requests to go through our page loading logic.
				isCrossDomainPageLoad = ( $.mobile.allowCrossDomainPages && documentUrl.protocol === "file:" && href.search( /^https?:/ ) != -1 ),

				//check for protocol or rel and its not an embedded page
				//TODO overlap in logic from isExternal, rel=external check should be
				//     moved into more comprehensive isExternalLink
				isExternal = useDefaultUrlHandling || ( path.isExternal( href ) && !isCrossDomainPageLoad );

			if( isExternal ) {
				httpCleanup();
				//use default click handling
				return;
			}

			//use ajax
			var transition = $link.jqmData( "transition" ),
				direction = $link.jqmData( "direction" ),
				reverse = ( direction && direction === "reverse" ) ||
							// deprecated - remove by 1.0
							$link.jqmData( "back" ),

				//this may need to be more specific as we use data-rel more
				role = $link.attr( "data-" + $.mobile.ns + "rel" ) || undefined;

			$.mobile.changePage( href, { transition: transition, reverse: reverse, role: role } );
			event.preventDefault();
		});

		//prefetch pages when anchors with data-prefetch are encountered
		$( document ).delegate( ".ui-page", "pageshow.prefetch", function() {
			var urls = [];
			$( this ).find( "a:jqmData(prefetch)" ).each(function(){
				var $link = $(this),
					url = $link.attr( "href" );

				if ( url && $.inArray( url, urls ) === -1 ) {
					urls.push( url );

					$.mobile.loadPage( url, {role: $link.attr("data-" + $.mobile.ns + "rel")} );
				}
			});
		});

		$.mobile._handleHashChange = function( hash ) {
			//find first page via hash
			var to = path.stripHash( hash ),
				//transition is false if it's the first page, undefined otherwise (and may be overridden by default)
				transition = $.mobile.urlHistory.stack.length === 0 ? "none" : undefined,

				// default options for the changPage calls made after examining the current state
				// of the page and the hash
				changePageOptions = {
					transition: transition,
					changeHash: false,
					fromHashChange: true
				};

			//if listening is disabled (either globally or temporarily), or it's a dialog hash
			if( !$.mobile.hashListeningEnabled || urlHistory.ignoreNextHashChange ) {
				urlHistory.ignoreNextHashChange = false;
				return;
			}

			// special case for dialogs
			if( urlHistory.stack.length > 1 && to.indexOf( dialogHashKey ) > -1 ) {

				// If current active page is not a dialog skip the dialog and continue
				// in the same direction
				if(!$.mobile.activePage.is( ".ui-dialog" )) {
					//determine if we're heading forward or backward and continue accordingly past
					//the current dialog
					urlHistory.directHashChange({
						currentUrl: to,
						isBack: function() { window.history.back(); },
						isForward: function() { window.history.forward(); }
					});

					// prevent changePage()
					return;
				} else {
					// if the current active page is a dialog and we're navigating
					// to a dialog use the dialog objected saved in the stack
					urlHistory.directHashChange({
						currentUrl: to,

						// regardless of the direction of the history change
						// do the following
						either: function( isBack ) {
							var active = $.mobile.urlHistory.getActive();

							to = active.pageUrl;

							// make sure to set the role, transition and reversal
							// as most of this is lost by the domCache cleaning
							$.extend( changePageOptions, {
								role: active.role,
								transition:	 active.transition,
								reverse: isBack
							});
						}
					});
				}
			}

			//if to is defined, load it
			if ( to ) {
				// At this point, 'to' can be one of 3 things, a cached page element from
				// a history stack entry, an id, or site-relative/absolute URL. If 'to' is
				// an id, we need to resolve it against the documentBase, not the location.href,
				// since the hashchange could've been the result of a forward/backward navigation
				// that crosses from an external page/dialog to an internal page/dialog.
				to = ( typeof to === "string" && !path.isPath( to ) ) ? ( path.makeUrlAbsolute( '#' + to, documentBase ) ) : to;
				$.mobile.changePage( to, changePageOptions );
			}	else {
				//there's no hash, go to the first page in the dom
				$.mobile.changePage( $.mobile.firstPage, changePageOptions );
			}
		};

		//hashchange event handler
		$window.bind( "hashchange", function( e, triggered ) {
			$.mobile._handleHashChange( location.hash );
		});

		//set page min-heights to be device specific
		$( document ).bind( "pageshow", resetActivePageHeight );
		$( window ).bind( "throttledresize", resetActivePageHeight );

	};//_registerInternalEvents callback

})( jQuery );

( function( $, window ) {
	// For now, let's Monkeypatch this onto the end of $.mobile._registerInternalEvents
	// Scope self to pushStateHandler so we can reference it sanely within the
	// methods handed off as event handlers
	var	pushStateHandler = {},
		self = pushStateHandler,
		$win = $( window ),
		url = $.mobile.path.parseUrl( location.href );

	$.extend( pushStateHandler, {
		// TODO move to a path helper, this is rather common functionality
		initialFilePath: (function() {
			return url.pathname + url.search;
		})(),

		initialHref: url.hrefNoHash,

		state: function() {
			return {
				hash: location.hash || "#" + self.initialFilePath,
				title: document.title,

				// persist across refresh
				initialHref: self.initialHref
			};
		},

		resetUIKeys: function( url ) {
			var dialog = $.mobile.dialogHashKey,
				subkey = "&" + $.mobile.subPageUrlKey,
				dialogIndex = url.indexOf( dialog );

			if( dialogIndex > -1 ) {
				url = url.slice( 0, dialogIndex ) + "#" + url.slice( dialogIndex );
			} else if( url.indexOf( subkey ) > -1 ) {
				url = url.split( subkey ).join( "#" + subkey );
			}

			return url;
		},

		hashValueAfterReset: function( url ) {
			var resetUrl = self.resetUIKeys( url );
			return $.mobile.path.parseUrl( resetUrl ).hash;
		},

		// TODO sort out a single barrier to hashchange functionality
		nextHashChangePrevented: function( value ) {
			$.mobile.urlHistory.ignoreNextHashChange = value;
			self.onHashChangeDisabled = value;
		},

		// on hash change we want to clean up the url
		// NOTE this takes place *after* the vanilla navigation hash change
		// handling has taken place and set the state of the DOM
		onHashChange: function( e ) {
			// disable this hash change
			if( self.onHashChangeDisabled ){
				return;
			}

			var href, state,
				hash = location.hash,
				isPath = $.mobile.path.isPath( hash ),
				resolutionUrl = isPath ? location.href : $.mobile.getDocumentUrl();

			hash = isPath ? hash.replace( "#", "" ) : hash;


			// propulate the hash when its not available
			state = self.state();

			// make the hash abolute with the current href
			href = $.mobile.path.makeUrlAbsolute( hash, resolutionUrl );

			if ( isPath ) {
				href = self.resetUIKeys( href );
			}

			// replace the current url with the new href and store the state
			// Note that in some cases we might be replacing an url with the
			// same url. We do this anyways because we need to make sure that
			// all of our history entries have a state object associated with
			// them. This allows us to work around the case where window.history.back()
			// is called to transition from an external page to an embedded page.
			// In that particular case, a hashchange event is *NOT* generated by the browser.
			// Ensuring each history entry has a state object means that onPopState()
			// will always trigger our hashchange callback even when a hashchange event
			// is not fired.
			history.replaceState( state, document.title, href );
		},

		// on popstate (ie back or forward) we need to replace the hash that was there previously
		// cleaned up by the additional hash handling
		onPopState: function( e ) {
			var poppedState = e.originalEvent.state,
				timeout, fromHash, toHash, hashChanged;

			// if there's no state its not a popstate we care about, eg chrome's initial popstate
			if( poppedState ) {
				// the active url in the history stack will still be from the previous state
				// so we can use it to verify if a hashchange will be fired from the popstate
				fromHash = self.hashValueAfterReset( $.mobile.urlHistory.getActive().url );

				// the hash stored in the state popped off the stack will be our currenturl or
				// the url to which we wish to navigate
				toHash = self.hashValueAfterReset( poppedState.hash.replace("#", "") );

				// if the hashes of the urls are different we must assume that the browser
				// will fire a hashchange
				hashChanged = fromHash !== toHash;

				// unlock hash handling once the hashchange caused be the popstate has fired
				if( hashChanged ) {
					$win.one( "hashchange.pushstate", function() {
						self.nextHashChangePrevented( false );
					});
				}

				// enable hash handling for the the _handleHashChange call
				self.nextHashChangePrevented( false );

				// change the page based on the hash
				$.mobile._handleHashChange( poppedState.hash );

				// only prevent another hash change handling if a hash change will be fired
				// by the browser
				if( hashChanged ) {
					// disable hash handling until one of the above timers fires
					self.nextHashChangePrevented( true );
				}
			}
		},

		init: function() {
			$win.bind( "hashchange", self.onHashChange );

			// Handle popstate events the occur through history changes
			$win.bind( "popstate", self.onPopState );

			// if there's no hash, we need to replacestate for returning to home
			if ( location.hash === "" ) {
				history.replaceState( self.state(), document.title, location.href );
			}
		}
	});

	$( function() {
		if( $.mobile.pushStateEnabled && $.support.pushState ){
			pushStateHandler.init();
		}
	});
})( jQuery, this );

/*
* fallback transition for pop in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.pop = "fade";

})( jQuery, this );

/*
* fallback transition for slide in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.slide = "fade";

})( jQuery, this );

/*
* fallback transition for slidedown in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.slidedown = "fade";

})( jQuery, this );

/*
* fallback transition for slideup in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.slideup = "fade";

})( jQuery, this );

/*
* fallback transition for flip in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.flip = "fade";

})( jQuery, this );

/*
* fallback transition for flow in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.flow = "fade";

})( jQuery, this );

/*
* fallback transition for turn in non-3D supporting browsers (which tend to handle complex transitions poorly in general
*/

(function( $, window, undefined ) {

$.mobile.transitionFallbacks.turn = "fade";

})( jQuery, this );

(function( $, undefined ) {

$.mobile.page.prototype.options.degradeInputs = {
	color: false,
	date: false,
	datetime: false,
	"datetime-local": false,
	email: false,
	month: false,
	number: false,
	range: "number",
	search: "text",
	tel: false,
	time: false,
	url: false,
	week: false
};


//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){

	var page = $.mobile.closestPageData($(e.target)), options;

	if( !page ) {
		return;
	}

	options = page.options;

	// degrade inputs to avoid poorly implemented native functionality
	$( e.target ).find( "input" ).not( page.keepNativeSelector() ).each(function() {
		var $this = $( this ),
			type = this.getAttribute( "type" ),
			optType = options.degradeInputs[ type ] || "text";

		if ( options.degradeInputs[ type ] ) {
			var html = $( "<div>" ).html( $this.clone() ).html(),
				// In IE browsers, the type sometimes doesn't exist in the cloned markup, so we replace the closing tag instead
				hasType = html.indexOf( " type=" ) > -1,
				findstr = hasType ? /\s+type=["']?\w+['"]?/ : /\/?>/,
				repstr = " type=\"" + optType + "\" data-" + $.mobile.ns + "type=\"" + type + "\"" + ( hasType ? "" : ">" );

			$this.replaceWith( html.replace( findstr, repstr ) );
		}
	});

});

})( jQuery );

(function( $, window, undefined ) {

$.widget( "mobile.dialog", $.mobile.widget, {
	options: {
		closeBtnText 	: "Close",
		overlayTheme	: "a",
		initSelector	: ":jqmData(role='dialog')"
	},
	_create: function() {
		var self = this,
			$el = this.element,
			headerCloseButton = $( "<a href='#' data-" + $.mobile.ns + "icon='delete' data-" + $.mobile.ns + "iconpos='notext'>"+ this.options.closeBtnText + "</a>" ),
			dialogWrap = $("<div/>", {
					"role" : "dialog",
					"class" : "ui-dialog-contain ui-corner-all ui-overlay-shadow"
				});

		$el.addClass( "ui-dialog ui-overlay-" + this.options.overlayTheme );
		
		// Class the markup for dialog styling
		// Set aria role
		$el
			.wrapInner( dialogWrap )
			.find( ":jqmData(role='header')" )
				.prepend( headerCloseButton )
			.end()
			.find(':first-child')
				.addClass( "ui-corner-top" )
			.end()
			.find( ":last-child" )
				.addClass( "ui-corner-bottom" );

		// this must be an anonymous function so that select menu dialogs can replace
		// the close method. This is a change from previously just defining data-rel=back
		// on the button and letting nav handle it
		//
		// Use click rather than vclick in order to prevent the possibility of unintentionally
		// reopening the dialog if the dialog opening item was directly under the close button.
		headerCloseButton.bind( "click", function() {
			self.close();
		});

		/* bind events
			- clicks and submits should use the closing transition that the dialog opened with
			  unless a data-transition is specified on the link/form
			- if the click was on the close button, or the link has a data-rel="back" it'll go back in history naturally
		*/
		$el.bind( "vclick submit", function( event ) {
			var $target = $( event.target ).closest( event.type === "vclick" ? "a" : "form" ),
				active;

			if ( $target.length && !$target.jqmData( "transition" ) ) {

				active = $.mobile.urlHistory.getActive() || {};

				$target.attr( "data-" + $.mobile.ns + "transition", ( active.transition || $.mobile.defaultDialogTransition ) )
					.attr( "data-" + $.mobile.ns + "direction", "reverse" );
			}
		})
		.bind( "pagehide", function( e, ui ) {
			$( this ).find( "." + $.mobile.activeBtnClass ).removeClass( $.mobile.activeBtnClass );
			
			// if there's an overlay theme, we're going to remove it from the page container.
			// First though, check that the incoming page isn't a dialog with the same theme. If so, don't remove.
			if( self.options.overlayTheme ){
				if( !ui.nextPage || !ui.nextPage.is( ".ui-dialog.ui-overlay-" + self.options.overlayTheme ) ){
					$.mobile.pageContainer.removeClass( "ui-overlay-" + self.options.overlayTheme );
				}	
			}
		})
		.bind( "pagebeforeshow", function(){
			if( self.options.overlayTheme ){
				$.mobile.pageContainer.addClass( "ui-overlay-" + self.options.overlayTheme );
			}
		});
	},

	// Close method goes back in history
	close: function() {
		window.history.back();
	}
});

//auto self-init widgets
$( document ).delegate( $.mobile.dialog.prototype.options.initSelector, "pagecreate", function(){
	$.mobile.dialog.prototype.enhance( this );
});

})( jQuery, this );

(function( $, undefined ) {

$.fn.fieldcontain = function( options ) {
	return this.addClass( "ui-field-contain ui-body ui-br" );
};

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$( ":jqmData(role='fieldcontain')", e.target ).jqmEnhanceable().fieldcontain();
});

})( jQuery );

(function( $, undefined ) {

$.fn.grid = function( options ) {
	return this.each(function() {

		var $this = $( this ),
			o = $.extend({
				grid: null
			},options),
			$kids = $this.children(),
			gridCols = {solo:1, a:2, b:3, c:4, d:5},
			grid = o.grid,
			iterator;

			if ( !grid ) {
				if ( $kids.length <= 5 ) {
					for ( var letter in gridCols ) {
						if ( gridCols[ letter ] === $kids.length ) {
							grid = letter;
						}
					}
				} else {
					grid = "a";
				}
			}
			iterator = gridCols[grid];

		$this.addClass( "ui-grid-" + grid );

		$kids.filter( ":nth-child(" + iterator + "n+1)" ).addClass( "ui-block-a" );

		if ( iterator > 1 ) {
			$kids.filter( ":nth-child(" + iterator + "n+2)" ).addClass( "ui-block-b" );
		}
		if ( iterator > 2 ) {
			$kids.filter( ":nth-child(3n+3)" ).addClass( "ui-block-c" );
		}
		if ( iterator > 3 ) {
			$kids.filter( ":nth-child(4n+4)" ).addClass( "ui-block-d" );
		}
		if ( iterator > 4 ) {
			$kids.filter( ":nth-child(5n+5)" ).addClass( "ui-block-e" );
		}
	});
};
})( jQuery );

(function( $, undefined ) {

$( document ).bind( "pagecreate create", function( e ){
	$( ":jqmData(role='nojs')", e.target ).addClass( "ui-nojs" );
	
});

})( jQuery );

( function( $, undefined ) {

$.fn.buttonMarkup = function( options ) {
	var $workingSet = this;

	// Enforce options to be of type string
	options = ( options && ( $.type( options ) == "object" ) )? options : {};
	for ( var i = 0; i < $workingSet.length; i++ ) {
		var el = $workingSet.eq( i ),
			e = el[ 0 ],
			o = $.extend( {}, $.fn.buttonMarkup.defaults, {
				icon:       options.icon       !== undefined ? options.icon       : el.jqmData( "icon" ),
				iconpos:    options.iconpos    !== undefined ? options.iconpos    : el.jqmData( "iconpos" ),
				theme:      options.theme      !== undefined ? options.theme      : el.jqmData( "theme" ),
				inline:     options.inline     !== undefined ? options.inline     : el.jqmData( "inline" ),
				shadow:     options.shadow     !== undefined ? options.shadow     : el.jqmData( "shadow" ),
				corners:    options.corners    !== undefined ? options.corners    : el.jqmData( "corners" ),
				iconshadow: options.iconshadow !== undefined ? options.iconshadow : el.jqmData( "iconshadow" ),
				mini:       options.mini       !== undefined ? options.mini       : el.jqmData( "mini" )
			}, options ),

			// Classes Defined
			innerClass = "ui-btn-inner",
			textClass = "ui-btn-text",
			buttonClass, iconClass,
			// Button inner markup
			buttonInner,
			buttonText,
			buttonIcon,
			buttonElements;

		$.each(o, function(key, value) {
			e.setAttribute( "data-" + $.mobile.ns + key, value );
			el.jqmData(key, value);
		});

		// Check if this element is already enhanced
		buttonElements = $.data(((e.tagName === "INPUT" || e.tagName === "BUTTON") ? e.parentNode : e), "buttonElements")

		if (buttonElements) {
			e = buttonElements.outer;
			el = $(e);
			buttonInner = buttonElements.inner;
			buttonText = buttonElements.text;
			// We will recreate this icon below
			$(buttonElements.icon).remove();
			buttonElements.icon = null;
		}
		else {
			buttonInner = document.createElement( o.wrapperEls );
			buttonText = document.createElement( o.wrapperEls );
		}
		buttonIcon = o.icon ? document.createElement( "span" ) : null;

		if ( attachEvents && !buttonElements) {
			attachEvents();
		}

		// if not, try to find closest theme container
		if ( !o.theme ) {
			o.theme = $.mobile.getInheritedTheme( el, "c" );
		}

		buttonClass = "ui-btn ui-btn-up-" + o.theme;

		if ( o.inline ) {
			buttonClass += " ui-btn-inline";
		}

		if ( o.mini ) {
			buttonClass += " ui-mini";
		} else if ( o.mini && o.mini === false ) {
			buttonClass += " ui-fullsize"; // Used to control styling in headers/footers, where buttons default to `mini` style.
		}

		if ( o.icon ) {
			o.icon = "ui-icon-" + o.icon;
			o.iconpos = o.iconpos || "left";

			iconClass = "ui-icon " + o.icon;

			if ( o.iconshadow ) {
				iconClass += " ui-icon-shadow";
			}
		}

		if ( o.iconpos ) {
			buttonClass += " ui-btn-icon-" + o.iconpos;

			if ( o.iconpos == "notext" && !el.attr( "title" ) ) {
				el.attr( "title", el.getEncodedText() );
			}
		}

		if ( o.corners ) {
			buttonClass += " ui-btn-corner-all";
			innerClass += " ui-btn-corner-all";
		}

		if ( o.shadow ) {
			buttonClass += " ui-shadow";
		}

		if (buttonElements)
			el.removeClass((buttonElements.bcls || ""));
		el.removeClass( "ui-link" ).addClass( buttonClass );

		buttonInner.className = innerClass;

		buttonText.className = textClass;
		if (!buttonElements)
			buttonInner.appendChild( buttonText );
		if ( buttonIcon ) {
			buttonIcon.className = iconClass;
			if (!(buttonElements && buttonElements.icon))
				buttonInner.appendChild( buttonIcon );
		}

		while ( e.firstChild && !buttonElements) {
			buttonText.appendChild( e.firstChild );
		}

		if (!buttonElements)
			e.appendChild( buttonInner );

		// Assign a structure containing the elements of this button to the elements of this button. This
		// will allow us to recognize this as an already-enhanced button in future calls to buttonMarkup().
		buttonElements = {
			bcls  : buttonClass,
			outer : e,
			inner : buttonInner,
			text  : buttonText,
			icon  : buttonIcon
		};

		$.data(e,           'buttonElements', buttonElements);
		$.data(buttonInner, 'buttonElements', buttonElements);
		$.data(buttonText,  'buttonElements', buttonElements);
		if (buttonIcon)
			$.data(buttonIcon, 'buttonElements', buttonElements);
	}

	return this;
};

$.fn.buttonMarkup.defaults = {
	corners: true,
	shadow: true,
	iconshadow: true,
	inline: false,
	wrapperEls: "span"
};

function closestEnabledButton( element ) {
    var cname;

    while ( element ) {
		// Note that we check for typeof className below because the element we
		// handed could be in an SVG DOM where className on SVG elements is defined to
		// be of a different type (SVGAnimatedString). We only operate on HTML DOM
		// elements, so we look for plain "string".
        cname = ( typeof element.className === 'string' ) && (element.className + ' ');
        if ( cname && cname.indexOf("ui-btn ") > -1 && cname.indexOf("ui-disabled ") < 0 ) {
            break;
        }

        element = element.parentNode;
    }

    return element;
}

var attachEvents = function() {
	var hoverDelay = 200,
		hov, foc;
	$( document ).bind( {
		"vmousedown": function( event ) {
			var btn = closestEnabledButton( event.target ),
				$btn, theme;

			if ( btn ) {
				$btn = $( btn );
				theme = $btn.attr( "data-" + $.mobile.ns + "theme" );

				if( $.support.touch ) {
					hov = setTimeout(function() {
						$btn.removeClass( "ui-btn-up-" + theme ).addClass( "ui-btn-down-" + theme );
					}, hoverDelay );
				} else {
					$btn.removeClass( "ui-btn-up-" + theme ).addClass( "ui-btn-down-" + theme );
				}
			}
		},
		"vmousecancel vmouseup": function( event ) {
			var btn = closestEnabledButton( event.target ),
				$btn, theme;

			if ( btn ) {
				$btn = $( btn );
				theme = $btn.attr( "data-" + $.mobile.ns + "theme" );
				$btn.removeClass( "ui-btn-down-" + theme ).addClass( "ui-btn-up-" + theme );
			}
		},
		"vmouseover focus": function( event ) {
			var btn = closestEnabledButton( event.target ),
				$btn, theme;

			if ( btn ) {
				$btn = $( btn );
				theme = $btn.attr( "data-" + $.mobile.ns + "theme" );

				if( $.support.touch ) {
					foc = setTimeout(function() {
						$btn.removeClass( "ui-btn-up-" + theme ).addClass( "ui-btn-hover-" + theme );
					}, hoverDelay );
				} else {
					$btn.removeClass( "ui-btn-up-" + theme ).addClass( "ui-btn-hover-" + theme );
				}
			}
		},
		"vmouseout blur scrollstart": function( event ) {
			var btn = closestEnabledButton( event.target ),
				$btn, theme;

			if ( btn ) {
				$btn = $( btn );
				theme = $btn.attr( "data-" + $.mobile.ns + "theme" );
				$btn.removeClass( "ui-btn-hover-" + theme  + " ui-btn-down-" + theme ).addClass( "ui-btn-up-" + theme );

				hov && clearTimeout( hov );
				foc && clearTimeout( foc );
			}
		}
	});

	attachEvents = null;
};

//links in bars, or those with  data-role become buttons
//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){

	$( ":jqmData(role='button'), .ui-bar > a, .ui-header > a, .ui-footer > a, .ui-bar > :jqmData(role='controlgroup') > a", e.target )
		.not( ".ui-btn, :jqmData(role='none'), :jqmData(role='nojs')" )
		.buttonMarkup();
});

})( jQuery );


(function( $, undefined ) {

$.mobile.page.prototype.options.backBtnText  = "Back";
$.mobile.page.prototype.options.addBackBtn   = false;
$.mobile.page.prototype.options.backBtnTheme = null;
$.mobile.page.prototype.options.headerTheme  = "a";
$.mobile.page.prototype.options.footerTheme  = "a";
$.mobile.page.prototype.options.contentTheme = null;

$( document ).delegate( ":jqmData(role='page'), :jqmData(role='dialog')", "pagecreate", function( e ) {

	var $page = $( this ),
		o = $page.data( "page" ).options,
		pageRole = $page.jqmData( "role" ),
		pageTheme = o.theme;

	$( ":jqmData(role='header'), :jqmData(role='footer'), :jqmData(role='content')", this )
		.jqmEnhanceable()
		.each(function() {

		var $this = $( this ),
			role = $this.jqmData( "role" ),
			theme = $this.jqmData( "theme" ),
			contentTheme = theme || o.contentTheme || ( pageRole === "dialog" && pageTheme ),
			$headeranchors,
			leftbtn,
			rightbtn,
			backBtn;

		$this.addClass( "ui-" + role );

		//apply theming and markup modifications to page,header,content,footer
		if ( role === "header" || role === "footer" ) {

			var thisTheme = theme || ( role === "header" ? o.headerTheme : o.footerTheme ) || pageTheme;

			$this
				//add theme class
				.addClass( "ui-bar-" + thisTheme )
				// Add ARIA role
				.attr( "role", role === "header" ? "banner" : "contentinfo" );

			// Right,left buttons
			$headeranchors	= $this.children( "a" );
			leftbtn	= $headeranchors.hasClass( "ui-btn-left" );
			rightbtn = $headeranchors.hasClass( "ui-btn-right" );

			leftbtn = leftbtn || $headeranchors.eq( 0 ).not( ".ui-btn-right" ).addClass( "ui-btn-left" ).length;

			rightbtn = rightbtn || $headeranchors.eq( 1 ).addClass( "ui-btn-right" ).length;

			// Auto-add back btn on pages beyond first view
			if ( o.addBackBtn &&
				role === "header" &&
				$( ".ui-page" ).length > 1 &&
				$this.jqmData( "url" ) !== $.mobile.path.stripHash( location.hash ) &&
				!leftbtn ) {

				backBtn = $( "<a href='#' class='ui-btn-left' data-"+ $.mobile.ns +"rel='back' data-"+ $.mobile.ns +"icon='arrow-l'>"+ o.backBtnText +"</a>" )
					// If theme is provided, override default inheritance
					.attr( "data-"+ $.mobile.ns +"theme", o.backBtnTheme || thisTheme )
					.prependTo( $this );
			}

			// Page title
			$this.children( "h1, h2, h3, h4, h5, h6" )
				.addClass( "ui-title" )
				// Regardless of h element number in src, it becomes h1 for the enhanced page
				.attr({
					"tabindex": "0",
					"role": "heading",
					"aria-level": "1"
				});

		} else if ( role === "content" ) {
			if ( contentTheme ) {
			    $this.addClass( "ui-body-" + ( contentTheme ) );
			}

			// Add ARIA role
			$this.attr( "role", "main" );
		}
	});
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.collapsible", $.mobile.widget, {
	options: {
		expandCueText: " click to expand contents",
		collapseCueText: " click to collapse contents",
		collapsed: true,
		heading: "h1,h2,h3,h4,h5,h6,legend",
		theme: null,
		contentTheme: null,
		iconTheme: "d",
		mini: false,
		initSelector: ":jqmData(role='collapsible')"
	},
	_create: function() {

		var $el = this.element,
			o = this.options,
			collapsible = $el.addClass( "ui-collapsible" ),
			collapsibleHeading = $el.children( o.heading ).first(),
			collapsibleContent = collapsible.wrapInner( "<div class='ui-collapsible-content'></div>" ).find( ".ui-collapsible-content" ),
			collapsibleSet = $el.closest( ":jqmData(role='collapsible-set')" ).addClass( "ui-collapsible-set" );

		// Replace collapsibleHeading if it's a legend
		if ( collapsibleHeading.is( "legend" ) ) {
			collapsibleHeading = $( "<div role='heading'>"+ collapsibleHeading.html() +"</div>" ).insertBefore( collapsibleHeading );
			collapsibleHeading.next().remove();
		}

		// If we are in a collapsible set
		if ( collapsibleSet.length ) {
			// Inherit the theme from collapsible-set
			if ( !o.theme ) {
				o.theme = collapsibleSet.jqmData( "theme" );
			}
			// Inherit the content-theme from collapsible-set
			if ( !o.contentTheme ) {
				o.contentTheme = collapsibleSet.jqmData( "content-theme" );
			}
			
            // Gets the preference icon position in the set
            if ( !o.iconPos ) {
                o.iconPos = collapsibleSet.jqmData( "iconpos" );
            }
			
			if( !o.mini ) {
				o.mini = collapsibleSet.jqmData( "mini" );
			}
		}
		collapsibleContent.addClass( ( o.contentTheme ) ? ( "ui-body-" + o.contentTheme ) : "");

		collapsibleHeading
			//drop heading in before content
			.insertBefore( collapsibleContent )
			//modify markup & attributes
			.addClass( "ui-collapsible-heading" )
			.append( "<span class='ui-collapsible-heading-status'></span>" )
			.wrapInner( "<a href='#' class='ui-collapsible-heading-toggle'></a>" )
			.find( "a" )
				.first()
				.buttonMarkup({
					shadow: false,
					corners: false,
					iconpos: $el.jqmData( "iconpos" ) || o.iconPos || "left",
					icon: "plus",
					mini: o.mini,
					theme: o.theme
				})
			.add( ".ui-btn-inner" )
				.addClass( "ui-corner-top ui-corner-bottom" );

		//events
		collapsible
			.bind( "expand collapse", function( event ) {
				if ( !event.isDefaultPrevented() ) {

					event.preventDefault();

					var $this = $( this ),
						isCollapse = ( event.type === "collapse" ),
					    contentTheme = o.contentTheme;

					collapsibleHeading
						.toggleClass( "ui-collapsible-heading-collapsed", isCollapse)
						.find( ".ui-collapsible-heading-status" )
							.text( isCollapse ? o.expandCueText : o.collapseCueText )
						.end()
						.find( ".ui-icon" )
							.toggleClass( "ui-icon-minus", !isCollapse )
							.toggleClass( "ui-icon-plus", isCollapse );

					$this.toggleClass( "ui-collapsible-collapsed", isCollapse );
					collapsibleContent.toggleClass( "ui-collapsible-content-collapsed", isCollapse ).attr( "aria-hidden", isCollapse );

					if ( contentTheme && ( !collapsibleSet.length || collapsible.jqmData( "collapsible-last" ) ) ) {
						collapsibleHeading
							.find( "a" ).first().add( collapsibleHeading.find( ".ui-btn-inner" ) )
							.toggleClass( "ui-corner-bottom", isCollapse );
						collapsibleContent.toggleClass( "ui-corner-bottom", !isCollapse );
					}
					collapsibleContent.trigger( "updatelayout" );
				}
			})
			.trigger( o.collapsed ? "collapse" : "expand" );

		collapsibleHeading
			.bind( "click", function( event ) {

				var type = collapsibleHeading.is( ".ui-collapsible-heading-collapsed" ) ?
										"expand" : "collapse";

				collapsible.trigger( type );

				event.preventDefault();
			});
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.collapsible.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.collapsibleset", $.mobile.widget, {
	options: {
		initSelector: ":jqmData(role='collapsible-set')"
	},
	_create: function() {
		var $el = this.element.addClass( "ui-collapsible-set" ),
			o = this.options;

		// Inherit the theme from collapsible-set
		if ( !o.theme ) {
			o.theme = $el.jqmData( "theme" );
		}
		// Inherit the content-theme from collapsible-set
		if ( !o.contentTheme ) {
			o.contentTheme = $el.jqmData( "content-theme" );
		}

		// Initialize the collapsible set if it's not already initialized
		if ( !$el.jqmData( "collapsiblebound" ) ) {
			$el
				.jqmData( "collapsiblebound", true )
				.bind( "expand collapse", function( event ) {
					var isCollapse = ( event.type === "collapse" ),
						collapsible = $( event.target ).closest( ".ui-collapsible" ),
						widget = collapsible.data( "collapsible" ),
					    contentTheme = widget.options.contentTheme;
					if ( contentTheme && collapsible.jqmData( "collapsible-last" ) ) {
						collapsible.find( widget.options.heading ).first()
							.find( "a" ).first()
							.add( ".ui-btn-inner" )
							.toggleClass( "ui-corner-bottom", isCollapse );
						collapsible.find( ".ui-collapsible-content" ).toggleClass( "ui-corner-bottom", !isCollapse );
					}
				})
				.bind( "expand", function( event ) {
					$( event.target )
						.closest( ".ui-collapsible" )
						.siblings( ".ui-collapsible" )
						.trigger( "collapse" );
				});
		}
	},

	_init: function() {
		this.refresh();
	},

	refresh: function() {
		var $el = this.element,
			collapsiblesInSet = $el.children( ":jqmData(role='collapsible')" );

		$.mobile.collapsible.prototype.enhance( collapsiblesInSet.not( ".ui-collapsible" ) );

		// clean up borders
		collapsiblesInSet.each( function() {
			$( this ).find( $.mobile.collapsible.prototype.options.heading )
				.find( "a" ).first()
				.add( ".ui-btn-inner" )
				.removeClass( "ui-corner-top ui-corner-bottom" );
		});

		collapsiblesInSet.first()
			.find( "a" )
				.first()
				.addClass( "ui-corner-top" )
				.find( ".ui-btn-inner" )
					.addClass( "ui-corner-top" );

		collapsiblesInSet.last()
			.jqmData( "collapsible-last", true )
			.find( "a" )
				.first()
				.addClass( "ui-corner-bottom" )
				.find( ".ui-btn-inner" )
					.addClass( "ui-corner-bottom" );
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.collapsibleset.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.navbar", $.mobile.widget, {
	options: {
		iconpos: "top",
		grid: null,
		initSelector: ":jqmData(role='navbar')"
	},

	_create: function(){

		var $navbar = this.element,
			$navbtns = $navbar.find( "a" ),
			iconpos = $navbtns.filter( ":jqmData(icon)" ).length ?
									this.options.iconpos : undefined;

		$navbar.addClass( "ui-navbar" )
			.attr( "role","navigation" )
			.find( "ul" )
			.jqmEnhanceable()
			.grid({ grid: this.options.grid });

		if ( !iconpos ) {
			$navbar.addClass( "ui-navbar-noicons" );
		}

		$navbtns.buttonMarkup({
			corners:	false,
			shadow:		false,
			iconpos:	iconpos
		});

		$navbar.delegate( "a", "vclick", function( event ) {
			if( !$(event.target).hasClass("ui-disabled") ) {
				$navbtns.removeClass( $.mobile.activeBtnClass );
				$( this ).addClass( $.mobile.activeBtnClass );
			}
		});

		// Buttons in the navbar with ui-state-persist class should regain their active state before page show
		$navbar.closest( ".ui-page" ).bind( "pagebeforeshow", function() {
			$navbtns.filter( ".ui-state-persist" ).addClass( $.mobile.activeBtnClass );
		});
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.navbar.prototype.enhanceWithin( e.target );
});

})( jQuery );

(function( $, undefined ) {

//Keeps track of the number of lists per page UID
//This allows support for multiple nested list in the same page
//https://github.com/jquery/jquery-mobile/issues/1617
var listCountPerPage = {};

$.widget( "mobile.listview", $.mobile.widget, {
	options: {
		theme: null,
		countTheme: "c",
		headerTheme: "b",
		dividerTheme: "b",
		splitIcon: "arrow-r",
		splitTheme: "b",
		inset: false,
		initSelector: ":jqmData(role='listview')"
	},

	_create: function() {
		var t = this;

		// create listview markup
		t.element.addClass(function( i, orig ) {
			return orig + " ui-listview " + ( t.options.inset ? " ui-listview-inset ui-corner-all ui-shadow " : "" );
		});

		t.refresh( true );
	},

	_removeCorners: function( li, which ) {
		var top = "ui-corner-top ui-corner-tr ui-corner-tl",
			bot = "ui-corner-bottom ui-corner-br ui-corner-bl";

		li = li.add( li.find( ".ui-btn-inner, .ui-li-link-alt, .ui-li-thumb" ) );

		if ( which === "top" ) {
			li.removeClass( top );
		} else if ( which === "bottom" ) {
			li.removeClass( bot );
		} else {
			li.removeClass( top + " " + bot );
		}
	},

	_refreshCorners: function( create ) {
		var $li,
			$visibleli,
			$topli,
			$bottomli;

		if ( this.options.inset ) {
			$li = this.element.children( "li" );
			// at create time the li are not visible yet so we need to rely on .ui-screen-hidden
			$visibleli = create?$li.not( ".ui-screen-hidden" ):$li.filter( ":visible" );

			this._removeCorners( $li );

			// Select the first visible li element
			$topli = $visibleli.first()
				.addClass( "ui-corner-top" );

			$topli.add( $topli.find( ".ui-btn-inner" )
					.not( ".ui-li-link-alt span:first-child" ) )
                                .addClass( "ui-corner-top" )
                                .end()
				.find( ".ui-li-link-alt, .ui-li-link-alt span:first-child" )
					.addClass( "ui-corner-tr" )
				.end()
				.find( ".ui-li-thumb" )
					.not(".ui-li-icon")
					.addClass( "ui-corner-tl" );

			// Select the last visible li element
			$bottomli = $visibleli.last()
				.addClass( "ui-corner-bottom" );

			$bottomli.add( $bottomli.find( ".ui-btn-inner" ) )
				.find( ".ui-li-link-alt" )
					.addClass( "ui-corner-br" )
				.end()
				.find( ".ui-li-thumb" )
					.not(".ui-li-icon")
					.addClass( "ui-corner-bl" );
		}
		if ( !create ) {
			this.element.trigger( "updatelayout" );
		}
	},

	// This is a generic utility method for finding the first
	// node with a given nodeName. It uses basic DOM traversal
	// to be fast and is meant to be a substitute for simple
	// $.fn.closest() and $.fn.children() calls on a single
	// element. Note that callers must pass both the lowerCase
	// and upperCase version of the nodeName they are looking for.
	// The main reason for this is that this function will be
	// called many times and we want to avoid having to lowercase
	// the nodeName from the element every time to ensure we have
	// a match. Note that this function lives here for now, but may
	// be moved into $.mobile if other components need a similar method.
	_findFirstElementByTagName: function( ele, nextProp, lcName, ucName )
	{
		var dict = {};
		dict[ lcName ] = dict[ ucName ] = true;
		while ( ele ) {
			if ( dict[ ele.nodeName ] ) {
				return ele;
			}
			ele = ele[ nextProp ];
		}
		return null;
	},
	_getChildrenByTagName: function( ele, lcName, ucName )
	{
		var results = [],
			dict = {};
		dict[ lcName ] = dict[ ucName ] = true;
		ele = ele.firstChild;
		while ( ele ) {
			if ( dict[ ele.nodeName ] ) {
				results.push( ele );
			}
			ele = ele.nextSibling;
		}
		return $( results );
	},

	_addThumbClasses: function( containers )
	{
		var i, img, len = containers.length;
		for ( i = 0; i < len; i++ ) {
			img = $( this._findFirstElementByTagName( containers[ i ].firstChild, "nextSibling", "img", "IMG" ) );
			if ( img.length ) {
				img.addClass( "ui-li-thumb" );
				$( this._findFirstElementByTagName( img[ 0 ].parentNode, "parentNode", "li", "LI" ) ).addClass( img.is( ".ui-li-icon" ) ? "ui-li-has-icon" : "ui-li-has-thumb" );
			}
		}
	},

	refresh: function( create ) {
		this.parentPage = this.element.closest( ".ui-page" );
		this._createSubPages();

		var o = this.options,
			$list = this.element,
			self = this,
			dividertheme = $list.jqmData( "dividertheme" ) || o.dividerTheme,
			listsplittheme = $list.jqmData( "splittheme" ),
			listspliticon = $list.jqmData( "spliticon" ),
			li = this._getChildrenByTagName( $list[ 0 ], "li", "LI" ),
			counter = $.support.cssPseudoElement || !$.nodeName( $list[ 0 ], "ol" ) ? 0 : 1,
			itemClassDict = {},
			item, itemClass, itemTheme,
			a, last, splittheme, countParent, icon, imgParents, img;

		if ( counter ) {
			$list.find( ".ui-li-dec" ).remove();
		}
		
		if ( !o.theme ) {
			o.theme = $.mobile.getInheritedTheme( this.element, "c" );
		}

		for ( var pos = 0, numli = li.length; pos < numli; pos++ ) {
			item = li.eq( pos );
			itemClass = "ui-li";

			// If we're creating the element, we update it regardless
			if ( create || !item.hasClass( "ui-li" ) ) {
				itemTheme = item.jqmData("theme") || o.theme;
				a = this._getChildrenByTagName( item[ 0 ], "a", "A" );

				if ( a.length ) {
					icon = item.jqmData("icon");

					item.buttonMarkup({
						wrapperEls: "div",
						shadow: false,
						corners: false,
						iconpos: "right",
						icon: a.length > 1 || icon === false ? false : icon || "arrow-r",
						theme: itemTheme
					});

					if ( ( icon != false ) && ( a.length == 1 ) ) {
						item.addClass( "ui-li-has-arrow" );
					}

					a.first().removeClass( "ui-link" ).addClass( "ui-link-inherit" );

					if ( a.length > 1 ) {
						itemClass += " ui-li-has-alt";

						last = a.last();
						splittheme = listsplittheme || last.jqmData( "theme" ) || o.splitTheme;

						last.appendTo(item)
							.attr( "title", last.getEncodedText() )
							.addClass( "ui-li-link-alt" )
							.empty()
							.buttonMarkup({
								shadow: false,
								corners: false,
								theme: itemTheme,
								icon: false,
								iconpos: false
							})
							.find( ".ui-btn-inner" )
								.append(
									$( document.createElement( "span" ) ).buttonMarkup({
										shadow: true,
										corners: true,
										theme: splittheme,
										iconpos: "notext",
										icon: listspliticon || last.jqmData( "icon" ) || o.splitIcon
									})
								);
					}
				} else if ( item.jqmData( "role" ) === "list-divider" ) {

					itemClass += " ui-li-divider ui-btn ui-bar-" + dividertheme;
					item.attr( "role", "heading" );

					//reset counter when a divider heading is encountered
					if ( counter ) {
						counter = 1;
					}

				} else {
					itemClass += " ui-li-static ui-body-" + itemTheme;
				}
			}

			if ( counter && itemClass.indexOf( "ui-li-divider" ) < 0 ) {
				countParent = item.is( ".ui-li-static:first" ) ? item : item.find( ".ui-link-inherit" );

				countParent.addClass( "ui-li-jsnumbering" )
					.prepend( "<span class='ui-li-dec'>" + (counter++) + ". </span>" );
			}

			// Instead of setting item class directly on the list item and its
			// btn-inner at this point in time, push the item into a dictionary
			// that tells us what class to set on it so we can do this after this
			// processing loop is finished.

			if ( !itemClassDict[ itemClass ] ) {
				itemClassDict[ itemClass ] = [];
			}

			itemClassDict[ itemClass ].push( item[ 0 ] );
		}

		// Set the appropriate listview item classes on each list item
		// and their btn-inner elements. The main reason we didn't do this
		// in the for-loop above is because we can eliminate per-item function overhead
		// by calling addClass() and children() once or twice afterwards. This
		// can give us a significant boost on platforms like WP7.5.

		for ( itemClass in itemClassDict ) {
			$( itemClassDict[ itemClass ] ).addClass( itemClass ).children( ".ui-btn-inner" ).addClass( itemClass );
		}

		$list.find( "h1, h2, h3, h4, h5, h6" ).addClass( "ui-li-heading" )
			.end()

			.find( "p, dl" ).addClass( "ui-li-desc" )
			.end()

			.find( ".ui-li-aside" ).each(function() {
					var $this = $(this);
					$this.prependTo( $this.parent() ); //shift aside to front for css float
				})
			.end()

			.find( ".ui-li-count" ).each( function() {
					$( this ).closest( "li" ).addClass( "ui-li-has-count" );
				}).addClass( "ui-btn-up-" + ( $list.jqmData( "counttheme" ) || this.options.countTheme) + " ui-btn-corner-all" );

		// The idea here is to look at the first image in the list item
		// itself, and any .ui-link-inherit element it may contain, so we
		// can place the appropriate classes on the image and list item.
		// Note that we used to use something like:
		//
		//    li.find(">img:eq(0), .ui-link-inherit>img:eq(0)").each( ... );
		//
		// But executing a find() like that on Windows Phone 7.5 took a
		// really long time. Walking things manually with the code below
		// allows the 400 listview item page to load in about 3 seconds as
		// opposed to 30 seconds.

		this._addThumbClasses( li );
		this._addThumbClasses( $list.find( ".ui-link-inherit" ) );

		this._refreshCorners( create );
	},

	//create a string for ID/subpage url creation
	_idStringEscape: function( str ) {
		return str.replace(/[^a-zA-Z0-9]/g, '-');
	},

	_createSubPages: function() {
		var parentList = this.element,
			parentPage = parentList.closest( ".ui-page" ),
			parentUrl = parentPage.jqmData( "url" ),
			parentId = parentUrl || parentPage[ 0 ][ $.expando ],
			parentListId = parentList.attr( "id" ),
			o = this.options,
			dns = "data-" + $.mobile.ns,
			self = this,
			persistentFooterID = parentPage.find( ":jqmData(role='footer')" ).jqmData( "id" ),
			hasSubPages;

		if ( typeof listCountPerPage[ parentId ] === "undefined" ) {
			listCountPerPage[ parentId ] = -1;
		}

		parentListId = parentListId || ++listCountPerPage[ parentId ];

		$( parentList.find( "li>ul, li>ol" ).toArray().reverse() ).each(function( i ) {
			var self = this,
				list = $( this ),
				listId = list.attr( "id" ) || parentListId + "-" + i,
				parent = list.parent(),
				nodeEls = $( list.prevAll().toArray().reverse() ),
				nodeEls = nodeEls.length ? nodeEls : $( "<span>" + $.trim(parent.contents()[ 0 ].nodeValue) + "</span>" ),
				title = nodeEls.first().getEncodedText(),//url limits to first 30 chars of text
				id = ( parentUrl || "" ) + "&" + $.mobile.subPageUrlKey + "=" + listId,
				theme = list.jqmData( "theme" ) || o.theme,
				countTheme = list.jqmData( "counttheme" ) || parentList.jqmData( "counttheme" ) || o.countTheme,
				newPage, anchor;

			//define hasSubPages for use in later removal
			hasSubPages = true;

			newPage = list.detach()
						.wrap( "<div " + dns + "role='page' " +	dns + "url='" + id + "' " + dns + "theme='" + theme + "' " + dns + "count-theme='" + countTheme + "'><div " + dns + "role='content'></div></div>" )
						.parent()
							.before( "<div " + dns + "role='header' " + dns + "theme='" + o.headerTheme + "'><div class='ui-title'>" + title + "</div></div>" )
							.after( persistentFooterID ? $( "<div " + dns + "role='footer' " + dns + "id='"+ persistentFooterID +"'>") : "" )
							.parent()
								.appendTo( $.mobile.pageContainer );

			newPage.page();

			anchor = parent.find('a:first');

			if ( !anchor.length ) {
				anchor = $( "<a/>" ).html( nodeEls || title ).prependTo( parent.empty() );
			}

			anchor.attr( "href", "#" + id );

		}).listview();

		// on pagehide, remove any nested pages along with the parent page, as long as they aren't active
		// and aren't embedded
		if( hasSubPages &&
			parentPage.is( ":jqmData(external-page='true')" ) &&
			parentPage.data("page").options.domCache === false ) {

			var newRemove = function( e, ui ){
				var nextPage = ui.nextPage, npURL;

				if( ui.nextPage ){
					npURL = nextPage.jqmData( "url" );
					if( npURL.indexOf( parentUrl + "&" + $.mobile.subPageUrlKey ) !== 0 ){
						self.childPages().remove();
						parentPage.remove();
					}
				}
			};

			// unbind the original page remove and replace with our specialized version
			parentPage
				.unbind( "pagehide.remove" )
				.bind( "pagehide.remove", newRemove);
		}
	},

	// TODO sort out a better way to track sub pages of the listview this is brittle
	childPages: function(){
		var parentUrl = this.parentPage.jqmData( "url" );

		return $( ":jqmData(url^='"+  parentUrl + "&" + $.mobile.subPageUrlKey +"')");
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.listview.prototype.enhanceWithin( e.target );
});

})( jQuery );

/*
* "checkboxradio" plugin
*/

(function( $, undefined ) {

$.widget( "mobile.checkboxradio", $.mobile.widget, {
	options: {
		theme: null,
		initSelector: "input[type='checkbox'],input[type='radio']"
	},
	_create: function() {
		var self = this,
			input = this.element,
			// NOTE: Windows Phone could not find the label through a selector
			// filter works though.
			label = $( input ).closest( "form,fieldset,:jqmData(role='page'),:jqmData(role='dialog')" ).find( "label" ).filter( "[for='" + input[ 0 ].id + "']" ),
			inputtype = input.attr( "type" ),
			mini = input.closest( "form,fieldset" ).jqmData('mini'),
			checkedState = inputtype + "-on",
			uncheckedState = inputtype + "-off",
			icon = input.parents( ":jqmData(type='horizontal')" ).length ? undefined : uncheckedState,
			activeBtn = icon ? "" : " " + $.mobile.activeBtnClass,
			checkedClass = "ui-" + checkedState + activeBtn,
			uncheckedClass = "ui-" + uncheckedState,
			checkedicon = "ui-icon-" + checkedState,
			uncheckedicon = "ui-icon-" + uncheckedState;

		if ( inputtype !== "checkbox" && inputtype !== "radio" ) {
			return;
		}

		// Expose for other methods
		$.extend( this, {
			label: label,
			inputtype: inputtype,
			checkedClass: checkedClass,
			uncheckedClass: uncheckedClass,
			checkedicon: checkedicon,
			uncheckedicon: uncheckedicon
		});

		// If there's no selected theme...
		if( !this.options.theme ) {
			this.options.theme = this.element.jqmData( "theme" );
		}

		label.buttonMarkup({
			theme: this.options.theme,
			icon: icon,
			shadow: false,
			mini: mini
		});

		// Wrap the input + label in a div
		var wrapper = document.createElement('div');		
		wrapper.className = 'ui-' + inputtype;	
		input[0].parentNode.insertBefore(wrapper,input[0]);
		wrapper.appendChild(input[0]);				
		wrapper.appendChild(label[0]);

		label.bind({
			vmouseover: function( event ) {
				if ( $( this ).parent().is( ".ui-disabled" ) ) {
					event.stopPropagation();
				}
			},

			vclick: function( event ) {
				if ( input.is( ":disabled" ) ) {
					event.preventDefault();
					return;
				}

				self._cacheVals();
				input.attr( "checked", inputtype === "radio" && true || !input.attr( "checked" ) );
				//input.prop( "checked", inputtype === "radio" && true || !input.attr( "checked" ) );

				// trigger click handler's bound directly to the input as a substitute for
				// how label clicks behave normally in the browsers
				// TODO: it would be nice to let the browser's handle the clicks and pass them
				//       through to the associate input. we can swallow that click at the parent
				//       wrapper element level
				input.triggerHandler( 'click' );

				// Input set for common radio buttons will contain all the radio
				// buttons, but will not for checkboxes. clearing the checked status
				// of other radios ensures the active button state is applied properly
				self._getInputSet().not( input ).removeAttr( "checked" );

				self._updateAll();
				return false;
			}

		});

		input
			.bind({
				vmousedown: function() {
					self._cacheVals();
				},

				vclick: function() {
					var $this = $(this);

					// Adds checked attribute to checked input when keyboard is used
					if ( $this.is( ":checked" ) ) {

						$this.attr( "checked", "checked" );
						self._getInputSet().not($this).removeAttr( "checked" );
					} else {

						$this.removeAttr( "checked" );
					}

					self._updateAll();
				},

				focus: function() {
					label.addClass( $.mobile.focusClass );
				},

				blur: function() {
					label.removeClass( $.mobile.focusClass );
				}
			});

		this.refresh();
	},

	_cacheVals: function() {
		this._getInputSet().each(function() {
			var $this = $(this);

			$this.jqmData( "cacheVal", $this.is( ":checked" ) );
		});
	},

	//returns either a set of radios with the same name attribute, or a single checkbox
	_getInputSet: function(){
		if(this.inputtype == "checkbox") {
			return this.element;
		}

		return this.element.closest( "form,fieldset,:jqmData(role='page')" )
			.find( "input[name='"+ this.element.attr( "name" ) +"'][type='"+ this.inputtype +"']" );
	},

	_updateAll: function() {
		var self = this;

		this._getInputSet().each(function() {
			var $this = $(this);

			// NOTE getAttribute is used here to deal with an issue with the :checked
			//      selector. see #3597
			if ( this.getAttribute( "checked" ) || self.inputtype === "checkbox" ) {
				$this.trigger( "change" );
			}
		})
		.checkboxradio( "refresh" );
	},

	refresh: function() {
		var input = this.element,
			label = this.label,
			icon = label.find( ".ui-icon" );

		// input[0].checked expando doesn't always report the proper value
		// for checked='checked'

		if ( input[ 0 ].getAttribute( "checked" ) ) {
			label.addClass( this.checkedClass ).removeClass( this.uncheckedClass );
			icon.addClass( this.checkedicon ).removeClass( this.uncheckedicon );
		} else {
			label.removeClass( this.checkedClass ).addClass( this.uncheckedClass );
			icon.removeClass( this.checkedicon ).addClass( this.uncheckedicon );
		}

		if ( input.is( ":disabled" ) ) {
			this.disable();
		} else {
			this.enable();
		}
	},

	disable: function() {
		this.element.attr( "disabled", true ).parent().addClass( "ui-disabled" );
	},

	enable: function() {
		this.element.prop( "disabled", false ).parent().removeClass( "ui-disabled" );
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.checkboxradio.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.button", $.mobile.widget, {
	options: {
		theme: null,
		icon: null,
		iconpos: null,
		inline: null,
		corners: true,
		shadow: true,
		iconshadow: true,
		initSelector: "button, [type='button'], [type='submit'], [type='reset'], [type='image']",
		mini: false
	},
	_create: function() {
		var $el = this.element,
			$button,
			o = this.options,
			type,
			name,
			classes = "",
			$buttonPlaceholder;

		// if this is a link, check if it's been enhanced and, if not, use the right function
		if( $el[ 0 ].tagName === "A" ) {
	 	 	!$el.hasClass( "ui-btn" ) && $el.buttonMarkup();
	 	 	return;
 	 	}
		
		
		// TODO: Post 1.1--once we have time to test thoroughly--any classes manually applied to the original element should be carried over to the enhanced element, with an `-enhanced` suffix. See https://github.com/jquery/jquery-mobile/issues/3577
		/* if( $el[0].className.length ) {
			classes = $el[0].className;
		} */
		if( !!~$el[0].className.indexOf( "ui-btn-left" ) ) {
			classes = "ui-btn-left";
		}
		
		if(  !!~$el[0].className.indexOf( "ui-btn-right" ) ) {
			classes = "ui-btn-right";
		}

		// Add ARIA role
		this.button = $( "<div></div>" )
			.text( $el.text() || $el.val() )
			.insertBefore( $el )
			.buttonMarkup({
				theme: o.theme,
				icon: o.icon,
				iconpos: o.iconpos,
				inline: o.inline,
				corners: o.corners,
				shadow: o.shadow,
				iconshadow: o.iconshadow,
				mini: o.mini
			})
			.addClass( classes )
			.append( $el.addClass( "ui-btn-hidden" ) );

        $button = this.button;
		type = $el.attr( "type" );
		name = $el.attr( "name" );

		// Add hidden input during submit if input type="submit" has a name.
		if ( type !== "button" && type !== "reset" && name ) {
				$el.bind( "vclick", function() {
					// Add hidden input if it doesn’t already exist.
					if( $buttonPlaceholder === undefined ) {
						$buttonPlaceholder = $( "<input>", {
							type: "hidden",
							name: $el.attr( "name" ),
							value: $el.attr( "value" )
						}).insertBefore( $el );

						// Bind to doc to remove after submit handling
						$( document ).one("submit", function(){
							$buttonPlaceholder.remove();

							// reset the local var so that the hidden input
							// will be re-added on subsequent clicks
							$buttonPlaceholder = undefined;
						});
					}
				});
		}

        $el.bind({
            focus: function() {
                $button.addClass( $.mobile.focusClass );
            },

            blur: function() {
                $button.removeClass( $.mobile.focusClass );
            }
        });

		this.refresh();
	},

	enable: function() {
		this.element.attr( "disabled", false );
		this.button.removeClass( "ui-disabled" ).attr( "aria-disabled", false );
		return this._setOption( "disabled", false );
	},

	disable: function() {
		this.element.attr( "disabled", true );
		this.button.addClass( "ui-disabled" ).attr( "aria-disabled", true );
		return this._setOption( "disabled", true );
	},

	refresh: function() {
		var $el = this.element;

		if ( $el.prop("disabled") ) {
			this.disable();
		} else {
			this.enable();
		}

                // Grab the button's text element from its implementation-independent data item
		$(this.button.data( 'buttonElements' ).text).text( $el.text() || $el.val() );
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.button.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.fn.controlgroup = function( options ) {
	function flipClasses( els, flCorners  ) {
		els.removeClass( "ui-btn-corner-all ui-shadow" )
			.eq( 0 ).addClass( flCorners[ 0 ] )
			.end()
			.last().addClass( flCorners[ 1 ] ).addClass( "ui-controlgroup-last" );
	}

	return this.each(function() {
		var $el = $( this ),
			o = $.extend({
						direction: $el.jqmData( "type" ) || "vertical",
						shadow: false,
						excludeInvisible: true,
						mini: $el.jqmData( "mini" )
					}, options ),
			groupheading = $el.children( "legend" ),
			flCorners = o.direction == "horizontal" ? [ "ui-corner-left", "ui-corner-right" ] : [ "ui-corner-top", "ui-corner-bottom" ],
			type = $el.find( "input" ).first().attr( "type" );

		// Replace legend with more stylable replacement div
		if ( groupheading.length ) {
			$el.wrapInner( "<div class='ui-controlgroup-controls'></div>" );
			$( "<div role='heading' class='ui-controlgroup-label'>" + groupheading.html() + "</div>" ).insertBefore( $el.children(0) );
			groupheading.remove();
		}

		$el.addClass( "ui-corner-all ui-controlgroup ui-controlgroup-" + o.direction );

		flipClasses( $el.find( ".ui-btn" + ( o.excludeInvisible ? ":visible" : "" ) ).not('.ui-slider-handle'), flCorners );
		flipClasses( $el.find( ".ui-btn-inner" ), flCorners );

		if ( o.shadow ) {
			$el.addClass( "ui-shadow" );
		}

		if ( o.mini ) {
			$el.addClass( "ui-mini" );
		}

	});
};

// The pagecreate handler for controlgroup is in jquery.mobile.init because of the soft-dependency on the wrapped widgets

})(jQuery);

(function( $, undefined ) {

$( document ).bind( "pagecreate create", function( e ){

	//links within content areas, tests included with page
	$( e.target )
		.find( "a" )
		.jqmEnhanceable()
		.not( ".ui-btn, .ui-link-inherit, :jqmData(role='none'), :jqmData(role='nojs')" )
		.addClass( "ui-link" );

});

})( jQuery );


( function( $ ) {
	var	meta = $( "meta[name=viewport]" ),
        initialContent = meta.attr( "content" ),
        disabledZoom = initialContent + ",maximum-scale=1, user-scalable=no",
        enabledZoom = initialContent + ",maximum-scale=10, user-scalable=yes";
	
	$.mobile.zoom = $.extend( {}, {
		enabled: true,
		locked: false,
		disable: function( lock ) {
			if( !$.mobile.zoom.locked ){
	        	meta.attr( "content", disabledZoom );
	        	$.mobile.zoom.enabled = false;
				$.mobile.zoom.locked = lock || false;
			}
		},
		enable: function( unlock ) {
			if( !$.mobile.zoom.locked || unlock ){
		        meta.attr( "content", enabledZoom );
		        $.mobile.zoom.enabled = true;
				$.mobile.zoom.locked = false;
			}
		},
		restore: function() {
	        meta.attr( "content", initialContent );
	        $.mobile.zoom.enabled = true;
		}
	});

}( jQuery ));

(function( $, undefined ) {

$.widget( "mobile.textinput", $.mobile.widget, {
	options: {
		theme: null,
		// This option defaults to true on iOS devices.
		preventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( "AppleWebKit" ) > -1,
		initSelector: "input[type='text'], input[type='search'], :jqmData(type='search'), input[type='number'], :jqmData(type='number'), input[type='password'], input[type='email'], input[type='url'], input[type='tel'], textarea, input[type='time'], input[type='date'], input[type='month'], input[type='week'], input[type='datetime'], input[type='datetime-local'], input[type='color'], input:not([type])"
	},

	_create: function() {

		var input = this.element,
			o = this.options,
			theme = o.theme || $.mobile.getInheritedTheme( this.element, "c" ),
			themeclass  = " ui-body-" + theme,
			mini = input.jqmData("mini") == true,
			miniclass = mini ? " ui-mini" : "",
			focusedEl, clearbtn;

		$( "label[for='" + input.attr( "id" ) + "']" ).addClass( "ui-input-text" );

		focusedEl = input.addClass("ui-input-text ui-body-"+ theme );

		// XXX: Temporary workaround for issue 785 (Apple bug 8910589).
		//      Turn off autocorrect and autocomplete on non-iOS 5 devices
		//      since the popup they use can't be dismissed by the user. Note
		//      that we test for the presence of the feature by looking for
		//      the autocorrect property on the input element. We currently
		//      have no test for iOS 5 or newer so we're temporarily using
		//      the touchOverflow support flag for jQM 1.0. Yes, I feel dirty. - jblas
		if ( typeof input[0].autocorrect !== "undefined" && !$.support.touchOverflow ) {
			// Set the attribute instead of the property just in case there
			// is code that attempts to make modifications via HTML.
			input[0].setAttribute( "autocorrect", "off" );
			input[0].setAttribute( "autocomplete", "off" );
		}


		//"search" input widget
		if ( input.is( "[type='search'],:jqmData(type='search')" ) ) {

			focusedEl = input.wrap( "<div class='ui-input-search ui-shadow-inset ui-btn-corner-all ui-btn-shadow ui-icon-searchfield" + themeclass + miniclass + "'></div>" ).parent();
			clearbtn = $( "<a href='#' class='ui-input-clear' title='clear text'>clear text</a>" )
				.tap(function( event ) {
					input.val( "" ).focus();
					input.trigger( "change" );
					clearbtn.addClass( "ui-input-clear-hidden" );
					event.preventDefault();
				})
				.appendTo( focusedEl )
				.buttonMarkup({
					icon: "delete",
					iconpos: "notext",
					corners: true,
					shadow: true,
					mini: mini
				});

			function toggleClear() {
				setTimeout(function() {
					clearbtn.toggleClass( "ui-input-clear-hidden", !input.val() );
				}, 0);
			}

			toggleClear();

			input.bind('paste cut keyup focus change blur', toggleClear);

		} else {
			input.addClass( "ui-corner-all ui-shadow-inset" + themeclass + miniclass );
		}

		input.focus(function() {
				focusedEl.addClass( $.mobile.focusClass );
			})
			.blur(function(){
				focusedEl.removeClass( $.mobile.focusClass );
			})
			// In many situations, iOS will zoom into the select upon tap, this prevents that from happening
			.bind( "focus", function() {
				if( o.preventFocusZoom ){
					$.mobile.zoom.disable( true );
				}
			})
			.bind( "blur", function() {
				if( o.preventFocusZoom ){
					$.mobile.zoom.enable( true );
				}
			});

		// Autogrow
		if ( input.is( "textarea" ) ) {
			var extraLineHeight = 15,
				keyupTimeoutBuffer = 100,
				keyup = function() {
					var scrollHeight = input[ 0 ].scrollHeight,
						clientHeight = input[ 0 ].clientHeight;

					if ( clientHeight < scrollHeight ) {
						input.height(scrollHeight + extraLineHeight);
					}
				},
				keyupTimeout;

			input.keyup(function() {
				clearTimeout( keyupTimeout );
				keyupTimeout = setTimeout( keyup, keyupTimeoutBuffer );
			});

			// binding to pagechange here ensures that for pages loaded via
			// ajax the height is recalculated without user input
			$( document ).one( "pagechange", keyup );

			// Issue 509: the browser is not providing scrollHeight properly until the styles load
			if ( $.trim( input.val() ) ) {
				// bind to the window load to make sure the height is calculated based on BOTH
				// the DOM and CSS
				$( window ).load( keyup );
			}
		}
	},

	disable: function(){
		( this.element.attr( "disabled", true ).is( "[type='search'],:jqmData(type='search')" ) ?
			this.element.parent() : this.element ).addClass( "ui-disabled" );
	},

	enable: function(){
		( this.element.attr( "disabled", false).is( "[type='search'],:jqmData(type='search')" ) ?
			this.element.parent() : this.element ).removeClass( "ui-disabled" );
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.textinput.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.mobile.listview.prototype.options.filter = false;
$.mobile.listview.prototype.options.filterPlaceholder = "Filter items...";
$.mobile.listview.prototype.options.filterTheme = "c";
$.mobile.listview.prototype.options.filterCallback = function( text, searchValue ){
	return text.toLowerCase().indexOf( searchValue ) === -1;
};

$( document ).delegate( ":jqmData(role='listview')", "listviewcreate", function() {

	var list = $( this ),
		listview = list.data( "listview" );

	if ( !listview.options.filter ) {
		return;
	}

	var wrapper = $( "<form>", {
			"class": "ui-listview-filter ui-bar-" + listview.options.filterTheme,
			"role": "search"
		}),
		search = $( "<input>", {
			placeholder: listview.options.filterPlaceholder
		})
		.attr( "data-" + $.mobile.ns + "type", "search" )
		.jqmData( "lastval", "" )
		.bind( "keyup change", function() {

			var $this = $(this),
				val = this.value.toLowerCase(),
				listItems = null,
				lastval = $this.jqmData( "lastval" ) + "",
				childItems = false,
				itemtext = "",
				item;

			// Change val as lastval for next execution
			$this.jqmData( "lastval" , val );
			if ( val.length < lastval.length || val.indexOf(lastval) !== 0 ) {

				// Removed chars or pasted something totally different, check all items
				listItems = list.children();
			} else {

				// Only chars added, not removed, only use visible subset
				listItems = list.children( ":not(.ui-screen-hidden)" );
			}

			if ( val ) {

				// This handles hiding regular rows without the text we search for
				// and any list dividers without regular rows shown under it

				for ( var i = listItems.length - 1; i >= 0; i-- ) {
					item = $( listItems[ i ] );
					itemtext = item.jqmData( "filtertext" ) || item.text();

					if ( item.is( "li:jqmData(role=list-divider)" ) ) {

						item.toggleClass( "ui-filter-hidequeue" , !childItems );

						// New bucket!
						childItems = false;

					} else if ( listview.options.filterCallback( itemtext, val ) ) {

						//mark to be hidden
						item.toggleClass( "ui-filter-hidequeue" , true );
					} else {

						// There's a shown item in the bucket
						childItems = true;
					}
				}

				// Show items, not marked to be hidden
				listItems
					.filter( ":not(.ui-filter-hidequeue)" )
					.toggleClass( "ui-screen-hidden", false );

				// Hide items, marked to be hidden
				listItems
					.filter( ".ui-filter-hidequeue" )
					.toggleClass( "ui-screen-hidden", true )
					.toggleClass( "ui-filter-hidequeue", false );

			} else {

				//filtervalue is empty => show all
				listItems.toggleClass( "ui-screen-hidden", false );
			}
			listview._refreshCorners();
		})
		.appendTo( wrapper )
		.textinput();

	if ( $( this ).jqmData( "inset" ) ) {
		wrapper.addClass( "ui-listview-filter-inset" );
	}

	wrapper.bind( "submit", function() {
		return false;
	})
	.insertBefore( list );
});

})( jQuery );

( function( $, undefined ) {

$.widget( "mobile.slider", $.mobile.widget, {
	options: {
		theme: null,
		trackTheme: null,
		disabled: false,
		initSelector: "input[type='range'], :jqmData(type='range'), :jqmData(role='slider')",
		mini: false
	},

	_create: function() {

		// TODO: Each of these should have comments explain what they're for
		var self = this,

			control = this.element,

			parentTheme = $.mobile.getInheritedTheme( control, "c" ),

			theme = this.options.theme || parentTheme,

			trackTheme = this.options.trackTheme || parentTheme,

			cType = control[ 0 ].nodeName.toLowerCase(),

			selectClass = ( cType == "select" ) ? "ui-slider-switch" : "",

			controlID = control.attr( "id" ),

			labelID = controlID + "-label",

			label = $( "[for='"+ controlID +"']" ).attr( "id", labelID ),

			val = function() {
				return  cType == "input"  ? parseFloat( control.val() ) : control[0].selectedIndex;
			},

			min =  cType == "input" ? parseFloat( control.attr( "min" ) ) : 0,

			max =  cType == "input" ? parseFloat( control.attr( "max" ) ) : control.find( "option" ).length-1,

			step = window.parseFloat( control.attr( "step" ) || 1 ),

			inlineClass = ( this.options.inline || control.jqmData("inline") == true ) ? " ui-slider-inline" : "",

			miniClass = ( this.options.mini || control.jqmData("mini") ) ? " ui-slider-mini" : "",


			domHandle = document.createElement('a'),
			handle = $( domHandle ),
			domSlider = document.createElement('div'),
			slider = $( domSlider ),

			valuebg = control.jqmData("highlight") && cType != "select" ? (function() {
				var bg = document.createElement('div');
				bg.className = 'ui-slider-bg ui-btn-active ui-btn-corner-all';
				return $( bg ).prependTo( slider );
			})() : false,

			options;

        domHandle.setAttribute( 'href', "#" );
		domSlider.setAttribute('role','application');
		domSlider.className = ['ui-slider ',selectClass," ui-btn-down-",trackTheme,' ui-btn-corner-all', inlineClass, miniClass].join("");
		domHandle.className = 'ui-slider-handle';
		domSlider.appendChild(domHandle);

		handle.buttonMarkup({ corners: true, theme: theme, shadow: true })
				.attr({
					"role": "slider",
					"aria-valuemin": min,
					"aria-valuemax": max,
					"aria-valuenow": val(),
					"aria-valuetext": val(),
					"title": val(),
					"aria-labelledby": labelID
				});

		$.extend( this, {
			slider: slider,
			handle: handle,
			valuebg: valuebg,
			dragging: false,
			beforeStart: null,
			userModified: false,
			mouseMoved: false
		});

		if ( cType == "select" ) {
			var wrapper = document.createElement('div');
			wrapper.className = 'ui-slider-inneroffset';

			for(var j = 0,length = domSlider.childNodes.length;j < length;j++){
				wrapper.appendChild(domSlider.childNodes[j]);
			}

			domSlider.appendChild(wrapper);

			// slider.wrapInner( "<div class='ui-slider-inneroffset'></div>" );

			// make the handle move with a smooth transition
			handle.addClass( "ui-slider-handle-snapping" );

			options = control.find( "option" );

			for(var i = 0, optionsCount = options.length; i < optionsCount; i++){
				var side = !i ? "b":"a",
					sliderTheme = !i ? " ui-btn-down-" + trackTheme :( " " + $.mobile.activeBtnClass ),
					sliderLabel = document.createElement('div'),
					sliderImg = document.createElement('span');

				sliderImg.className = ['ui-slider-label ui-slider-label-',side,sliderTheme," ui-btn-corner-all"].join("");
				sliderImg.setAttribute('role','img');
				sliderImg.appendChild(document.createTextNode(options[i].innerHTML));
				$(sliderImg).prependTo( slider );
			}

			self._labels = $( ".ui-slider-label", slider );

		}

		label.addClass( "ui-slider" );

		// monitor the input for updated values
		control.addClass( cType === "input" ? "ui-slider-input" : "ui-slider-switch" )
			.change( function() {
				// if the user dragged the handle, the "change" event was triggered from inside refresh(); don't call refresh() again
				if (!self.mouseMoved) {
					self.refresh( val(), true );
				}
			})
			.keyup( function() { // necessary?
				self.refresh( val(), true, true );
			})
			.blur( function() {
				self.refresh( val(), true );
			});

		// prevent screen drag when slider activated
		$( document ).bind( "vmousemove", function( event ) {
			if ( self.dragging ) {
				// self.mouseMoved must be updated before refresh() because it will be used in the control "change" event
				self.mouseMoved = true;

				if ( cType === "select" ) {
					// make the handle move in sync with the mouse
					handle.removeClass( "ui-slider-handle-snapping" );
				}

				self.refresh( event );

				// only after refresh() you can calculate self.userModified
				self.userModified = self.beforeStart !== control[0].selectedIndex;
				return false;
			}
		});

		slider.bind( "vmousedown", function( event ) {
			self.dragging = true;
			self.userModified = false;
			self.mouseMoved = false;

			if ( cType === "select" ) {
				self.beforeStart = control[0].selectedIndex;
			}

			self.refresh( event );
			return false;
		})
		.bind( "vclick", false );

		slider.add( document )
			.bind( "vmouseup", function() {
				if ( self.dragging ) {

					self.dragging = false;

					if ( cType === "select") {

						// make the handle move with a smooth transition
						handle.addClass( "ui-slider-handle-snapping" );

						if ( self.mouseMoved ) {

							// this is a drag, change the value only if user dragged enough
							if ( self.userModified ) {
								self.refresh( self.beforeStart == 0 ? 1 : 0 );
							}
							else {
								self.refresh( self.beforeStart );
							}

						}
						else {
							// this is just a click, change the value
							self.refresh( self.beforeStart == 0 ? 1 : 0 );
						}

					}

					self.mouseMoved = false;

					return false;
				}
			});

		slider.insertAfter( control );

		// Only add focus class to toggle switch, sliders get it automatically from ui-btn
		if( cType == 'select' ) {
			this.handle.bind({
				focus: function() {
					slider.addClass( $.mobile.focusClass );
				},

				blur: function() {
					slider.removeClass( $.mobile.focusClass );
				}
			});
		}

		this.handle.bind({
			// NOTE force focus on handle
			vmousedown: function() {
				$( this ).focus();
			},

			vclick: false,

			keydown: function( event ) {
				var index = val();

				if ( self.options.disabled ) {
					return;
				}

				// In all cases prevent the default and mark the handle as active
				switch ( event.keyCode ) {
					case $.mobile.keyCode.HOME:
					case $.mobile.keyCode.END:
					case $.mobile.keyCode.PAGE_UP:
					case $.mobile.keyCode.PAGE_DOWN:
					case $.mobile.keyCode.UP:
					case $.mobile.keyCode.RIGHT:
					case $.mobile.keyCode.DOWN:
					case $.mobile.keyCode.LEFT:
						event.preventDefault();

						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( "ui-state-active" );
						}
						break;
				}

				// move the slider according to the keypress
				switch ( event.keyCode ) {
					case $.mobile.keyCode.HOME:
						self.refresh( min );
						break;
					case $.mobile.keyCode.END:
						self.refresh( max );
						break;
					case $.mobile.keyCode.PAGE_UP:
					case $.mobile.keyCode.UP:
					case $.mobile.keyCode.RIGHT:
						self.refresh( index + step );
						break;
					case $.mobile.keyCode.PAGE_DOWN:
					case $.mobile.keyCode.DOWN:
					case $.mobile.keyCode.LEFT:
						self.refresh( index - step );
						break;
				}
			}, // remove active mark

			keyup: function( event ) {
				if ( self._keySliding ) {
					self._keySliding = false;
					$( this ).removeClass( "ui-state-active" );
				}
			}
			});

		this.refresh(undefined, undefined, true);
	},

	refresh: function( val, isfromControl, preventInputUpdate ) {

		if ( this.options.disabled || this.element.attr('disabled')) {
			this.disable();
		}

		var control = this.element, percent,
			cType = control[0].nodeName.toLowerCase(),
			min = cType === "input" ? parseFloat( control.attr( "min" ) ) : 0,
			max = cType === "input" ? parseFloat( control.attr( "max" ) ) : control.find( "option" ).length - 1,
			step = (cType === "input" && parseFloat( control.attr( "step" ) ) > 0) ? parseFloat(control.attr("step")) : 1;

		if ( typeof val === "object" ) {
			var data = val,
				// a slight tolerance helped get to the ends of the slider
				tol = 8;
			if ( !this.dragging ||
					data.pageX < this.slider.offset().left - tol ||
					data.pageX > this.slider.offset().left + this.slider.width() + tol ) {
				return;
			}
			percent = Math.round( ( ( data.pageX - this.slider.offset().left ) / this.slider.width() ) * 100 );
		} else {
			if ( val == null ) {
				val = cType === "input" ? parseFloat( control.val() || 0 ) : control[0].selectedIndex;
			}
			percent = ( parseFloat( val ) - min ) / ( max - min ) * 100;
		}

		if ( isNaN( percent ) ) {
			return;
		}

		if ( percent < 0 ) {
			percent = 0;
		}

		if ( percent > 100 ) {
			percent = 100;
		}

		var newval = ( percent / 100 ) * ( max - min ) + min;

		//from jQuery UI slider, the following source will round to the nearest step
		var valModStep = ( newval - min ) % step;
		var alignValue = newval - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}
		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see jQueryUI: #4124)
		newval = parseFloat( alignValue.toFixed(5) );

		if ( newval < min ) {
			newval = min;
		}

		if ( newval > max ) {
			newval = max;
		}

		this.handle.css( "left", percent + "%" );
		this.handle.attr( {
				"aria-valuenow": cType === "input" ? newval : control.find( "option" ).eq( newval ).attr( "value" ),
				"aria-valuetext": cType === "input" ? newval : control.find( "option" ).eq( newval ).getEncodedText(),
				title: cType === "input" ? newval : control.find( "option" ).eq( newval ).getEncodedText()
			});
		this.valuebg && this.valuebg.css( "width", percent + "%" );

		// drag the label widths
		if ( this._labels ) {
			var handlePercent = this.handle.width() / this.slider.width() * 100,
				aPercent = percent && handlePercent + ( 100 - handlePercent ) * percent / 100,
				bPercent = percent === 100 ? 0 : Math.min( handlePercent + 100 - aPercent, 100 );

			this._labels.each(function(){
				var ab = $(this).is( ".ui-slider-label-a" );
				$( this ).width( ( ab ? aPercent : bPercent  ) + "%" );
			});
		}

		if ( !preventInputUpdate ) {
			var valueChanged = false;

			// update control"s value
			if ( cType === "input" ) {
				valueChanged = control.val() !== newval;
				control.val( newval );
			} else {
				valueChanged = control[ 0 ].selectedIndex !== newval;
				control[ 0 ].selectedIndex = newval;
			}
			if ( !isfromControl && valueChanged ) {
				control.trigger( "change" );
			}
		}
	},

	enable: function() {
		this.element.attr( "disabled", false );
		this.slider.removeClass( "ui-disabled" ).attr( "aria-disabled", false );
		return this._setOption( "disabled", false );
	},

	disable: function() {
		this.element.attr( "disabled", true );
		this.slider.addClass( "ui-disabled" ).attr( "aria-disabled", true );
		return this._setOption( "disabled", true );
	}

});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.slider.prototype.enhanceWithin( e.target, true );
});

})( jQuery );

(function( $, undefined ) {

$.widget( "mobile.selectmenu", $.mobile.widget, {
	options: {
		theme: null,
		disabled: false,
		icon: "arrow-d",
		iconpos: "right",
		inline: null,
		corners: true,
		shadow: true,
		iconshadow: true,
		menuPageTheme: "b",
		overlayTheme: "a",
		hidePlaceholderMenuItems: true,
		closeText: "Close",
		nativeMenu: true,
		// This option defaults to true on iOS devices.
		preventFocusZoom: /iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( "AppleWebKit" ) > -1,
		initSelector: "select:not(:jqmData(role='slider'))",
		mini: false
	},

	_button: function(){
		return $( "<div/>" );
	},

	_setDisabled: function( value ) {
		this.element.attr( "disabled", value );
		this.button.attr( "aria-disabled", value );
		return this._setOption( "disabled", value );
	},

	_focusButton : function() {
		var self = this;

		setTimeout( function() {
			self.button.focus();
		}, 40);
	},

  _selectOptions: function() {
    return this.select.find( "option" );
  },

	// setup items that are generally necessary for select menu extension
	_preExtension: function(){
		var classes = "";
		// TODO: Post 1.1--once we have time to test thoroughly--any classes manually applied to the original element should be carried over to the enhanced element, with an `-enhanced` suffix. See https://github.com/jquery/jquery-mobile/issues/3577
		/* if( $el[0].className.length ) {
			classes = $el[0].className;
		} */
		if( !!~this.element[0].className.indexOf( "ui-btn-left" ) ) {
			classes =  " ui-btn-left";
		}
		
		if(  !!~this.element[0].className.indexOf( "ui-btn-right" ) ) {
			classes = " ui-btn-right";
		}
		
		this.select = this.element.wrap( "<div class='ui-select" + classes + "'>" );
		this.selectID  = this.select.attr( "id" );
		this.label = $( "label[for='"+ this.selectID +"']" ).addClass( "ui-select" );
		this.isMultiple = this.select[ 0 ].multiple;
		if ( !this.options.theme ) {
			this.options.theme = $.mobile.getInheritedTheme( this.select, "c" );
		}
	},

	_create: function() {
		this._preExtension();

 		// Allows for extension of the native select for custom selects and other plugins
		// see select.custom for example extension
		// TODO explore plugin registration
		this._trigger( "beforeCreate" );

		this.button = this._button();

		var self = this,

			options = this.options,

			// IE throws an exception at options.item() function when
			// there is no selected item
			// select first in this case
			selectedIndex = this.select[ 0 ].selectedIndex == -1 ? 0 : this.select[ 0 ].selectedIndex,

			// TODO values buttonId and menuId are undefined here
			button = this.button
				.text( $( this.select[ 0 ].options.item( selectedIndex ) ).text() )
				.insertBefore( this.select )
				.buttonMarkup( {
					theme: options.theme,
					icon: options.icon,
					iconpos: options.iconpos,
					inline: options.inline,
					corners: options.corners,
					shadow: options.shadow,
					iconshadow: options.iconshadow,
					mini: options.mini
				});

		// Opera does not properly support opacity on select elements
		// In Mini, it hides the element, but not its text
		// On the desktop,it seems to do the opposite
		// for these reasons, using the nativeMenu option results in a full native select in Opera
		if ( options.nativeMenu && window.opera && window.opera.version ) {
			this.select.addClass( "ui-select-nativeonly" );
		}

		// Add counter for multi selects
		if ( this.isMultiple ) {
			this.buttonCount = $( "<span>" )
				.addClass( "ui-li-count ui-btn-up-c ui-btn-corner-all" )
				.hide()
				.appendTo( button.addClass('ui-li-has-count') );
		}

		// Disable if specified
		if ( options.disabled || this.element.attr('disabled')) {
			this.disable();
		}

		// Events on native select
		this.select.change( function() {
			self.refresh();
		});

		this.build();
	},

	build: function() {
		var self = this;

		this.select
			.appendTo( self.button )
			.bind( "vmousedown", function() {
				// Add active class to button
				self.button.addClass( $.mobile.activeBtnClass );
			})
            .bind( "focus", function() {
                self.button.addClass( $.mobile.focusClass );
            })
            .bind( "blur", function() {
                self.button.removeClass( $.mobile.focusClass );
            })
			.bind( "focus vmouseover", function() {
				self.button.trigger( "vmouseover" );
			})
			.bind( "vmousemove", function() {
				// Remove active class on scroll/touchmove
				self.button.removeClass( $.mobile.activeBtnClass );
			})
			.bind( "change blur vmouseout", function() {
				self.button.trigger( "vmouseout" )
					.removeClass( $.mobile.activeBtnClass );
			})
			.bind( "change blur", function() {
				self.button.removeClass( "ui-btn-down-" + self.options.theme );
			});

		// In many situations, iOS will zoom into the select upon tap, this prevents that from happening
		self.button.bind( "vmousedown", function() {
			if( self.options.preventFocusZoom ){
				$.mobile.zoom.disable( true );
			}
		})
		.bind( "mouseup", function() {
			if( self.options.preventFocusZoom ){
				$.mobile.zoom.enable( true );
			}
		});
	},

	selected: function() {
		return this._selectOptions().filter( ":selected" );
	},

	selectedIndices: function() {
		var self = this;

		return this.selected().map( function() {
			return self._selectOptions().index( this );
		}).get();
	},

	setButtonText: function() {
		var self = this, selected = this.selected();

		this.button.find( ".ui-btn-text" ).text( function() {
			if ( !self.isMultiple ) {
				return selected.text();
			}

			return selected.length ? selected.map( function() {
				return $( this ).text();
			}).get().join( ", " ) : self.placeholder;
		});
	},

	setButtonCount: function() {
		var selected = this.selected();

		// multiple count inside button
		if ( this.isMultiple ) {
			this.buttonCount[ selected.length > 1 ? "show" : "hide" ]().text( selected.length );
		}
	},

	refresh: function() {
		this.setButtonText();
		this.setButtonCount();
	},

	// open and close preserved in native selects
	// to simplify users code when looping over selects
	open: $.noop,
	close: $.noop,

	disable: function() {
		this._setDisabled( true );
		this.button.addClass( "ui-disabled" );
	},

	enable: function() {
		this._setDisabled( false );
		this.button.removeClass( "ui-disabled" );
	}
});

//auto self-init widgets
$( document ).bind( "pagecreate create", function( e ){
	$.mobile.selectmenu.prototype.enhanceWithin( e.target, true );
});
})( jQuery );

/*
* custom "selectmenu" plugin
*/

(function( $, undefined ) {
	var extendSelect = function( widget ){

		var select = widget.select,
			selectID  = widget.selectID,
			label = widget.label,
			thisPage = widget.select.closest( ".ui-page" ),
			screen = $( "<div>", {"class": "ui-selectmenu-screen ui-screen-hidden"} ).appendTo( thisPage ),
			selectOptions = widget._selectOptions(),
			isMultiple = widget.isMultiple = widget.select[ 0 ].multiple,
			buttonId = selectID + "-button",
			menuId = selectID + "-menu",
			menuPage = $( "<div data-" + $.mobile.ns + "role='dialog' data-" +$.mobile.ns + "theme='"+ widget.options.theme +"' data-" +$.mobile.ns + "overlay-theme='"+ widget.options.overlayTheme +"'>" +
				"<div data-" + $.mobile.ns + "role='header'>" +
				"<div class='ui-title'>" + label.getEncodedText() + "</div>"+
				"</div>"+
				"<div data-" + $.mobile.ns + "role='content'></div>"+
				"</div>" ),

			listbox =  $("<div>", { "class": "ui-selectmenu ui-selectmenu-hidden ui-overlay-shadow ui-corner-all ui-body-" + widget.options.overlayTheme + " " + $.mobile.defaultDialogTransition } ).insertAfter(screen),

			list = $( "<ul>", {
				"class": "ui-selectmenu-list",
				"id": menuId,
				"role": "listbox",
				"aria-labelledby": buttonId
			}).attr( "data-" + $.mobile.ns + "theme", widget.options.theme ).appendTo( listbox ),

			header = $( "<div>", {
				"class": "ui-header ui-bar-" + widget.options.theme
			}).prependTo( listbox ),

			headerTitle = $( "<h1>", {
				"class": "ui-title"
			}).appendTo( header ),

			headerClose = $( "<a>", {
				"text": widget.options.closeText,
				"href": "#",
				"class": "ui-btn-left"
			}).attr( "data-" + $.mobile.ns + "iconpos", "notext" ).attr( "data-" + $.mobile.ns + "icon", "delete" ).appendTo( header ).buttonMarkup(),

			menuPageContent,
			
			menuPageClose;


		$.extend( widget, {
			select: widget.select,
			selectID: selectID,
			buttonId: buttonId,
			menuId: menuId,
			thisPage: thisPage,
			menuPage: menuPage,
			label: label,
			screen: screen,
			selectOptions: selectOptions,
			isMultiple: isMultiple,
			theme: widget.options.theme,
			listbox: listbox,
			list: list,
			header: header,
			headerTitle: headerTitle,
			headerClose: headerClose,
			menuPageContent: menuPageContent,
			menuPageClose: menuPageClose,
			placeholder: "",

			build: function() {
				var self = this;

				// Create list from select, update state
				self.refresh();

				self.select.attr( "tabindex", "-1" ).focus(function() {
					$( this ).blur();
					self.button.focus();
				});

				// Button events
				self.button.bind( "vclick keydown" , function( event ) {
					if ( event.type == "vclick" ||
							 event.keyCode && ( event.keyCode === $.mobile.keyCode.ENTER ||
																	event.keyCode === $.mobile.keyCode.SPACE ) ) {

						self.open();
						event.preventDefault();
					}
				});

				// Events for list items
				self.list.attr( "role", "listbox" )
					.bind( "focusin", function( e ){
						$( e.target )
							.attr( "tabindex", "0" )
							.trigger( "vmouseover" );
						
					})
					.bind( "focusout", function( e ){
						$( e.target )
							.attr( "tabindex", "-1" )
							.trigger( "vmouseout" );
					})
					.delegate( "li:not(.ui-disabled, .ui-li-divider)", "click", function( event ) {

						// index of option tag to be selected
						var oldIndex = self.select[ 0 ].selectedIndex,
							newIndex = self.list.find( "li:not(.ui-li-divider)" ).index( this ),
							option = self._selectOptions().eq( newIndex )[ 0 ];

						// toggle selected status on the tag for multi selects
						option.selected = self.isMultiple ? !option.selected : true;

						// toggle checkbox class for multiple selects
						if ( self.isMultiple ) {
							$( this ).find( ".ui-icon" )
								.toggleClass( "ui-icon-checkbox-on", option.selected )
								.toggleClass( "ui-icon-checkbox-off", !option.selected );
						}

						// trigger change if value changed
						if ( self.isMultiple || oldIndex !== newIndex ) {
							self.select.trigger( "change" );
						}

						//hide custom select for single selects only
						if ( !self.isMultiple ) {
							self.close();
						}

						event.preventDefault();
					})
					.keydown(function( event ) {  //keyboard events for menu items
						var target = $( event.target ),
							li = target.closest( "li" ),
							prev, next;

						// switch logic based on which key was pressed
						switch ( event.keyCode ) {
							// up or left arrow keys
						 case 38:
							prev = li.prev();

							// if there's a previous option, focus it
							if ( prev.length ) {
								target
									.blur()
									.attr( "tabindex", "-1" );

								prev.find( "a" ).first().focus();
							}

							return false;
							break;

							// down or right arrow keys
						 case 40:
							next = li.next();

							// if there's a next option, focus it
							if ( next.length ) {
								target
									.blur()
									.attr( "tabindex", "-1" );

								next.find( "a" ).first().focus();
							}

							return false;
							break;

							// If enter or space is pressed, trigger click
						 case 13:
						 case 32:
							target.trigger( "click" );

							return false;
							break;
						}
					});

				// button refocus ensures proper height calculation
				// by removing the inline style and ensuring page inclusion
				self.menuPage.bind( "pagehide", function() {
					self.list.appendTo( self.listbox );
					self._focusButton();

					// TODO centralize page removal binding / handling in the page plugin.
					// Suggestion from @jblas to do refcounting
					//
					// TODO extremely confusing dependency on the open method where the pagehide.remove
					// bindings are stripped to prevent the parent page from disappearing. The way
					// we're keeping pages in the DOM right now sucks
					//
					// rebind the page remove that was unbound in the open function
					// to allow for the parent page removal from actions other than the use
					// of a dialog sized custom select
					//
					// doing this here provides for the back button on the custom select dialog
					$.mobile._bindPageRemove.call( self.thisPage );
				});

				// Events on "screen" overlay
				self.screen.bind( "vclick", function( event ) {
					self.close();
				});

				// Close button on small overlays
				self.headerClose.click( function() {
					if ( self.menuType == "overlay" ) {
						self.close();
						return false;
					}
				});

				// track this dependency so that when the parent page
				// is removed on pagehide it will also remove the menupage
				self.thisPage.addDependents( this.menuPage );
			},

			_isRebuildRequired: function() {
				var list = this.list.find( "li" ),
					options = this._selectOptions();

				// TODO exceedingly naive method to determine difference
				// ignores value changes etc in favor of a forcedRebuild
				// from the user in the refresh method
				return options.text() !== list.text();
			},

			refresh: function( forceRebuild , foo ){
				var self = this,
				select = this.element,
				isMultiple = this.isMultiple,
				options = this._selectOptions(),
				selected = this.selected(),
				// return an array of all selected index's
				indicies = this.selectedIndices();

				if (  forceRebuild || this._isRebuildRequired() ) {
					self._buildList();
				}

				self.setButtonText();
				self.setButtonCount();

				self.list.find( "li:not(.ui-li-divider)" )
					.removeClass( $.mobile.activeBtnClass )
					.attr( "aria-selected", false )
					.each(function( i ) {

						if ( $.inArray( i, indicies ) > -1 ) {
							var item = $( this );

							// Aria selected attr
							item.attr( "aria-selected", true );

							// Multiple selects: add the "on" checkbox state to the icon
							if ( self.isMultiple ) {
								item.find( ".ui-icon" ).removeClass( "ui-icon-checkbox-off" ).addClass( "ui-icon-checkbox-on" );
							} else {
								item.addClass( $.mobile.activeBtnClass );
							}
						}
					});
			},

			close: function() {
				if ( this.options.disabled || !this.isOpen ) {
					return;
				}

				var self = this;

				if ( self.menuType == "page" ) {
					// doesn't solve the possible issue with calling change page
					// where the objects don't define data urls which prevents dialog key
					// stripping - changePage has incoming refactor
					window.history.back();
				} else {
					self.screen.addClass( "ui-screen-hidden" );
					self.listbox.addClass( "ui-selectmenu-hidden" ).removeAttr( "style" ).removeClass( "in" );
					self.list.appendTo( self.listbox );
					self._focusButton();
				}

				// allow the dialog to be closed again
				self.isOpen = false;
			},

			open: function() {
				if ( this.options.disabled ) {
					return;
				}

				var self = this,
          $window = $( window ),
          selfListParent = self.list.parent(),
					menuHeight = selfListParent.outerHeight(),
					menuWidth = selfListParent.outerWidth(),
					activePage = $( ".ui-page-active" ),
					tScrollElem = activePage,
					scrollTop = $window.scrollTop(),
					btnOffset = self.button.offset().top,
					screenHeight = $window.height(),
					screenWidth = $window.width();

				//add active class to button
				self.button.addClass( $.mobile.activeBtnClass );

				//remove after delay
				setTimeout( function() {
					self.button.removeClass( $.mobile.activeBtnClass );
				}, 300);

				function focusMenuItem() {
					self.list.find( "." + $.mobile.activeBtnClass + " a" ).focus();
				}

				if ( menuHeight > screenHeight - 80 || !$.support.scrollTop ) {
					
					self.menuPage.appendTo( $.mobile.pageContainer ).page();					
					self.menuPageContent = menuPage.find( ".ui-content" );
					self.menuPageClose = menuPage.find( ".ui-header a" );
					
					// prevent the parent page from being removed from the DOM,
					// otherwise the results of selecting a list item in the dialog
					// fall into a black hole
					self.thisPage.unbind( "pagehide.remove" );

					//for WebOS/Opera Mini (set lastscroll using button offset)
					if ( scrollTop == 0 && btnOffset > screenHeight ) {
						self.thisPage.one( "pagehide", function() {
							$( this ).jqmData( "lastScroll", btnOffset );
						});
					}

					self.menuPage.one( "pageshow", function() {
						// silentScroll() is called whenever a page is shown to restore
						// any previous scroll position the page may have had. We need to
						// wait for the "silentscroll" event before setting focus to avoid
						// the browser"s "feature" which offsets rendering to make sure
						// whatever has focus is in view.
						$( window ).one( "silentscroll", function() {
							focusMenuItem();
						});

						self.isOpen = true;
					});

					self.menuType = "page";
					self.menuPageContent.append( self.list );
					self.menuPage.find("div .ui-title").text(self.label.text());
					$.mobile.changePage( self.menuPage, {
						transition: $.mobile.defaultDialogTransition
					});
				} else {
					self.menuType = "overlay";

					self.screen.height( $(document).height() )
						.removeClass( "ui-screen-hidden" );

					// Try and center the overlay over the button
					var roomtop = btnOffset - scrollTop,
						roombot = scrollTop + screenHeight - btnOffset,
						halfheight = menuHeight / 2,
						maxwidth = parseFloat( self.list.parent().css( "max-width" ) ),
						newtop, newleft;

					if ( roomtop > menuHeight / 2 && roombot > menuHeight / 2 ) {
						newtop = btnOffset + ( self.button.outerHeight() / 2 ) - halfheight;
					} else {
						// 30px tolerance off the edges
						newtop = roomtop > roombot ? scrollTop + screenHeight - menuHeight - 30 : scrollTop + 30;
					}

					// If the menuwidth is smaller than the screen center is
					if ( menuWidth < maxwidth ) {
						newleft = ( screenWidth - menuWidth ) / 2;
					} else {

						//otherwise insure a >= 30px offset from the left
						newleft = self.button.offset().left + self.button.outerWidth() / 2 - menuWidth / 2;

						// 30px tolerance off the edges
						if ( newleft < 30 ) {
							newleft = 30;
						} else if ( (newleft + menuWidth) > screenWidth ) {
							newleft = screenWidth - menuWidth - 30;
						}
					}

					self.listbox.append( self.list )
						.removeClass( "ui-selectmenu-hidden" )
						.css({
							top: newtop,
							left: newleft
						})
						.addClass( "in" );

					focusMenuItem();

					// duplicate with value set in page show for dialog sized selects
					self.isOpen = true;
				}
			},

			_buildList: function() {
				var self = this,
					o = this.options,
					placeholder = this.placeholder,
					optgroups = [],
					lis = [],
					dataIcon = self.isMultiple ? "checkbox-off" : "false";

				self.list.empty().filter( ".ui-listview" ).listview( "destroy" );

				var $options = self.select.find("option"),
					numOptions = $options.length,                      
					select = this.select[ 0 ],                         
					dataPrefix = 'data-' + $.mobile.ns,                 
					dataIndexAttr = dataPrefix + 'option-index', 
					dataIconAttr = dataPrefix + 'icon',
					dataRoleAttr = dataPrefix + 'role',
					fragment = document.createDocumentFragment(),
					optGroup;
									
				for (var i = 0; i < numOptions;i++){				
					var option = $options[i],
						$option = $(option),
						parent = option.parentNode,
						text = $option.text(),			
						anchor  = document.createElement('a');
						classes = [];				
					
					anchor.setAttribute('href','#');							
					anchor.appendChild(document.createTextNode(text));	
					
					// Are we inside an optgroup?									
					if (parent !== select && parent.nodeName.toLowerCase() === "optgroup"){
						var optLabel = parent.getAttribute('label');
						if ( optLabel != optGroup) {						
							var divider = document.createElement('li');
							divider.setAttribute(dataRoleAttr,'list-divider');
							divider.setAttribute('role','option');
							divider.setAttribute('tabindex','-1');
							divider.appendChild(document.createTextNode(optLabel));
							fragment.appendChild(divider);
							optGroup = optLabel;
						}
					}															
										
					if (!placeholder && (!option.getAttribute( "value" ) || text.length == 0 || $option.jqmData( "placeholder" )) ) {
						if ( o.hidePlaceholderMenuItems ) {
							classes.push( "ui-selectmenu-placeholder" );
						}						
						placeholder = self.placeholder = text;									
					}
															
					var item = document.createElement('li');															
					if ( option.disabled ) {
						classes.push( "ui-disabled" );
						item.setAttribute('aria-disabled',true);
					}
					item.setAttribute(dataIndexAttr,i);
					item.setAttribute(dataIconAttr,dataIcon);					
					item.className = classes.join(" ");
					item.setAttribute('role','option');
					anchor.setAttribute('tabindex','-1');
					item.appendChild(anchor);					
					fragment.appendChild(item);
				}	

				self.list[0].appendChild(fragment);

				// Hide header close link for single selects
				if ( !this.isMultiple ) {
					this.headerClose.hide();
				}

				// Hide header if it's not a multiselect and there's no placeholder
				if ( !this.isMultiple && !placeholder.length ) {
					this.header.hide();
				} else {
					this.headerTitle.text( this.placeholder );
				}

				// Now populated, create listview
				self.list.listview();
			},

			_button: function(){
				return $( "<a>", {
					"href": "#",
					"role": "button",
					// TODO value is undefined at creation
					"id": this.buttonId,
					"aria-haspopup": "true",

					// TODO value is undefined at creation
					"aria-owns": this.menuId
				});
			}
		});
	};

	$( document ).delegate( "select", "selectmenubeforecreate", function(){
		var selectmenuWidget = $( this ).data( "selectmenu" );

		if( !selectmenuWidget.options.nativeMenu ){
			extendSelect( selectmenuWidget );
		}
	});
})( jQuery );

(function( $, undefined ) {


	$.widget( "mobile.fixedtoolbar", $.mobile.widget, {
		options: {
			visibleOnPageShow: true,
			disablePageZoom: true,
			transition: "slide", //can be none, fade, slide (slide maps to slideup or slidedown)
			fullscreen: false,
			tapToggle: true,
			tapToggleBlacklist: "a, input, select, textarea, .ui-header-fixed, .ui-footer-fixed",
			hideDuringFocus: "input, textarea, select",
			updatePagePadding: true,
			trackPersistentToolbars: true,

			// Browser detection! Weeee, here we go...
			// Unfortunately, position:fixed is costly, not to mention probably impossible, to feature-detect accurately.
			// Some tests exist, but they currently return false results in critical devices and browsers, which could lead to a broken experience.
			// Testing fixed positioning is also pretty obtrusive to page load, requiring injected elements and scrolling the window
			// The following function serves to rule out some popular browsers with known fixed-positioning issues
			// This is a plugin option like any other, so feel free to improve or overwrite it
			supportBlacklist: function(){
				var w = window,
					ua = navigator.userAgent,
					platform = navigator.platform,
					// Rendering engine is Webkit, and capture major version
					wkmatch = ua.match( /AppleWebKit\/([0-9]+)/ ),
					wkversion = !!wkmatch && wkmatch[ 1 ],
					ffmatch = ua.match( /Fennec\/([0-9]+)/ ),
					ffversion = !!ffmatch && ffmatch[ 1 ],
					operammobilematch = ua.match( /Opera Mobile\/([0-9]+)/ ),
					bbmatch = w.blackberry && w.navigator.appVersion.match( /Version\/([0-9]+)/ ),
					bbversion = !!bbmatch && parseInt( bbmatch[ 1 ], 10 ),
					omversion = !!operammobilematch && operammobilematch[ 1 ];
					
				if(
					// iOS 4.3 and older : Platform is iPhone/Pad/Touch and Webkit version is less than 534 (ios5)
					( ( platform.indexOf( "iPhone" ) > -1 || platform.indexOf( "iPad" ) > -1  || platform.indexOf( "iPod" ) > -1 ) && wkversion && wkversion < 534 )
					||
					// Opera Mini
					( w.operamini && ({}).toString.call( w.operamini ) === "[object OperaMini]" )
					||
					( operammobilematch && omverson < 7458 )
					||
					//Android lte 2.1: Platform is Android and Webkit version is less than 533 (Android 2.2)
					( ua.indexOf( "Android" ) > -1 && wkversion && wkversion < 533 )
					||
					// Firefox Mobile before 6.0 -
					( ffversion && ffversion < 6 )
					||
					// WebOS less than 3
					( "palmGetResource" in window && wkversion && wkversion < 534 )
					||
					// BlackBerry six and below.
					( w.blackberry && bbversion < 7 )
					||
					// MeeGo
					( ua.indexOf( "MeeGo" ) > -1 && ua.indexOf( "NokiaBrowser/8.5.0" ) > -1 )
				){
					return true;
				}

				return false;
			},
			initSelector: ":jqmData(position='fixed')"
		},

		_create: function() {

			var self = this,
				o = self.options,
				$el = self.element,
				tbtype = $el.is( ".ui-header" ) ? "header" : "footer",
				$page = $el.closest(".ui-page");

			// Feature detecting support for
			if( o.supportBlacklist() ){
				self.destroy();
				return;
			}

			$el.addClass( "ui-"+ tbtype +"-fixed" );

			// "fullscreen" overlay positioning
			if( $el.jqmData( "fullscreen" ) ){
				$el.addClass( "ui-"+ tbtype +"-fullscreen" );
				$page.addClass( "ui-page-" + tbtype + "-fullscreen" );
			}
			// If not fullscreen, add class to page to set top or bottom padding
			else{
				$page.addClass( "ui-page-" + tbtype + "-fixed" );
			}

			self._addTransitionClass();
			self._bindPageEvents();
			self._bindToggleHandlers();
		},

		_addTransitionClass: function(){
			var tclass = this.options.transition;

			if( tclass && tclass !== "none" ){
				// use appropriate slide for header or footer
				if( tclass === "slide" ){
					tclass = this.element.is( ".ui-header" ) ? "slidedown" : "slideup";
				}

				this.element.addClass( tclass );
			}
		},

		_bindPageEvents: function(){
			var self = this,
				o = self.options,
				$el = self.element;

			//page event bindings
			// Fixed toolbars require page zoom to be disabled, otherwise usability issues crop up
			// This method is meant to disable zoom while a fixed-positioned toolbar page is visible
			$el.closest( ".ui-page" )
				.bind( "pagebeforeshow", function(){
					if( o.disablePageZoom ){
						$.mobile.zoom.disable( true );
					}
					if( o.visibleOnPageShow ){
						self.show( true );
					}
				} )
				.bind( "webkitAnimationStart animationstart updatelayout", function(){
					if( o.updatePagePadding ){
						self.updatePagePadding();
					}
				})
				.bind( "pageshow", function(){
					self.updatePagePadding();
					if( o.updatePagePadding ){
						$( window ).bind( "throttledresize." + self.widgetName, function(){
						 	self.updatePagePadding();
						});
					}
				})
				.bind( "pagebeforehide", function( e, ui ){
					if( o.disablePageZoom ){
						$.mobile.zoom.enable( true );
					}
					if( o.updatePagePadding ){
						$( window ).unbind( "throttledresize." + self.widgetName );
					}

					if( o.trackPersistentToolbars ){
						var thisFooter = $( ".ui-footer-fixed:jqmData(id)", this ),
							thisHeader = $( ".ui-header-fixed:jqmData(id)", this ),
							nextFooter = thisFooter.length && ui.nextPage && $( ".ui-footer-fixed:jqmData(id='" + thisFooter.jqmData( "id" ) + "')", ui.nextPage ),
							nextHeader = thisHeader.length && ui.nextPage && $( ".ui-header-fixed:jqmData(id='" + thisHeader.jqmData( "id" ) + "')", ui.nextPage );

							if( nextFooter.length || nextHeader.length ){

								nextFooter.add( nextHeader ).appendTo( $.mobile.pageContainer );

								ui.nextPage.one( "pageshow", function(){
									nextFooter.add( nextHeader ).appendTo( this );
								} );
							}
					}

				});
		},

		_visible: false,

		// This will set the content element's top or bottom padding equal to the toolbar's height
		updatePagePadding: function() {
			var $el = this.element,
				header = $el.is( ".ui-header" );

			// This behavior only applies to "fixed", not "fullscreen"
			if( this.options.fullscreen ){ return; }

			$el.closest( ".ui-page" ).css( "padding-" + ( header ? "top" : "bottom" ), $el.outerHeight() );
		},

		show: function( notransition ){
			var hideClass = "ui-fixed-hidden",
				$el = this.element,
				$win = $( window ),
				scroll = $win.scrollTop(),
				elHeight = $el.height(),
				pHeight = $el.closest( ".ui-page" ).height(),
				viewportHeight = Math.min( screen.height, $win.height() ),
				tbtype = $el.is( ".ui-header" ) ? "header" : "footer";

				if( !notransition && ( this.options.transition && this.options.transition !== "none" &&
					(
					( tbtype === "header" && !this.options.fullscreen && scroll > elHeight ) ||
					( tbtype === "footer" && !this.options.fullscreen && scroll + viewportHeight < pHeight - elHeight )
					) || this.options.fullscreen ) ){
				$el
					.removeClass( "out " + hideClass )
					.addClass( "in" );
			}
			else {
				$el.removeClass( hideClass );
			}
			this._visible = true;
		},

		hide: function( notransition ){
			var hideClass = "ui-fixed-hidden",
				$el = this.element,
				$win = $( window ),
				scroll = $win.scrollTop(),
				elHeight = $el.height(),
				pHeight = $el.closest( ".ui-page" ).height(),
				viewportHeight = Math.min( screen.height, $win.height() ),
				tbtype = $el.is( ".ui-header" ) ? "header" : "footer",
				// if it's a slide transition, our new transitions need the reverse class as well to slide outward
				outclass = "out" + ( this.options.transition === "slide" ? " reverse" : "" );

			if( !notransition && ( this.options.transition && this.options.transition !== "none" &&
					(
					( tbtype === "header" && !this.options.fullscreen && scroll > elHeight ) ||
					( tbtype === "footer" && !this.options.fullscreen && scroll + viewportHeight < pHeight - elHeight )
					) || this.options.fullscreen ) ){
				$el
					.addClass( outclass )
					.removeClass( "in" )
					.animationComplete( function(){
						$el.addClass( hideClass ).removeClass( outclass );
					});
			}
			else {
				$el.addClass( hideClass ).removeClass( outclass );
			}
			this._visible = false;
		},

		toggle: function(){
			this[ this._visible ? "hide" : "show" ]();
		},

		_bindToggleHandlers: function(){
			var self = this,
				o = self.options,
				$el = self.element;

			// tap toggle
			$el.closest( ".ui-page" )
				.bind( "vclick", function( e ){
					if( o.tapToggle && !$( e.target ).closest( o.tapToggleBlacklist ).length ){
						self.toggle();
					}
				})
				.bind( "focusin focusout", function( e ){
					if( screen.width < 500 && $( e.target ).is( o.hideDuringFocus ) && !$( e.target ).closest( ".ui-header-fixed, .ui-footer-fixed" ).length ){
						self[ ( e.type === "focusin" && self._visible ) ? "hide" : "show" ]();
					}
				});
		},

		destroy: function(){
			this.element.removeClass( "ui-header-fixed ui-footer-fixed ui-header-fullscreen ui-footer-fullscreen in out fade slidedown slideup ui-fixed-hidden" );
			this.element.closest( ".ui-page" ).removeClass( "ui-page-header-fixed ui-page-footer-fixed ui-page-header-fullscreen ui-page-footer-fullscreen" );
		}

	});

	//auto self-init widgets
	$( document ).bind( "pagecreate create", function( e ){
		$.mobile.fixedtoolbar.prototype.enhanceWithin( e.target );
	});

})( jQuery );

( function( $, window ) {
	
	// This fix addresses an iOS bug, so return early if the UA claims it's something else.
	if( !(/iPhone|iPad|iPod/.test( navigator.platform ) && navigator.userAgent.indexOf( "AppleWebKit" ) > -1 ) ){
		return;
	}
	
    var zoom = $.mobile.zoom,
		evt, x, y, z, aig;
	
    function checkTilt( e ){
		evt = e.originalEvent;
		aig = evt.accelerationIncludingGravity;
		
		x = Math.abs( aig.x );
		y = Math.abs( aig.y );
		z = Math.abs( aig.z );
				
		// If portrait orientation and in one of the danger zones
        if( !window.orientation && ( x > 7 || ( ( z > 6 && y < 8 || z < 8 && y > 6 ) && x > 5 ) ) ){
			if( zoom.enabled ){
				zoom.disable();
			}        	
        }
		else if( !zoom.enabled ){
			zoom.enable();
        }
    }

    $( window )
		.bind( "orientationchange.iosorientationfix", zoom.enable )
		.bind( "devicemotion.iosorientationfix", checkTilt );

}( jQuery, this ));

( function( $, window, undefined ) {
	var	$html = $( "html" ),
			$head = $( "head" ),
			$window = $( window );

 	// trigger mobileinit event - useful hook for configuring $.mobile settings before they're used
	$( window.document ).trigger( "mobileinit" );

	// support conditions
	// if device support condition(s) aren't met, leave things as they are -> a basic, usable experience,
	// otherwise, proceed with the enhancements
	if ( !$.mobile.gradeA() ) {
		return;
	}

	// override ajaxEnabled on platforms that have known conflicts with hash history updates
	// or generally work better browsing in regular http for full page refreshes (BB5, Opera Mini)
	if ( $.mobile.ajaxBlacklist ) {
		$.mobile.ajaxEnabled = false;
	}

	// Add mobile, initial load "rendering" classes to docEl
	$html.addClass( "ui-mobile ui-mobile-rendering" );
	
	// This is a fallback. If anything goes wrong (JS errors, etc), or events don't fire, 
	// this ensures the rendering class is removed after 5 seconds, so content is visible and accessible
	setTimeout( hideRenderingClass, 5000 );

	// loading div which appears during Ajax requests
	// will not appear if $.mobile.loadingMessage is false
	var loaderClass = "ui-loader",
		$loader = $( "<div class='" + loaderClass + "'><span class='ui-icon ui-icon-loading'></span><h1></h1></div>" );
	
	// For non-fixed supportin browsers. Position at y center (if scrollTop supported), above the activeBtn (if defined), or just 100px from top
	function fakeFixLoader(){
		$loader
			.css({
				top: $.support.scrollTop && $window.scrollTop() + $window.height() / 2 ||
				activeBtn.length && activeBtn.offset().top || 100
			});		
	}
	
	// check position of loader to see if it appears to be "fixed" to center
	// if not, use abs positioning
	function checkLoaderPosition(){
		if( $loader.offset().top < $window.scrollTop() ){
			$loader.addClass( "ui-loader-fakefix" );
			fakeFixLoader();
			$window
				.unbind( "scroll", checkLoaderPosition )
				.bind( "scroll", fakeFixLoader );
		}
	}
	
	//remove initial build class (only present on first pageshow)
	function hideRenderingClass(){
		$html.removeClass( "ui-mobile-rendering" );
	}
	

	$.extend($.mobile, {
		// turn on/off page loading message.
		showPageLoadingMsg: function( theme, msgText, textonly ) {
			$html.addClass( "ui-loading" );
			
			if ( $.mobile.loadingMessage ) {
				var activeBtn = $( "." + $.mobile.activeBtnClass ).first(),
					theme = theme || $.mobile.loadingMessageTheme,
					// text visibility from argument takes priority
					textVisible = textonly || $.mobile.loadingMessageTextVisible;
					

				$loader
					.attr( "class", loaderClass + " ui-corner-all ui-body-" + ( theme || "a" ) + " ui-loader-" + ( textVisible ? "verbose" : "default" ) + ( textonly ? " ui-loader-textonly" : "" ) )
					.find( "h1" )
						.text( msgText || $.mobile.loadingMessage )
						.end()
					.appendTo( $.mobile.pageContainer );
					
				checkLoaderPosition();
				$window.bind( "scroll", checkLoaderPosition );
			}
		},

		hidePageLoadingMsg: function() {
			$html.removeClass( "ui-loading" );
			
			if( $.mobile.loadingMessage ){
				$loader.removeClass( "ui-loader-fakefix" );
			}
			
			$( window ).unbind( "scroll", fakeFixLoader );
		},

		// find and enhance the pages in the dom and transition to the first page.
		initializePage: function() {
			// find present pages
			var $pages = $( ":jqmData(role='page'), :jqmData(role='dialog')" );
			
			// if no pages are found, create one with body's inner html
			if ( !$pages.length ) {
				$pages = $( "body" ).wrapInner( "<div data-" + $.mobile.ns + "role='page'></div>" ).children( 0 );
			}
			
			// add dialogs, set data-url attrs
			$pages.each(function() {
				var $this = $(this);

				// unless the data url is already set set it to the pathname
				if ( !$this.jqmData("url") ) {
					$this.attr( "data-" + $.mobile.ns + "url", $this.attr( "id" ) || location.pathname + location.search );
				}
			});

			// define first page in dom case one backs out to the directory root (not always the first page visited, but defined as fallback)
			$.mobile.firstPage = $pages.first();

			// define page container
			$.mobile.pageContainer = $pages.first().parent().addClass( "ui-mobile-viewport" );

			// alert listeners that the pagecontainer has been determined for binding
			// to events triggered on it
			$window.trigger( "pagecontainercreate" );

			// cue page loading message
			$.mobile.showPageLoadingMsg();
			
			//remove initial build class (only present on first pageshow)
			hideRenderingClass();

			// if hashchange listening is disabled or there's no hash deeplink, change to the first page in the DOM
			if ( !$.mobile.hashListeningEnabled || !$.mobile.path.stripHash( location.hash ) ) {
				$.mobile.changePage( $.mobile.firstPage, { transition: "none", reverse: true, changeHash: false, fromHashChange: true } );
			}
			// otherwise, trigger a hashchange to load a deeplink
			else {
				$window.trigger( "hashchange", [ true ] );
			}
		}
	});

	// initialize events now, after mobileinit has occurred
	$.mobile._registerInternalEvents();

	// check which scrollTop value should be used by scrolling to 1 immediately at domready
	// then check what the scroll top is. Android will report 0... others 1
	// note that this initial scroll won't hide the address bar. It's just for the check.
	$(function() {
		window.scrollTo( 0, 1 );

		// if defaultHomeScroll hasn't been set yet, see if scrollTop is 1
		// it should be 1 in most browsers, but android treats 1 as 0 (for hiding addr bar)
		// so if it's 1, use 0 from now on
		$.mobile.defaultHomeScroll = ( !$.support.scrollTop || $(window).scrollTop() === 1 ) ? 0 : 1;


		// TODO: Implement a proper registration mechanism with dependency handling in order to not have exceptions like the one below
		//auto self-init widgets for those widgets that have a soft dependency on others
		if ( $.fn.controlgroup ) {
			$( document ).bind( "pagecreate create", function( e ){
				$( ":jqmData(role='controlgroup')", e.target )
					.jqmEnhanceable()
					.controlgroup({ excludeInvisible: false });
			});
		}

		//dom-ready inits
		if( $.mobile.autoInitializePage ){
			$.mobile.initializePage();
		}

		// window load event
		// hide iOS browser chrome on load
		$window.load( $.mobile.silentScroll );
	});
}( jQuery, this ));


}));

/**
 * @license AngularJS v1.0.0rc3
 * (c) 2010-2012 AngularJS http://angularjs.org
 * License: MIT
 */
'use strict';
(function(window, document, undefined){

////////////////////////////////////

    if (typeof document.getAttribute == $undefined)
        document.getAttribute = function() {};

    /**
     * @ngdoc function
     * @name angular.lowercase
     * @function
     *
     * @description Converts the specified string to lowercase.
     * @param {string} string String to be converted to lowercase.
     * @returns {string} Lowercased string.
     */
    var lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};


    /**
     * @ngdoc function
     * @name angular.uppercase
     * @function
     *
     * @description Converts the specified string to uppercase.
     * @param {string} string String to be converted to uppercase.
     * @returns {string} Uppercased string.
     */
    var uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};


    var manualLowercase = function(s) {
        return isString(s)
            ? s.replace(/[A-Z]/g, function(ch) {return fromCharCode(ch.charCodeAt(0) | 32);})
            : s;
    };
    var manualUppercase = function(s) {
        return isString(s)
            ? s.replace(/[a-z]/g, function(ch) {return fromCharCode(ch.charCodeAt(0) & ~32);})
            : s;
    };


// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish
// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods
// with correct but slower alternatives.
    if ('i' !== 'I'.toLowerCase()) {
        lowercase = manualLowercase;
        uppercase = manualUppercase;
    }

    function fromCharCode(code) {return String.fromCharCode(code);}


    var $boolean          = 'boolean',
        $console          = 'console',
        $length           = 'length',
        $name             = 'name',
        $object           = 'object',
        $string           = 'string',
        $undefined        = 'undefined',
        Error             = window.Error,
        /** holds major version number for IE or NaN for real browsers */
            msie              = int((/msie (\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]),
        jqLite,           // delay binding since jQuery could be loaded after us.
        jQuery,           // delay binding
        slice             = [].slice,
        push              = [].push,
        toString          = Object.prototype.toString,

        /** @name angular */
            angular           = window.angular || (window.angular = {}),
        angularModule,
        /** @name angular.module.ng */
            nodeName_,
        uid               = ['0', '0', '0'];

    /**
     * @ngdoc function
     * @name angular.forEach
     * @function
     *
     * @description
     * Invokes the `iterator` function once for each item in `obj` collection, which can be either an
     * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`
     * is the value of an object property or an array element and `key` is the object property key or
     * array element index. Specifying a `context` for the function is optional.
     *
     * Note: this function was previously known as `angular.foreach`.
     *
     <pre>
     var values = {name: 'misko', gender: 'male'};
     var log = [];
     angular.forEach(values, function(value, key){
     this.push(key + ': ' + value);
     }, log);
     expect(log).toEqual(['name: misko', 'gender:male']);
     </pre>
     *
     * @param {Object|Array} obj Object to iterate over.
     * @param {Function} iterator Iterator function.
     * @param {Object=} context Object to become context (`this`) for the iterator function.
     * @returns {Object|Array} Reference to `obj`.
     */
    function forEach(obj, iterator, context) {
        var key;
        if (obj) {
            if (isFunction(obj)){
                for (key in obj) {
                    if (key != 'prototype' && key != $length && key != $name && obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key);
                    }
                }
            } else if (obj.forEach && obj.forEach !== forEach) {
                obj.forEach(iterator, context);
            } else if (isObject(obj) && isNumber(obj.length)) {
                for (key = 0; key < obj.length; key++)
                    iterator.call(context, obj[key], key);
            } else {
                for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        iterator.call(context, obj[key], key);
                    }
                }
            }
        }
        return obj;
    }

    function sortedKeys(obj) {
        var keys = [];
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys.sort();
    }

    function forEachSorted(obj, iterator, context) {
        var keys = sortedKeys(obj)
        for ( var i = 0; i < keys.length; i++) {
            iterator.call(context, obj[keys[i]], keys[i]);
        }
        return keys;
    }


    /**
     * when using forEach the params are value, key, but it is often useful to have key, value.
     * @param {function(string, *)} iteratorFn
     * @returns {function(*, string)}
     */
    function reverseParams(iteratorFn) {
        return function(value, key) { iteratorFn(key, value) };
    }

    /**
     * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
     * characters such as '012ABC'. The reason why we are not using simply a number counter is that
     * the number string gets longer over time, and it can also overflow, where as the the nextId
     * will grow much slower, it is a string, and it will never overflow.
     *
     * @returns an unique alpha-numeric string
     */
    function nextUid() {
        var index = uid.length;
        var digit;

        while(index) {
            index--;
            digit = uid[index].charCodeAt(0);
            if (digit == 57 /*'9'*/) {
                uid[index] = 'A';
                return uid.join('');
            }
            if (digit == 90  /*'Z'*/) {
                uid[index] = '0';
            } else {
                uid[index] = String.fromCharCode(digit + 1);
                return uid.join('');
            }
        }
        uid.unshift('0');
        return uid.join('');
    }

    /**
     * @ngdoc function
     * @name angular.extend
     * @function
     *
     * @description
     * Extends the destination object `dst` by copying all of the properties from the `src` object(s)
     * to `dst`. You can specify multiple `src` objects.
     *
     * @param {Object} dst Destination object.
     * @param {...Object} src Source object(s).
     */
    function extend(dst) {
        forEach(arguments, function(obj){
            if (obj !== dst) {
                forEach(obj, function(value, key){
                    dst[key] = value;
                });
            }
        });
        return dst;
    }

    function int(str) {
        return parseInt(str, 10);
    }


    function inherit(parent, extra) {
        return extend(new (extend(function() {}, {prototype:parent}))(), extra);
    }


    /**
     * @ngdoc function
     * @name angular.noop
     * @function
     *
     * @description
     * A function that performs no operations. This function can be useful when writing code in the
     * functional style.
     <pre>
     function foo(callback) {
     var result = calculateResult();
     (callback || angular.noop)(result);
     }
     </pre>
     */
    function noop() {}
    noop.$inject = [];


    /**
     * @ngdoc function
     * @name angular.identity
     * @function
     *
     * @description
     * A function that returns its first argument. This function is useful when writing code in the
     * functional style.
     *
     <pre>
     function transformer(transformationFn, value) {
     return (transformationFn || identity)(value);
     };
     </pre>
     */
    function identity($) {return $;}
    identity.$inject = [];


    function valueFn(value) {return function() {return value;};}

    /**
     * @ngdoc function
     * @name angular.isUndefined
     * @function
     *
     * @description
     * Determines if a reference is undefined.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is undefined.
     */
    function isUndefined(value){return typeof value == $undefined;}


    /**
     * @ngdoc function
     * @name angular.isDefined
     * @function
     *
     * @description
     * Determines if a reference is defined.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is defined.
     */
    function isDefined(value){return typeof value != $undefined;}


    /**
     * @ngdoc function
     * @name angular.isObject
     * @function
     *
     * @description
     * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not
     * considered to be objects.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is an `Object` but not `null`.
     */
    function isObject(value){return value!=null && typeof value == $object;}


    /**
     * @ngdoc function
     * @name angular.isString
     * @function
     *
     * @description
     * Determines if a reference is a `String`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `String`.
     */
    function isString(value){return typeof value == $string;}


    /**
     * @ngdoc function
     * @name angular.isNumber
     * @function
     *
     * @description
     * Determines if a reference is a `Number`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `Number`.
     */
    function isNumber(value){return typeof value == 'number';}


    /**
     * @ngdoc function
     * @name angular.isDate
     * @function
     *
     * @description
     * Determines if a value is a date.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `Date`.
     */
    function isDate(value){
        return toString.apply(value) == '[object Date]';
    }


    /**
     * @ngdoc function
     * @name angular.isArray
     * @function
     *
     * @description
     * Determines if a reference is an `Array`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is an `Array`.
     */
    function isArray(value) {
        return toString.apply(value) == '[object Array]';
    }


    /**
     * @ngdoc function
     * @name angular.isFunction
     * @function
     *
     * @description
     * Determines if a reference is a `Function`.
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a `Function`.
     */
    function isFunction(value){return typeof value == 'function';}


    /**
     * Checks if `obj` is a window object.
     *
     * @private
     * @param {*} obj Object to check
     * @returns {boolean} True if `obj` is a window obj.
     */
    function isWindow(obj) {
        return obj && obj.document && obj.location && obj.alert && obj.setInterval;
    }


    function isScope(obj) {
        return obj && obj.$evalAsync && obj.$watch;
    }


    function isFile(obj) {
        return toString.apply(obj) === '[object File]';
    }


    function isBoolean(value) {return typeof value == $boolean;}
    function isTextNode(node) {return nodeName_(node) == '#text';}

    function trim(value) {
        return isString(value) ? value.replace(/^\s*/, '').replace(/\s*$/, '') : value;
    }

    /**
     * @ngdoc function
     * @name angular.isElement
     * @function
     *
     * @description
     * Determines if a reference is a DOM element (or wrapped jQuery element).
     *
     * @param {*} value Reference to check.
     * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).
     */
    function isElement(node) {
        return node &&
            (node.nodeName  // we are a direct element
                || (node.bind && node.find));  // we have a bind and find method part of jQuery API
    }

    /**
     * @param str 'key1,key2,...'
     * @returns {object} in the form of {key1:true, key2:true, ...}
     */
    function makeMap(str){
        var obj = {}, items = str.split(","), i;
        for ( i = 0; i < items.length; i++ )
            obj[ items[i] ] = true;
        return obj;
    }



    /**
     * HTML class which is the only class which can be used in ng-bind to inline HTML for security
     * reasons.
     *
     * @constructor
     * @param html raw (unsafe) html
     * @param {string=} option If set to 'usafe', get method will return raw (unsafe/unsanitized) html
     */
    function HTML(html, option) {
        this.html = html;
        this.get = lowercase(option) == 'unsafe'
            ? valueFn(html)
            : function htmlSanitize() {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf));
            return buf.join('');
        };
    }

    if (msie < 9) {
        nodeName_ = function(element) {
            element = element.nodeName ? element : element[0];
            return (element.scopeName && element.scopeName != 'HTML')
                ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;
        };
    } else {
        nodeName_ = function(element) {
            return element.nodeName ? element.nodeName : element[0].nodeName;
        };
    }

    function isVisible(element) {
        var rect = element[0].getBoundingClientRect(),
            width = (rect.width || (rect.right||0 - rect.left||0)),
            height = (rect.height || (rect.bottom||0 - rect.top||0));
        return width>0 && height>0;
    }

    function map(obj, iterator, context) {
        var results = [];
        forEach(obj, function(value, index, list) {
            results.push(iterator.call(context, value, index, list));
        });
        return results;
    }


    /**
     * @description
     * Determines the number of elements in an array, the number of properties an object has, or
     * the length of a string.
     *
     * Note: This function is used to augment the Object type in Angular expressions. See
     * {@link angular.Object} for more information about Angular arrays.
     *
     * @param {Object|Array|string} obj Object, array, or string to inspect.
     * @param {boolean} [ownPropsOnly=false] Count only "own" properties in an object
     * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.
     */
    function size(obj, ownPropsOnly) {
        var size = 0, key;

        if (isArray(obj) || isString(obj)) {
            return obj.length;
        } else if (isObject(obj)){
            for (key in obj)
                if (!ownPropsOnly || obj.hasOwnProperty(key))
                    size++;
        }

        return size;
    }


    function includes(array, obj) {
        return indexOf(array, obj) != -1;
    }

    function indexOf(array, obj) {
        if (array.indexOf) return array.indexOf(obj);

        for ( var i = 0; i < array.length; i++) {
            if (obj === array[i]) return i;
        }
        return -1;
    }

    function arrayRemove(array, value) {
        var index = indexOf(array, value);
        if (index >=0)
            array.splice(index, 1);
        return value;
    }

    function isLeafNode (node) {
        if (node) {
            switch (node.nodeName) {
                case "OPTION":
                case "PRE":
                case "TITLE":
                    return true;
            }
        }
        return false;
    }

    /**
     * @ngdoc function
     * @name angular.copy
     * @function
     *
     * @description
     * Creates a deep copy of `source`, which should be an object or an array.
     *
     * * If no destination is supplied, a copy of the object or array is created.
     * * If a destination is provided, all of its elements (for array) or properties (for objects)
     *   are deleted and then all elements/properties from the source are copied to it.
     * * If  `source` is not an object or array, `source` is returned.
     *
     * Note: this function is used to augment the Object type in Angular expressions. See
     * {@link angular.module.ng.$filter} for more information about Angular arrays.
     *
     * @param {*} source The source that will be used to make a copy.
     *                   Can be any type, including primitives, `null`, and `undefined`.
     * @param {(Object|Array)=} destination Destination into which the source is copied. If
     *     provided, must be of the same type as `source`.
     * @returns {*} The copy or updated `destination`, if `destination` was specified.
     */
    function copy(source, destination){
        if (isWindow(source) || isScope(source)) throw Error("Can't copy Window or Scope");
        if (!destination) {
            destination = source;
            if (source) {
                if (isArray(source)) {
                    destination = copy(source, []);
                } else if (isDate(source)) {
                    destination = new Date(source.getTime());
                } else if (isObject(source)) {
                    destination = copy(source, {});
                }
            }
        } else {
            if (source === destination) throw Error("Can't copy equivalent objects or arrays");
            if (isArray(source)) {
                while(destination.length) {
                    destination.pop();
                }
                for ( var i = 0; i < source.length; i++) {
                    destination.push(copy(source[i]));
                }
            } else {
                forEach(destination, function(value, key){
                    delete destination[key];
                });
                for ( var key in source) {
                    destination[key] = copy(source[key]);
                }
            }
        }
        return destination;
    }

    /**
     * Create a shallow copy of an object
     */
    function shallowCopy(src, dst) {
        dst = dst || {};

        for(var key in src) {
            if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {
                dst[key] = src[key];
            }
        }

        return dst;
    }


    /**
     * @ngdoc function
     * @name angular.equals
     * @function
     *
     * @description
     * Determines if two objects or two values are equivalent. Supports value types, arrays and
     * objects.
     *
     * Two objects or values are considered equivalent if at least one of the following is true:
     *
     * * Both objects or values pass `===` comparison.
     * * Both objects or values are of the same type and all of their properties pass `===` comparison.
     * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)
     *
     * During a property comparision, properties of `function` type and properties with names
     * that begin with `$` are ignored.
     *
     * Scope and DOMWindow objects are being compared only be identify (`===`).
     *
     * @param {*} o1 Object or value to compare.
     * @param {*} o2 Object or value to compare.
     * @returns {boolean} True if arguments are equal.
     */
    function equals(o1, o2) {
        if (o1 === o2) return true;
        if (o1 === null || o2 === null) return false;
        if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2) {
            if (t1 == 'object') {
                if (isArray(o1)) {
                    if ((length = o1.length) == o2.length) {
                        for(key=0; key<length; key++) {
                            if (!equals(o1[key], o2[key])) return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    return isDate(o2) && o1.getTime() == o2.getTime();
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2)) return false;
                    keySet = {};
                    for(key in o1) {
                        if (key.charAt(0) !== '$' && !isFunction(o1[key]) && !equals(o1[key], o2[key])) {
                            return false;
                        }
                        keySet[key] = true;
                    }
                    for(key in o2) {
                        if (!keySet[key] && key.charAt(0) !== '$' && !isFunction(o2[key])) return false;
                    }
                    return true;
                }
            }
        }
        return false;
    }

    function setHtml(node, html) {
        if (isLeafNode(node)) {
            if (msie) {
                node.innerText = html;
            } else {
                node.textContent = html;
            }
        } else {
            node.innerHTML = html;
        }
    }

    function concat(array1, array2, index) {
        return array1.concat(slice.call(array2, index));
    }

    function sliceArgs(args, startIndex) {
        return slice.call(args, startIndex || 0);
    }


    /**
     * @ngdoc function
     * @name angular.bind
     * @function
     *
     * @description
     * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for
     * `fn`). You can supply optional `args` that are are prebound to the function. This feature is also
     * known as [function currying](http://en.wikipedia.org/wiki/Currying).
     *
     * @param {Object} self Context which `fn` should be evaluated in.
     * @param {function()} fn Function to be bound.
     * @param {...*} args Optional arguments to be prebound to the `fn` function call.
     * @returns {function()} Function that wraps the `fn` with all the specified bindings.
     */
    function bind(self, fn) {
        var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
        if (isFunction(fn) && !(fn instanceof RegExp)) {
            return curryArgs.length
                ? function() {
                return arguments.length
                    ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))
                    : fn.apply(self, curryArgs);
            }
                : function() {
                return arguments.length
                    ? fn.apply(self, arguments)
                    : fn.call(self);
            };
        } else {
            // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)
            return fn;
        }
    }


    function toJsonReplacer(key, value) {
        var val = value;

        if (/^\$+/.test(key)) {
            val = undefined;
        } else if (isWindow(value)) {
            val = '$WINDOW';
        } else if (value &&  document === value) {
            val = '$DOCUMENT';
        } else if (isScope(value)) {
            val = '$SCOPE';
        }

        return val;
    };


    /**
     * @ngdoc function
     * @name angular.toJson
     * @function
     *
     * @description
     * Serializes input into a JSON-formatted string.
     *
     * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.
     * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.
     * @returns {string} Jsonified string representing `obj`.
     */
    function toJson(obj, pretty) {
        return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);
    }


    /**
     * @ngdoc function
     * @name angular.fromJson
     * @function
     *
     * @description
     * Deserializes a JSON string.
     *
     * @param {string} json JSON string to deserialize.
     * @returns {Object|Array|Date|string|number} Deserialized thingy.
     */
    function fromJson(json) {
        return isString(json)
            ? JSON.parse(json)
            : json;
    }


    function toBoolean(value) {
        if (value && value.length !== 0) {
            var v = lowercase("" + value);
            value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');
        } else {
            value = false;
        }
        return value;
    }

    /**
     * @returns {string} Returns the string representation of the element.
     */
    function startingTag(element) {
        element = jqLite(element).clone();
        try {
            // turns out IE does not let you set .html() on elements which
            // are not allowed to have children. So we just ignore it.
            element.html('');
        } catch(e) {};
        return jqLite('<div>').append(element).html().match(/^(<[^>]+>)/)[1];
    }


/////////////////////////////////////////////////

    /**
     * Parses an escaped url query string into key-value pairs.
     * @returns Object.<(string|boolean)>
     */
    function parseKeyValue(/**string*/keyValue) {
        var obj = {}, key_value, key;
        forEach((keyValue || "").split('&'), function(keyValue){
            if (keyValue) {
                key_value = keyValue.split('=');
                key = decodeURIComponent(key_value[0]);
                obj[key] = isDefined(key_value[1]) ? decodeURIComponent(key_value[1]) : true;
            }
        });
        return obj;
    }

    function toKeyValue(obj) {
        var parts = [];
        forEach(obj, function(value, key) {
            parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
        });
        return parts.length ? parts.join('&') : '';
    }


    /**
     * We need our custom mehtod because encodeURIComponent is too agressive and doesn't follow
     * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path
     * segments:
     *    segment       = *pchar
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriSegment(val) {
        return encodeUriQuery(val, true).
            replace(/%26/gi, '&').
            replace(/%3D/gi, '=').
            replace(/%2B/gi, '+');
    }


    /**
     * This method is intended for encoding *key* or *value* parts of query component. We need a custom
     * method becuase encodeURIComponent is too agressive and encodes stuff that doesn't have to be
     * encoded per http://tools.ietf.org/html/rfc3986:
     *    query       = *( pchar / "/" / "?" )
     *    pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
     *    unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
     *    pct-encoded   = "%" HEXDIG HEXDIG
     *    sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
     *                     / "*" / "+" / "," / ";" / "="
     */
    function encodeUriQuery(val, pctEncodeSpaces) {
        return encodeURIComponent(val).
            replace(/%40/gi, '@').
            replace(/%3A/gi, ':').
            replace(/%24/g, '$').
            replace(/%2C/gi, ',').
            replace((pctEncodeSpaces ? null : /%20/g), '+');
    }


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-app
     *
     * @element ANY
     * @param {angular.Module} ng-app on optional application
     *   {@link angular.module module} name to load.
     *
     * @description
     *
     * Use this directive to auto-bootstrap on application. Only
     * one directive can be used per HTML document. The directive
     * designates the root of the application and is typically placed
     * ot the root of the page.
     *
     * In the example below if the `ng-app` directive would not be placed
     * on the `html` element then the document would not be compiled
     * and the `{{ 1+2 }}` would not be resolved to `3`.
     *
     * `ng-app` is the easiest way to bootstrap an application.
     *
     <doc:example>
     <doc:source>
     I can add: 1 + 2 =  {{ 1+2 }}
     </doc:source>
     </doc:example>
     *
     */
    function angularInit(element, bootstrap) {
        var elements = [element],
            appElement,
            module,
            names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],
            NG_APP_CLASS_REGEXP = /\sng[:\-]app(:\s*([\w\d_]+);?)?\s/;

        function append(element) {
            element && elements.push(element);
        }

        forEach(names, function(name) {
            names[name] = true;
            append(document.getElementById(name));
            name = name.replace(':', '\\:');
            if (element.querySelectorAll) {
                forEach(element.querySelectorAll('.' + name), append);
                forEach(element.querySelectorAll('.' + name + '\\:'), append);
                forEach(element.querySelectorAll('[' + name + ']'), append);
            };
        });

        forEach(elements, function(element) {
            if (!appElement) {
                var className = ' ' + element.className + ' ';
                var match = NG_APP_CLASS_REGEXP.exec(className);
                if (match) {
                    appElement = element;
                    module = (match[2] || '').replace(/\s+/g, ',');
                } else {
                    forEach(element.attributes, function(attr) {
                        if (!appElement && names[attr.name]) {
                            appElement = element;
                            module = attr.value;
                        }
                    });
                }
            }
        });
        if (appElement) {
            bootstrap(appElement, module ? [module] : []);
        }
    }

    /**
     * @ngdoc function
     * @name angular.bootstrap
     * @description
     * Use this function to manually start up angular application.
     *
     * See: {@link guide/dev_guide.bootstrap.manual_bootstrap Bootstrap}
     *
     * @param {Element} element DOM element which is the root of angular application.
     * @param {Array<String,function>=} modules an array of module declarations. See: {@link angular.module modules}
     * @param {angular.module.auta.$injector} the injector;
     */
    function bootstrap(element, modules) {
        element = jqLite(element);
        modules = modules || [];
        modules.unshift('ng');
        var injector = createInjector(modules);
        injector.invoke(
            ['$rootScope', '$compile', '$injector', function(scope, compile, injector){
                scope.$apply(function() {
                    element.data('$injector', injector);
                    compile(element)(scope);
                });
            }]
        );
        return injector;
    }

    var SNAKE_CASE_REGEXP = /[A-Z]/g;
    function snake_case(name, separator){
        separator = separator || '_';
        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
            return (pos ? separator : '') + letter.toLowerCase();
        });
    }

    function bindJQuery() {
        // bind to jQuery if present;
        jQuery = window.jQuery;
        // reset to jQuery or default to us.
        if (jQuery) {
            jqLite = jQuery;
            extend(jQuery.fn, {
                scope: JQLitePrototype.scope,
                controller: JQLitePrototype.controller,
                injector: JQLitePrototype.injector,
                inheritedData: JQLitePrototype.inheritedData
            });
            JQLitePatchJQueryRemove('remove', true);
            JQLitePatchJQueryRemove('empty');
            JQLitePatchJQueryRemove('html');
        } else {
            jqLite = JQLite;
        }
        angular.element = jqLite;
    }

    /**
     * throw error of the argument is falsy.
     */
    function assertArg(arg, name, reason) {
        if (!arg) {
            var error = new Error("Argument '" + (name||'?') + "' is " +
                (reason || "required"));
            throw error;
        }
        return arg;
    }

    function assertArgFn(arg, name, acceptArrayAnnotation) {
        if (acceptArrayAnnotation && isArray(arg)) {
            arg = arg[arg.length - 1];
        }

        assertArg(isFunction(arg), name, 'not a function, got ' +
            (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));
        return arg;
    }

    /**
     * @ngdoc interface
     * @name angular.Module
     * @description
     *
     * Interface for configuring angular {@link angular.module modules}.
     */

    function setupModuleLoader(window) {

        function ensure(obj, name, factory) {
            return obj[name] || (obj[name] = factory());
        }

        return ensure(ensure(window, 'angular', Object), 'module', function() {
            /** @type {Object.<string, angular.Module>} */
            var modules = {};

            /**
             * @ngdoc function
             * @name angular.module
             * @description
             *
             * The `angular.module` is a global place for creating and registering Angular modules. All
             * modules (angular core or 3rd party) that should be available to an application must be
             * registered using this mechanism.
             *
             *
             * # Module
             *
             * A module is a collocation of services, directives, filters, and configure information. Module
             * is used to configure the {@link angular.module.AUTO.$injector $injector}.
             *
             * <pre>
             * // Create a new module
             * var myModule = angular.module('myModule', []);
             *
             * // register a new service
             * myModule.value('appName', 'MyCoolApp');
             *
             * // configure existing services inside initialization blocks.
             * myModule.config(function($locationProvider) {
             *   // Configure existing providers
             *   $locationProvider.hashPrefix('!');
             * });
             * </pre>
             *
             * Then you can create an injector and load your modules like this:
             *
             * <pre>
             * var injector = angular.injector(['ng', 'MyModule'])
             * </pre>
             *
             * However it's more likely that you'll just use
             * {@link angular.module.ng.$compileProvider.directive.ng-app ng-app} or
             * {@link angular.bootstrap} to simplify this process for you.
             *
             * @param {!string} name The name of the module to create or retrieve.
             * @param {Array.<string>=} requires If specified then new module is being created. If unspecified then the
             *        the module is being retrieved for further configuration.
             * @param {Function} configFn Option configuration function for the module. Same as
             *        {@link angular.Module#config Module#config()}.
             * @returns {module} new module with the {@link angular.Module} api.
             */
            return function module(name, requires, configFn) {
                if (requires && modules.hasOwnProperty(name)) {
                    modules[name] = null;
                }
                return ensure(modules, name, function() {
                    if (!requires) {
                        throw Error('No module: ' + name);
                    }

                    /** @type {!Array.<Array.<*>>} */
                    var invokeQueue = [];

                    /** @type {!Array.<Function>} */
                    var runBlocks = [];

                    var config = invokeLater('$injector', 'invoke');

                    /** @type {angular.Module} */
                    var moduleInstance = {
                        // Private state
                        _invokeQueue: invokeQueue,
                        _runBlocks: runBlocks,

                        /**
                         * @ngdoc property
                         * @name angular.Module#requires
                         * @propertyOf angular.Module
                         * @returns {Array.<string>} List of module names which must be loaded before this module.
                         * @description
                         * Holds the list of modules which the injector will load before the current module is loaded.
                         */
                        requires: requires,

                        /**
                         * @ngdoc property
                         * @name angular.Module#name
                         * @propertyOf angular.Module
                         * @returns {string} Name of the module.
                         * @description
                         */
                        name: name,


                        /**
                         * @ngdoc method
                         * @name angular.Module#provider
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {Function} providerType Construction function for creating new instance of the service.
                         * @description
                         * See {@link angular.module.AUTO.$provide#provider $provide.provider()}.
                         */
                        provider: invokeLater('$provide', 'provider'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#factory
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {Function} providerFunction Function for creating new instance of the service.
                         * @description
                         * See {@link angular.module.AUTO.$provide#factory $provide.factory()}.
                         */
                        factory: invokeLater('$provide', 'factory'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#service
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {Function} constructor A constructor function that will be instantiated.
                         * @description
                         * See {@link angular.module.AUTO.$provide#service $provide.service()}.
                         */
                        service: invokeLater('$provide', 'service'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#value
                         * @methodOf angular.Module
                         * @param {string} name service name
                         * @param {*} object Service instance object.
                         * @description
                         * See {@link angular.module.AUTO.$provide#value $provide.value()}.
                         */
                        value: invokeLater('$provide', 'value'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#constant
                         * @methodOf angular.Module
                         * @param {string} name constant name
                         * @param {*} object Constant value.
                         * @description
                         * Because the constant are fixed, they get applied before other provide methods.
                         * See {@link angular.module.AUTO.$provide#constant $provide.constant()}.
                         */
                        constant: invokeLater('$provide', 'constant', 'unshift'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#filter
                         * @methodOf angular.Module
                         * @param {string} name Filter name.
                         * @param {Function} filterFactory Factory function for creating new instance of filter.
                         * @description
                         * See {@link angular.module.ng.$filterProvider#register $filterProvider.register()}.
                         */
                        filter: invokeLater('$filterProvider', 'register'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#controller
                         * @methodOf angular.Module
                         * @param {string} name Controller name.
                         * @param {Function} constructor Controller constructor function.
                         * @description
                         * See {@link angular.module.ng.$controllerProvider#register $controllerProvider.register()}.
                         */
                        controller: invokeLater('$controllerProvider', 'register'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#directive
                         * @methodOf angular.Module
                         * @param {string} name directive name
                         * @param {Function} directiveFactory Factory function for creating new instance of
                         * directives.
                         * @description
                         * See {@link angular.module.ng.$compileProvider.directive $compileProvider.directive()}.
                         */
                        directive: invokeLater('$compileProvider', 'directive'),

                        /**
                         * @ngdoc method
                         * @name angular.Module#config
                         * @methodOf angular.Module
                         * @param {Function} configFn Execute this function on module load. Useful for service
                         *    configuration.
                         * @description
                         * Use this method to register work which needs to be performed on module loading.
                         */
                        config: config,

                        /**
                         * @ngdoc method
                         * @name angular.Module#run
                         * @methodOf angular.Module
                         * @param {Function} initializationFn Execute this function after injector creation.
                         *    Useful for application initialization.
                         * @description
                         * Use this method to register work which needs to be performed when the injector with
                         * with the current module is finished loading.
                         */
                        run: function(block) {
                            runBlocks.push(block);
                            return this;
                        }
                    };

                    if (configFn) {
                        config(configFn);
                    }

                    return  moduleInstance;

                    /**
                     * @param {string} provider
                     * @param {string} method
                     * @param {String=} insertMethod
                     * @returns {angular.Module}
                     */
                    function invokeLater(provider, method, insertMethod) {
                        return function() {
                            invokeQueue[insertMethod || 'push']([provider, method, arguments]);
                            return moduleInstance;
                        }
                    }
                });
            };
        });

    }

    /**
     * @ngdoc property
     * @name angular.version
     * @description
     * An object that contains information about the current AngularJS version. This object has the
     * following properties:
     *
     * - `full` – `{string}` – Full version string, such as "0.9.18".
     * - `major` – `{number}` – Major version number, such as "0".
     * - `minor` – `{number}` – Minor version number, such as "9".
     * - `dot` – `{number}` – Dot version number, such as "18".
     * - `codeName` – `{string}` – Code name of the release, such as "jiggling-armfat".
     */
    var version = {
        full: '1.0.0rc3',    // all of these placeholder strings will be replaced by rake's
        major: 1,    // compile task
        minor: 0,
        dot: 0,
        codeName: 'barefoot-telepathy'
    };


    function publishExternalAPI(angular){
        extend(angular, {
            'bootstrap': bootstrap,
            'copy': copy,
            'extend': extend,
            'equals': equals,
            'element': jqLite,
            'forEach': forEach,
            'injector': createInjector,
            'noop':noop,
            'bind':bind,
            'toJson': toJson,
            'fromJson': fromJson,
            'identity':identity,
            'isUndefined': isUndefined,
            'isDefined': isDefined,
            'isString': isString,
            'isFunction': isFunction,
            'isObject': isObject,
            'isNumber': isNumber,
            'isElement': isElement,
            'isArray': isArray,
            'version': version,
            'isDate': isDate,
            'lowercase': lowercase,
            'uppercase': uppercase,
            'callbacks': {counter: 0}
        });

        angularModule = setupModuleLoader(window);
        try {
            angularModule('ngLocale');
        } catch (e) {
            angularModule('ngLocale', []).provider('$locale', $LocaleProvider);
        }

        angularModule('ng', ['ngLocale'], ['$provide',
            function ngModule($provide) {
                $provide.provider('$compile', $CompileProvider).
                    directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        style: styleDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindHtmlUnsafe: ngBindHtmlUnsafeDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngSubmit: ngSubmitDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngView: ngViewDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        ngModelInstant: ngModelInstantDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        ngValue: ngValueDirective
                    }).
                    directive(ngAttributeAliasDirectives).
                    directive(ngEventDirectives);
                $provide.provider({
                    $anchorScroll: $AnchorScrollProvider,
                    $browser: $BrowserProvider,
                    $cacheFactory: $CacheFactoryProvider,
                    $controller: $ControllerProvider,
                    $defer: $DeferProvider,
                    $document: $DocumentProvider,
                    $exceptionHandler: $ExceptionHandlerProvider,
                    $filter: $FilterProvider,
                    $interpolate: $InterpolateProvider,
                    $http: $HttpProvider,
                    $httpBackend: $HttpBackendProvider,
                    $location: $LocationProvider,
                    $log: $LogProvider,
                    $parse: $ParseProvider,
                    $route: $RouteProvider,
                    $routeParams: $RouteParamsProvider,
                    $rootScope: $RootScopeProvider,
                    $q: $QProvider,
                    $sanitize: $SanitizeProvider,
                    $sniffer: $SnifferProvider,
                    $templateCache: $TemplateCacheProvider,
                    $window: $WindowProvider
                });
            }
        ]);
    };

//////////////////////////////////
//JQLite
//////////////////////////////////

    /**
     * @ngdoc function
     * @name angular.element
     * @function
     *
     * @description
     * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.
     * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if
     * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite
     * implementation (commonly referred to as jqLite).
     *
     * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`
     * event fired.
     *
     * jqLite is a tiny, API-compatible subset of jQuery that allows
     * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality
     * within a very small footprint, so only a subset of the jQuery API - methods, arguments and
     * invocation styles - are supported.
     *
     * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never
     * raw DOM references.
     *
     * ## Angular's jQuery lite provides the following methods:
     *
     * - [addClass()](http://api.jquery.com/addClass/)
     * - [after()](http://api.jquery.com/after/)
     * - [append()](http://api.jquery.com/append/)
     * - [attr()](http://api.jquery.com/attr/)
     * - [bind()](http://api.jquery.com/bind/)
     * - [children()](http://api.jquery.com/children/)
     * - [clone()](http://api.jquery.com/clone/)
     * - [contents()](http://api.jquery.com/contents/)
     * - [css()](http://api.jquery.com/css/)
     * - [data()](http://api.jquery.com/data/)
     * - [eq()](http://api.jquery.com/eq/)
     * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name.
     * - [hasClass()](http://api.jquery.com/hasClass/)
     * - [html()](http://api.jquery.com/html/)
     * - [next()](http://api.jquery.com/next/)
     * - [parent()](http://api.jquery.com/parent/)
     * - [prepend()](http://api.jquery.com/prepend/)
     * - [prop()](http://api.jquery.com/prop/)
     * - [ready()](http://api.jquery.com/ready/)
     * - [remove()](http://api.jquery.com/remove/)
     * - [removeAttr()](http://api.jquery.com/removeAttr/)
     * - [removeClass()](http://api.jquery.com/removeClass/)
     * - [removeData()](http://api.jquery.com/removeData/)
     * - [replaceWith()](http://api.jquery.com/replaceWith/)
     * - [text()](http://api.jquery.com/text/)
     * - [toggleClass()](http://api.jquery.com/toggleClass/)
     * - [unbind()](http://api.jquery.com/unbind/)
     * - [val()](http://api.jquery.com/val/)
     * - [wrap()](http://api.jquery.com/wrap/)
     *
     * ## In addtion to the above, Angular privides an additional method to both jQuery and jQuery lite:
     *
     * - `controller(name)` - retrieves the controller of the current element or its parent. By default
     *   retrieves controller associated with the `ng-controller` directive. If `name` is provided as
     *   camelCase directive name, then the controller for this directive will be retrieved (e.g.
     *   `'ngModel'`).
     * - `injector()` - retrieves the injector of the current element or its parent.
     * - `scope()` - retrieves the {@link api/angular.module.ng.$rootScope.Scope scope} of the current
     *   element or its parent.
     * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top
     *   parent element is reached.
     *
     * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.
     * @returns {Object} jQuery object.
     */

    var jqCache = {},
        jqName = 'ng-' + new Date().getTime(),
        jqId = 1,
        addEventListenerFn = (window.document.addEventListener
            ? function(element, type, fn) {element.addEventListener(type, fn, false);}
            : function(element, type, fn) {element.attachEvent('on' + type, fn);}),
        removeEventListenerFn = (window.document.removeEventListener
            ? function(element, type, fn) {element.removeEventListener(type, fn, false); }
            : function(element, type, fn) {element.detachEvent('on' + type, fn); });

    function jqNextId() { return (jqId++); }


    function getStyle(element) {
        var current = {}, style = element[0].style, value, name, i;
        if (typeof style.length == 'number') {
            for(i = 0; i < style.length; i++) {
                name = style[i];
                current[name] = style[name];
            }
        } else {
            for (name in style) {
                value = style[name];
                if (1*name != name && name != 'cssText' && value && typeof value == 'string' && value !='false')
                    current[name] = value;
            }
        }
        return current;
    }


    var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
    var MOZ_HACK_REGEXP = /^moz([A-Z])/;

    /**
     * Converts snake_case to camelCase.
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
    function camelCase(name) {
        return name.
            replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
            return offset ? letter.toUpperCase() : letter;
        }).
            replace(MOZ_HACK_REGEXP, 'Moz$1');
    }

/////////////////////////////////////////////
// jQuery mutation patch
//
//  In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a
// $destroy event on all DOM nodes being removed.
//
/////////////////////////////////////////////

    function JQLitePatchJQueryRemove(name, dispatchThis) {
        var originalJqFn = jQuery.fn[name];
        originalJqFn = originalJqFn.$original || originalJqFn;
        removePatch.$original = originalJqFn;
        jQuery.fn[name] = removePatch;

        function removePatch() {
            var list = [this],
                fireEvent = dispatchThis,
                set, setIndex, setLength,
                element, childIndex, childLength, children,
                fns, data;

            while(list.length) {
                set = list.shift();
                for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {
                    element = jqLite(set[setIndex]);
                    if (fireEvent) {
                        data = element.data('events');
                        if ( (fns = data && data.$destroy) ) {
                            forEach(fns, function(fn){
                                fn.handler();
                            });
                        }
                    } else {
                        fireEvent = !fireEvent;
                    }
                    for(childIndex = 0, childLength = (children = element.children()).length;
                        childIndex < childLength;
                        childIndex++) {
                        list.push(jQuery(children[childIndex]));
                    }
                }
            }
            return originalJqFn.apply(this, arguments);
        }
    }

/////////////////////////////////////////////
    function JQLite(element) {
        if (element instanceof JQLite) {
            return element;
        }
        if (!(this instanceof JQLite)) {
            if (isString(element) && element.charAt(0) != '<') {
                throw Error('selectors not implemented');
            }
            return new JQLite(element);
        }

        if (isString(element)) {
            var div = document.createElement('div');
            // Read about the NoScope elements here:
            // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx
            div.innerHTML = '<div>&nbsp;</div>' + element; // IE insanity to make NoScope elements work!
            div.removeChild(div.firstChild); // remove the superfluous div
            JQLiteAddNodes(this, div.childNodes);
            this.remove(); // detach the elements from the temporary DOM div.
        } else {
            JQLiteAddNodes(this, element);
        }
    }

    function JQLiteClone(element) {
        return element.cloneNode(true);
    }

    function JQLiteDealoc(element){
        JQLiteRemoveData(element);
        for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {
            JQLiteDealoc(children[i]);
        }
    }

    function JQLiteRemoveData(element) {
        var cacheId = element[jqName],
            cache = jqCache[cacheId];
        if (cache) {
            if (cache.bind) {
                forEach(cache.bind, function(fn, type){
                    if (type == '$destroy') {
                        fn({});
                    } else {
                        removeEventListenerFn(element, type, fn);
                    }
                });
            }
            delete jqCache[cacheId];
            element[jqName] = undefined; // ie does not allow deletion of attributes on elements.
        }
    }

    function JQLiteData(element, key, value) {
        var cacheId = element[jqName],
            cache = jqCache[cacheId || -1];
        if (isDefined(value)) {
            if (!cache) {
                element[jqName] = cacheId = jqNextId();
                cache = jqCache[cacheId] = {};
            }
            cache[key] = value;
        } else {
            return cache ? cache[key] : null;
        }
    }

    function JQLiteHasClass(element, selector) {
        return ((" " + element.className + " ").replace(/[\n\t]/g, " ").
            indexOf( " " + selector + " " ) > -1);
    }

    function JQLiteRemoveClass(element, selector) {
        if (selector) {
            forEach(selector.split(' '), function(cssClass) {
                element.className = trim(
                    (" " + element.className + " ")
                        .replace(/[\n\t]/g, " ")
                        .replace(" " + trim(cssClass) + " ", " ")
                );
            });
        }
    }

    function JQLiteAddClass(element, selector) {
        if (selector) {
            forEach(selector.split(' '), function(cssClass) {
                if (!JQLiteHasClass(element, cssClass)) {
                    element.className = trim(element.className + ' ' + trim(cssClass));
                }
            });
        }
    }

    function JQLiteAddNodes(root, elements) {
        if (elements) {
            elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))
                ? elements
                : [ elements ];
            for(var i=0; i < elements.length; i++) {
                root.push(elements[i]);
            }
        }
    }

    function JQLiteController(element, name) {
        return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');
    }

    function JQLiteInheritedData(element, name, value) {
        element = jqLite(element);

        // if element is the document object work with the html element instead
        // this makes $(document).scope() possible
        if(element[0].nodeType == 9) {
            element = element.find('html');
        }

        while (element.length) {
            if (value = element.data(name)) return value;
            element = element.parent();
        }
    }

//////////////////////////////////////////
// Functions which are declared directly.
//////////////////////////////////////////
    var JQLitePrototype = JQLite.prototype = {
        ready: function(fn) {
            var fired = false;

            function trigger() {
                if (fired) return;
                fired = true;
                fn();
            }

            this.bind('DOMContentLoaded', trigger); // works for modern browsers and IE9
            // we can not use jqLite since we are not done loading and jQuery could be loaded later.
            JQLite(window).bind('load', trigger); // fallback to window.onload for others
        },
        toString: function() {
            var value = [];
            forEach(this, function(e){ value.push('' + e);});
            return '[' + value.join(', ') + ']';
        },

        eq: function(index) {
            return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);
        },

        length: 0,
        push: push,
        sort: [].sort,
        splice: [].splice
    };

//////////////////////////////////////////
// Functions iterating getter/setters.
// these functions return self on setter and
// value on get.
//////////////////////////////////////////
    var BOOLEAN_ATTR = {};
    forEach('multiple,selected,checked,disabled,readOnly,required'.split(','), function(value) {
        BOOLEAN_ATTR[lowercase(value)] = value;
    });
    var BOOLEAN_ELEMENTS = {};
    forEach('input,select,option,textarea,button,form'.split(','), function(value) {
        BOOLEAN_ELEMENTS[uppercase(value)] = true;
    });

    function isBooleanAttr(element, name) {
        return BOOLEAN_ELEMENTS[element.nodeName] && BOOLEAN_ATTR[name.toLowerCase()];
    }

    forEach({
        data: JQLiteData,
        inheritedData: JQLiteInheritedData,

        scope: function(element) {
            return JQLiteInheritedData(element, '$scope');
        },

        controller: JQLiteController ,

        injector: function(element) {
            return JQLiteInheritedData(element, '$injector');
        },

        removeAttr: function(element,name) {
            element.removeAttribute(name);
        },

        hasClass: JQLiteHasClass,

        css: function(element, name, value) {
            name = camelCase(name);

            if (isDefined(value)) {
                element.style[name] = value;
            } else {
                var val;

                if (msie <= 8) {
                    // this is some IE specific weirdness that jQuery 1.6.4 does not sure why
                    val = element.currentStyle && element.currentStyle[name];
                    if (val === '') val = 'auto';
                }

                val = val || element.style[name];

                if (msie <= 8) {
                    // jquery weirdness :-/
                    val = (val === '') ? undefined : val;
                }

                return  val;
            }
        },

        attr: function(element, name, value){
            var lowercasedName = lowercase(name);
            if (BOOLEAN_ATTR[lowercasedName]) {
                if (isDefined(value)) {
                    if (!!value) {
                        element[name] = true;
                        element.setAttribute(name, lowercasedName);
                    } else {
                        element[name] = false;
                        element.removeAttribute(lowercasedName);
                    }
                } else {
                    return (element[name] ||
                        (element.attributes.getNamedItem(name)|| noop).specified)
                        ? lowercasedName
                        : undefined;
                }
            } else if (isDefined(value)) {
                element.setAttribute(name, value);
            } else if (element.getAttribute) {
                // the extra argument "2" is to get the right thing for a.href in IE, see jQuery code
                // some elements (e.g. Document) don't have get attribute, so return undefined
                var ret = element.getAttribute(name, 2);
                // normalize non-existing attributes to undefined (as jQuery)
                return ret === null ? undefined : ret;
            }
        },

        prop: function(element, name, value) {
            if (isDefined(value)) {
                element[name] = value;
            } else {
                return element[name];
            }
        },

        text: extend((msie < 9)
            ? function(element, value) {
            if (element.nodeType == 1 /** Element */) {
                if (isUndefined(value))
                    return element.innerText;
                element.innerText = value;
            } else {
                if (isUndefined(value))
                    return element.nodeValue;
                element.nodeValue = value;
            }
        }
            : function(element, value) {
            if (isUndefined(value)) {
                return element.textContent;
            }
            element.textContent = value;
        }, {$dv:''}),

        val: function(element, value) {
            if (isUndefined(value)) {
                return element.value;
            }
            element.value = value;
        },

        html: function(element, value) {
            if (isUndefined(value)) {
                return element.innerHTML;
            }
            for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {
                JQLiteDealoc(childNodes[i]);
            }
            element.innerHTML = value;
        }
    }, function(fn, name){
        /**
         * Properties: writes return selection, reads return first value
         */
        JQLite.prototype[name] = function(arg1, arg2) {
            var i, key;

            // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it
            // in a way that survives minification.
            if (((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController)) ? arg1 : arg2) === undefined) {
                if (isObject(arg1)) {
                    // we are a write, but the object properties are the key/values
                    for(i=0; i < this.length; i++) {
                        for (key in arg1) {
                            fn(this[i], key, arg1[key]);
                        }
                    }
                    // return self for chaining
                    return this;
                } else {
                    // we are a read, so read the first child.
                    if (this.length)
                        return fn(this[0], arg1, arg2);
                }
            } else {
                // we are a write, so apply to all children
                for(i=0; i < this.length; i++) {
                    fn(this[i], arg1, arg2);
                }
                // return self for chaining
                return this;
            }
            return fn.$dv;
        };
    });

    function createEventHandler(element) {
        var eventHandler = function (event) {
            if (!event.preventDefault) {
                event.preventDefault = function() {
                    event.returnValue = false; //ie
                };
            }

            if (!event.stopPropagation) {
                event.stopPropagation = function() {
                    event.cancelBubble = true; //ie
                };
            }

            if (!event.target) {
                event.target = event.srcElement || document;
            }

            if (isUndefined(event.defaultPrevented)) {
                var prevent = event.preventDefault;
                event.preventDefault = function() {
                    event.defaultPrevented = true;
                    prevent.call(event);
                };
                event.defaultPrevented = false;
            }

            event.isDefaultPrevented = function() {
                return event.defaultPrevented;
            };

            forEach(eventHandler.fns, function(fn){
                fn.call(element, event);
            });

            // Remove monkey-patched methods (IE),
            // as they would cause memory leaks in IE8.
            if (msie < 8) {
                // IE7 does not allow to delete property on native object
                event.preventDefault = null;
                event.stopPropagation = null;
                event.isDefaultPrevented = null;
            } else {
                // It shouldn't affect normal browsers (native methods are defined on prototype).
                delete event.preventDefault;
                delete event.stopPropagation;
                delete event.isDefaultPrevented;
            }
        };
        eventHandler.fns = [];
        return eventHandler;
    };

//////////////////////////////////////////
// Functions iterating traversal.
// These functions chain results into a single
// selector.
//////////////////////////////////////////
    forEach({
        removeData: JQLiteRemoveData,

        dealoc: JQLiteDealoc,

        bind: function bindFn(element, type, fn){
            var bind = JQLiteData(element, 'bind');


            if (!bind) JQLiteData(element, 'bind', bind = {});
            forEach(type.split(' '), function(type){
                var eventHandler = bind[type];


                if (!eventHandler) {
                    if (type == 'mouseenter' || type == 'mouseleave') {
                        var mouseenter = bind.mouseenter = createEventHandler(element);
                        var mouseleave = bind.mouseleave = createEventHandler(element);
                        var counter = 0;


                        bindFn(element, 'mouseover', function(event) {
                            counter++;
                            if (counter == 1) {
                                event.type = 'mouseenter';
                                mouseenter(event);
                            }
                        });
                        bindFn(element, 'mouseout', function(event) {
                            counter --;
                            if (counter == 0) {
                                event.type = 'mouseleave';
                                mouseleave(event);
                            }
                        });
                        eventHandler = bind[type];
                    } else {
                        eventHandler = bind[type] = createEventHandler(element);
                        addEventListenerFn(element, type, eventHandler);
                    }
                }
                eventHandler.fns.push(fn);
            });
        },

        unbind: function(element, type, fn) {
            var bind = JQLiteData(element, 'bind');
            if (!bind) return; //no listeners registered

            if (isUndefined(type)) {
                forEach(bind, function(eventHandler, type) {
                    removeEventListenerFn(element, type, eventHandler);
                    delete bind[type];
                });
            } else {
                if (isUndefined(fn)) {
                    removeEventListenerFn(element, type, bind[type]);
                    delete bind[type];
                } else {
                    arrayRemove(bind[type].fns, fn);
                }
            }
        },

        replaceWith: function(element, replaceNode) {
            var index, parent = element.parentNode;
            JQLiteDealoc(element);
            forEach(new JQLite(replaceNode), function(node){
                if (index) {
                    parent.insertBefore(node, index.nextSibling);
                } else {
                    parent.replaceChild(node, element);
                }
                index = node;
            });
        },

        children: function(element) {
            var children = [];
            forEach(element.childNodes, function(element){
                if (element.nodeName != '#text')
                    children.push(element);
            });
            return children;
        },

        contents: function(element) {
            return element.childNodes;
        },

        append: function(element, node) {
            forEach(new JQLite(node), function(child){
                if (element.nodeType === 1)
                    element.appendChild(child);
            });
        },

        prepend: function(element, node) {
            if (element.nodeType === 1) {
                var index = element.firstChild;
                forEach(new JQLite(node), function(child){
                    if (index) {
                        element.insertBefore(child, index);
                    } else {
                        element.appendChild(child);
                        index = child;
                    }
                });
            }
        },

        wrap: function(element, wrapNode) {
            wrapNode = jqLite(wrapNode)[0];
            var parent = element.parentNode;
            if (parent) {
                parent.replaceChild(wrapNode, element);
            }
            wrapNode.appendChild(element);
        },

        remove: function(element) {
            JQLiteDealoc(element);
            var parent = element.parentNode;
            if (parent) parent.removeChild(element);
        },

        after: function(element, newElement) {
            var index = element, parent = element.parentNode;
            forEach(new JQLite(newElement), function(node){
                parent.insertBefore(node, index.nextSibling);
                index = node;
            });
        },

        addClass: JQLiteAddClass,
        removeClass: JQLiteRemoveClass,

        toggleClass: function(element, selector, condition) {
            if (isUndefined(condition)) {
                condition = !JQLiteHasClass(element, selector);
            }
            (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);
        },

        parent: function(element) {
            var parent = element.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },

        next: function(element) {
            return element.nextSibling;
        },

        find: function(element, selector) {
            return element.getElementsByTagName(selector);
        },

        clone: JQLiteClone
    }, function(fn, name){
        /**
         * chaining functions
         */
        JQLite.prototype[name] = function(arg1, arg2) {
            var value;
            for(var i=0; i < this.length; i++) {
                if (value == undefined) {
                    value = fn(this[i], arg1, arg2);
                    if (value !== undefined) {
                        // any function which returns a value needs to be wrapped
                        value = jqLite(value);
                    }
                } else {
                    JQLiteAddNodes(value, fn(this[i], arg1, arg2));
                }
            }
            return value == undefined ? this : value;
        };
    });

    /**
     * Computes a hash of an 'obj'.
     * Hash of a:
     *  string is string
     *  number is number as string
     *  object is either result of calling $$hashKey function on the object or uniquely generated id,
     *         that is also assigned to the $$hashKey property of the object.
     *
     * @param obj
     * @returns {string} hash string such that the same input will have the same hash string.
     *         The resulting string key is in 'type:hashKey' format.
     */
    function hashKey(obj) {
        var objType = typeof obj,
            key;

        if (objType == 'object' && obj !== null) {
            if (typeof (key = obj.$$hashKey) == 'function') {
                // must invoke on object to keep the right this
                key = obj.$$hashKey();
            } else if (key === undefined) {
                key = obj.$$hashKey = nextUid();
            }
        } else {
            key = obj;
        }

        return objType + ':' + key;
    }

    /**
     * HashMap which can use objects as keys
     */
    function HashMap(array){
        forEach(array, this.put, this);
    }
    HashMap.prototype = {
        /**
         * Store key value pair
         * @param key key to store can be any type
         * @param value value to store can be any type
         */
        put: function(key, value) {
            this[hashKey(key)] = value;
        },

        /**
         * @param key
         * @returns the value for the key
         */
        get: function(key) {
            return this[hashKey(key)];
        },

        /**
         * Remove the key/value pair
         * @param key
         */
        remove: function(key) {
            var value = this[key = hashKey(key)];
            delete this[key];
            return value;
        }
    };

    /**
     * A map where multiple values can be added to the same key such that they form a queue.
     * @returns {HashQueueMap}
     */
    function HashQueueMap() {}
    HashQueueMap.prototype = {
        /**
         * Same as array push, but using an array as the value for the hash
         */
        push: function(key, value) {
            var array = this[key = hashKey(key)];
            if (!array) {
                this[key] = [value];
            } else {
                array.push(value);
            }
        },

        /**
         * Same as array shift, but using an array as the value for the hash
         */
        shift: function(key) {
            var array = this[key = hashKey(key)];
            if (array) {
                if (array.length == 1) {
                    delete this[key];
                    return array[0];
                } else {
                    return array.shift();
                }
            }
        }
    };

    /**
     * @ngdoc function
     * @name angular.injector
     * @function
     *
     * @description
     * Creates an injector function that can be used for retrieving services as well as for
     * dependency injection (see {@link guide/dev_guide.di dependency injection}).
     *

     * @param {Array.<string|Function>} modules A list of module functions or their aliases. See
     *        {@link angular.module}. The `ng` module must be explicitly added.
     * @returns {function()} Injector function. See {@link angular.module.AUTO.$injector $injector}.
     *
     * @example
     * Typical usage
     * <pre>
     *   // create an injector
     *   var $injector = angular.injector(['ng']);
     *
     *   // use the injector to kick of your application
     *   // use the type inference to auto inject arguments, or use implicit injection
     *   $injector.invoke(function($rootScope, $compile, $document){
     *     $compile($document)($rootScope);
     *     $rootScope.$digest();
     *   });
     * </pre>
     */


    /**
     * @ngdoc overview
     * @name angular.module.AUTO
     * @description
     *
     * Implicit module which gets automatically added to each {@link angular.module.AUTO.$injector $injector}.
     */

    var FN_ARGS = /^function\s*[^\(]*\(\s*([^\)]*)\)/m;
    var FN_ARG_SPLIT = /,/;
    var FN_ARG = /^\s*(_?)(.+?)\1\s*$/;
    var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    function inferInjectionArgs(fn) {
        assertArgFn(fn);
        if (!fn.$inject) {
            var args = fn.$inject = [];
            var fnText = fn.toString().replace(STRIP_COMMENTS, '');
            var argDecl = fnText.match(FN_ARGS);
            forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){
                arg.replace(FN_ARG, function(all, underscore, name){
                    args.push(name);
                });
            });
        }
        return fn.$inject;
    }

///////////////////////////////////////

    /**
     * @ngdoc object
     * @name angular.module.AUTO.$injector
     * @function
     *
     * @description
     *
     * `$injector` is used to retrieve object instances as defined by
     * {@link angular.module.AUTO.$provide provider}, instantiate types, invoke methods,
     * and load modules.
     *
     * The following always holds true:
     *
     * <pre>
     *   var $injector = angular.injector();
     *   expect($injector.get('$injector')).toBe($injector);
     *   expect($injector.invoke(function($injector){
     *     return $injector;
     *   }).toBe($injector);
     * </pre>
     *
     * # Injection Function Annotation
     *
     * JavaScript does not have annotations, and annotations are needed for dependency injection. The
     * following ways are all valid way of annotating function with injection arguments and are equivalent.
     *
     * <pre>
     *   // inferred (only works if code not minified/obfuscated)
     *   $inject.invoke(function(serviceA){});
     *
     *   // annotated
     *   function explicit(serviceA) {};
     *   explicit.$inject = ['serviceA'];
     *   $inject.invoke(explicit);
     *
     *   // inline
     *   $inject.invoke(['serviceA', function(serviceA){}]);
     * </pre>
     *
     * ## Inference
     *
     * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be
     * parsed and the function arguments can be extracted. *NOTE:* This does not work with minfication, and obfuscation
     * tools since these tools change the argument names.
     *
     * ## `$inject` Annotation
     * By adding a `$inject` property onto a function the injection parameters can be specified.
     *
     * ## Inline
     * As an array of injection names, where the last item in the array is the function to call.
     */

    /**
     * @ngdoc method
     * @name angular.module.AUTO.$injector#get
     * @methodOf angular.module.AUTO.$injector
     *
     * @description
     * Return an instance of the service.
     *
     * @param {string} name The name of the instance to retrieve.
     * @return {*} The instance.
     */

    /**
     * @ngdoc method
     * @name angular.module.AUTO.$injector#invoke
     * @methodOf angular.module.AUTO.$injector
     *
     * @description
     * Invoke the method and supply the method arguments from the `$injector`.
     *
     * @param {!function} fn The function to invoke. The function arguments come form the function annotation.
     * @param {Object=} self The `this` for the invoked method.
     * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
     *   the `$injector` is consulted.
     * @return the value returned by the invoked `fn` function.
     */

    /**
     * @ngdoc method
     * @name angular.module.AUTO.$injector#instantiate
     * @methodOf angular.module.AUTO.$injector
     * @description
     * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies
     * all of the arguments to the constructor function as specified by the constructor annotation.
     *
     * @param {function} Type Annotated constructor function.
     * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before
     *   the `$injector` is consulted.
     * @return new instance of `Type`.
     */


    /**
     * @ngdoc object
     * @name angular.module.AUTO.$provide
     *
     * @description
     *
     * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.
     * The providers share the same name as the instance they create with the `Provider` suffixed to them.
     *
     * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of
     * a service. The Provider can have additional methods which would allow for configuration of the provider.
     *
     * <pre>
     *   function GreetProvider() {
     *     var salutation = 'Hello';
     *
     *     this.salutation = function(text) {
     *       salutation = text;
     *     };
     *
     *     this.$get = function() {
     *       return function (name) {
     *         return salutation + ' ' + name + '!';
     *       };
     *     };
     *   }
     *
     *   describe('Greeter', function(){
     *
     *     beforeEach(module(function($provide) {
     *       $provide.provider('greet', GreetProvider);
     *     });
     *
     *     it('should greet', inject(function(greet) {
     *       expect(greet('angular')).toEqual('Hello angular!');
     *     }));
     *
     *     it('should allow configuration of salutation', function() {
     *       module(function(greetProvider) {
     *         greetProvider.salutation('Ahoj');
     *       });
     *       inject(function(greet) {
     *         expect(greet('angular')).toEqual('Ahoj angular!');
     *       });
     *     )};
     *
     *   });
     * </pre>
     */

    /**
     * @ngdoc method
     * @name angular.module.AUTO.$provide#provider
     * @methodOf angular.module.AUTO.$provide
     * @description
     *
     * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.
     *
     * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.
     * @param {(Object|function())} provider If the provider is:
     *
     *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using
     *               {@link angular.module.AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.
     *   - `Constructor`: a new instance of the provider will be created using
     *               {@link angular.module.AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.
     *
     * @returns {Object} registered provider instance
     */

    /**
     * @ngdoc method
     * @name angular.module.AUTO.$provide#factory
     * @methodOf angular.module.AUTO.$provide
     * @description
     *
     * A short hand for configuring services if only `$get` method is required.
     *
     * @param {string} name The name of the instance.
     * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for
     * `$provide.provider(name, {$get: $getFn})`.
     * @returns {Object} registered provider instance
     */


    /**
     * @ngdoc method
     * @name angular.module.AUTO.$provide#service
     * @methodOf angular.module.AUTO.$provide
     * @description
     *
     * A short hand for registering service of given class.
     *
     * @param {string} name The name of the instance.
     * @param {Function} constructor A class (constructor function) that will be instantiated.
     * @returns {Object} registered provider instance
     */


    /**
     * @ngdoc method
     * @name angular.module.AUTO.$provide#value
     * @methodOf angular.module.AUTO.$provide
     * @description
     *
     * A short hand for configuring services if the `$get` method is a constant.
     *
     * @param {string} name The name of the instance.
     * @param {*} value The value.
     * @returns {Object} registered provider instance
     */


    /**
     * @ngdoc method
     * @name angular.module.AUTO.$provide#constant
     * @methodOf angular.module.AUTO.$provide
     * @description
     *
     * A constant value, but unlike {@link angular.module.AUTO.$provide#value value} it can be injected
     * into configuration function (other modules) and it is not interceptable by
     * {@link angular.module.AUTO.$provide#decorator decorator}.
     *
     * @param {string} name The name of the constant.
     * @param {*} value The constant value.
     * @returns {Object} registered instance
     */


    /**
     * @ngdoc method
     * @name angular.module.AUTO.$provide#decorator
     * @methodOf angular.module.AUTO.$provide
     * @description
     *
     * Decoration of service, allows the decorator to intercept the service instance creation. The
     * returned instance may be the original instance, or a new instance which delegates to the
     * original instance.
     *
     * @param {string} name The name of the service to decorate.
     * @param {function()} decorator This function will be invoked when the service needs to be
     *    instanciated. The function is called using the {@link angular.module.AUTO.$injector#invoke
     *    injector.invoke} method and is therefore fully injectable. Local injection arguments:
     *
     *    * `$delegate` - The original service instance, which can be monkey patched, configured,
     *      decorated or delegated to.
     */


    function createInjector(modulesToLoad) {
        var INSTANTIATING = {},
            providerSuffix = 'Provider',
            path = [],
            loadedModules = new HashMap(),
            providerCache = {
                $provide: {
                    provider: supportObject(provider),
                    factory: supportObject(factory),
                    service: supportObject(service),
                    value: supportObject(value),
                    constant: supportObject(constant),
                    decorator: decorator
                }
            },
            providerInjector = createInternalInjector(providerCache, function() {
                throw Error("Unknown provider: " + path.join(' <- '));
            }),
            instanceCache = {},
            instanceInjector = (instanceCache.$injector =
                createInternalInjector(instanceCache, function(servicename) {
                    var provider = providerInjector.get(servicename + providerSuffix);
                    return instanceInjector.invoke(provider.$get, provider);
                }));


        forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });

        return instanceInjector;

        ////////////////////////////////////
        // $provider
        ////////////////////////////////////

        function supportObject(delegate) {
            return function(key, value) {
                if (isObject(key)) {
                    forEach(key, reverseParams(delegate));
                } else {
                    return delegate(key, value);
                }
            }
        }

        function provider(name, provider_) {
            if (isFunction(provider_)) {
                provider_ = providerInjector.instantiate(provider_);
            }
            if (!provider_.$get) {
                throw Error('Provider ' + name + ' must define $get factory method.');
            }
            return providerCache[name + providerSuffix] = provider_;
        }

        function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }

        function service(name, constructor) {
            return factory(name, ['$injector', function($injector) {
                return $injector.instantiate(constructor);
            }]);
        }

        function value(name, value) { return factory(name, valueFn(value)); }

        function constant(name, value) {
            providerCache[name] = value;
            instanceCache[name] = value;
        }

        function decorator(serviceName, decorFn) {
            var origProvider = providerInjector.get(serviceName + providerSuffix),
                orig$get = origProvider.$get;

            origProvider.$get = function() {
                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});
            };
        }

        ////////////////////////////////////
        // Module Loading
        ////////////////////////////////////
        function loadModules(modulesToLoad){
            var runBlocks = [];
            forEach(modulesToLoad, function(module) {
                if (loadedModules.get(module)) return;
                loadedModules.put(module, true);
                if (isString(module)) {
                    var moduleFn = angularModule(module);
                    runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);

                    try {
                        for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {
                            var invokeArgs = invokeQueue[i],
                                provider = invokeArgs[0] == '$injector'
                                    ? providerInjector
                                    : providerInjector.get(invokeArgs[0]);

                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        }
                    } catch (e) {
                        if (e.message) e.message += ' from ' + module;
                        throw e;
                    }
                } else if (isFunction(module)) {
                    try {
                        runBlocks.push(providerInjector.invoke(module));
                    } catch (e) {
                        if (e.message) e.message += ' from ' + module;
                        throw e;
                    }
                } else if (isArray(module)) {
                    try {
                        runBlocks.push(providerInjector.invoke(module));
                    } catch (e) {
                        if (e.message) e.message += ' from ' + String(module[module.length - 1]);
                        throw e;
                    }
                } else {
                    assertArgFn(module, 'module');
                }
            });
            return runBlocks;
        }

        ////////////////////////////////////
        // internal Injector
        ////////////////////////////////////

        function createInternalInjector(cache, factory) {

            function getService(serviceName) {
                if (typeof serviceName !== 'string') {
                    throw Error('Service name expected');
                }
                if (cache.hasOwnProperty(serviceName)) {
                    if (cache[serviceName] === INSTANTIATING) {
                        throw Error('Circular dependency: ' + path.join(' <- '));
                    }
                    return cache[serviceName];
                } else {
                    try {
                        path.unshift(serviceName);
                        cache[serviceName] = INSTANTIATING;
                        return cache[serviceName] = factory(serviceName);
                    } finally {
                        path.shift();
                    }
                }
            }

            function invoke(fn, self, locals){
                var args = [],
                    $inject,
                    length,
                    key;

                if (typeof fn == 'function') {
                    $inject = inferInjectionArgs(fn);
                    length = $inject.length;
                } else {
                    if (isArray(fn)) {
                        $inject = fn;
                        length = $inject.length - 1;
                        fn = $inject[length];
                    }
                    assertArgFn(fn, 'fn');
                }

                for(var i = 0; i < length; i++) {
                    key = $inject[i];
                    args.push(
                        locals && locals.hasOwnProperty(key)
                            ? locals[key]
                            : getService(key, path)
                    );
                }

                // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke
                switch (self ? -1 : args.length) {
                    case  0: return fn();
                    case  1: return fn(args[0]);
                    case  2: return fn(args[0], args[1]);
                    case  3: return fn(args[0], args[1], args[2]);
                    case  4: return fn(args[0], args[1], args[2], args[3]);
                    case  5: return fn(args[0], args[1], args[2], args[3], args[4]);
                    case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                    case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
                    case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
                    case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
                    default: return fn.apply(self, args);
                }
            }

            function instantiate(Type, locals) {
                var Constructor = function() {},
                    instance, returnedValue;

                Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;
                instance = new Constructor();
                returnedValue = invoke(Type, instance, locals);

                return isObject(returnedValue) ? returnedValue : instance;
            }

            return {
                invoke: invoke,
                instantiate: instantiate,
                get: getService
            };
        }
    }
    /**
     * @ngdoc function
     * @name angular.module.ng.$anchorScroll
     * @requires $window
     * @requires $location
     * @requires $rootScope
     *
     * @description
     * When called, it checks current value of `$location.hash()` and scroll to related element,
     * according to rules specified in
     * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.
     *
     * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.
     * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.
     */
    function $AnchorScrollProvider() {

        var autoScrollingEnabled = true;

        this.disableAutoScrolling = function() {
            autoScrollingEnabled = false;
        };

        this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {
            var document = $window.document;

            // helper function to get first anchor from a NodeList
            // can't use filter.filter, as it accepts only instances of Array
            // and IE can't convert NodeList to an array using [].slice
            // TODO(vojta): use filter if we change it to accept lists as well
            function getFirstAnchor(list) {
                var result = null;
                forEach(list, function(element) {
                    if (!result && lowercase(element.nodeName) === 'a') result = element;
                });
                return result;
            }

            function scroll() {
                var hash = $location.hash(), elm;

                // empty hash, scroll to the top of the page
                if (!hash) $window.scrollTo(0, 0);

                // element with given id
                else if ((elm = document.getElementById(hash))) elm.scrollIntoView();

                // first anchor with given name :-D
                else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();

                // no element and hash == 'top', scroll to the top of the page
                else if (hash === 'top') $window.scrollTo(0, 0);
            }

            // does not scroll when user clicks on anchor link that is currently on
            // (no url change, no $locaiton.hash() change), browser native does scroll
            if (autoScrollingEnabled) {
                $rootScope.$watch(function() {return $location.hash();}, function() {
                    $rootScope.$evalAsync(scroll);
                });
            }

            return scroll;
        }];
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$browser
     * @requires $log
     * @description
     * This object has two goals:
     *
     * - hide all the global state in the browser caused by the window object
     * - abstract away all the browser specific features and inconsistencies
     *
     * For tests we provide {@link angular.module.ngMock.$browser mock implementation} of the `$browser`
     * service, which can be used for convenient testing of the application without the interaction with
     * the real browser apis.
     */
    /**
     * @param {object} window The global window object.
     * @param {object} document jQuery wrapped document.
     * @param {object} body jQuery wrapped document.body.
     * @param {function()} XHR XMLHttpRequest constructor.
     * @param {object} $log console.log or an object with the same interface.
     * @param {object} $sniffer $sniffer service
     */
    function Browser(window, document, body, $log, $sniffer) {
        var self = this,
            rawDocument = document[0],
            location = window.location,
            history = window.history,
            setTimeout = window.setTimeout,
            clearTimeout = window.clearTimeout,
            pendingDeferIds = {};

        self.isMock = false;

        var outstandingRequestCount = 0;
        var outstandingRequestCallbacks = [];

        // TODO(vojta): remove this temporary api
        self.$$completeOutstandingRequest = completeOutstandingRequest;
        self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };

        /**
         * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`
         * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.
         */
        function completeOutstandingRequest(fn) {
            try {
                fn.apply(null, sliceArgs(arguments, 1));
            } finally {
                outstandingRequestCount--;
                if (outstandingRequestCount === 0) {
                    while(outstandingRequestCallbacks.length) {
                        try {
                            outstandingRequestCallbacks.pop()();
                        } catch (e) {
                            $log.error(e);
                        }
                    }
                }
            }
        }

        /**
         * @private
         * Note: this method is used only by scenario runner
         * TODO(vojta): prefix this method with $$ ?
         * @param {function()} callback Function that will be called when no outstanding request
         */
        self.notifyWhenNoOutstandingRequests = function(callback) {
            // force browser to execute all pollFns - this is needed so that cookies and other pollers fire
            // at some deterministic time in respect to the test runner's actions. Leaving things up to the
            // regular poller would result in flaky tests.
            forEach(pollFns, function(pollFn){ pollFn(); });

            if (outstandingRequestCount === 0) {
                callback();
            } else {
                outstandingRequestCallbacks.push(callback);
            }
        };

        //////////////////////////////////////////////////////////////
        // Poll Watcher API
        //////////////////////////////////////////////////////////////
        var pollFns = [],
            pollTimeout;

        /**
         * @ngdoc method
         * @name angular.module.ng.$browser#addPollFn
         * @methodOf angular.module.ng.$browser
         *
         * @param {function()} fn Poll function to add
         *
         * @description
         * Adds a function to the list of functions that poller periodically executes,
         * and starts polling if not started yet.
         *
         * @returns {function()} the added function
         */
        self.addPollFn = function(fn) {
            if (isUndefined(pollTimeout)) startPoller(100, setTimeout);
            pollFns.push(fn);
            return fn;
        };

        /**
         * @param {number} interval How often should browser call poll functions (ms)
         * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.
         *
         * @description
         * Configures the poller to run in the specified intervals, using the specified
         * setTimeout fn and kicks it off.
         */
        function startPoller(interval, setTimeout) {
            (function check() {
                forEach(pollFns, function(pollFn){ pollFn(); });
                pollTimeout = setTimeout(check, interval);
            })();
        }

        //////////////////////////////////////////////////////////////
        // URL API
        //////////////////////////////////////////////////////////////

        var lastBrowserUrl = location.href;

        /**
         * @ngdoc method
         * @name angular.module.ng.$browser#url
         * @methodOf angular.module.ng.$browser
         *
         * @description
         * GETTER:
         * Without any argument, this method just returns current value of location.href.
         *
         * SETTER:
         * With at least one argument, this method sets url to new value.
         * If html5 history api supported, pushState/replaceState is used, otherwise
         * location.href/location.replace is used.
         * Returns its own instance to allow chaining
         *
         * NOTE: this api is intended for use only by the $location service. Please use the
         * {@link angular.module.ng.$location $location service} to change url.
         *
         * @param {string} url New url (when used as setter)
         * @param {boolean=} replace Should new url replace current history record ?
         */
        self.url = function(url, replace) {
            // setter
            if (url) {
                lastBrowserUrl = url;
                if ($sniffer.history) {
                    if (replace) history.replaceState(null, '', url);
                    else history.pushState(null, '', url);
                } else {
                    if (replace) location.replace(url);
                    else location.href = url;
                }
                return self;
                // getter
            } else {
                return location.href;
            }
        };

        var urlChangeListeners = [],
            urlChangeInit = false;

        function fireUrlChange() {
            if (lastBrowserUrl == self.url()) return;

            lastBrowserUrl = self.url();
            forEach(urlChangeListeners, function(listener) {
                listener(self.url());
            });
        }

        /**
         * @ngdoc method
         * @name angular.module.ng.$browser#onUrlChange
         * @methodOf angular.module.ng.$browser
         * @TODO(vojta): refactor to use node's syntax for events
         *
         * @description
         * Register callback function that will be called, when url changes.
         *
         * It's only called when the url is changed by outside of angular:
         * - user types different url into address bar
         * - user clicks on history (forward/back) button
         * - user clicks on a link
         *
         * It's not called when url is changed by $browser.url() method
         *
         * The listener gets called with new url as parameter.
         *
         * NOTE: this api is intended for use only by the $location service. Please use the
         * {@link angular.module.ng.$location $location service} to monitor url changes in angular apps.
         *
         * @param {function(string)} listener Listener function to be called when url changes.
         * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.
         */
        self.onUrlChange = function(callback) {
            if (!urlChangeInit) {
                // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)
                // don't fire popstate when user change the address bar and don't fire hashchange when url
                // changed by push/replaceState

                // html5 history api - popstate event
                if ($sniffer.history) jqLite(window).bind('popstate', fireUrlChange);
                // hashchange event
                if ($sniffer.hashchange) jqLite(window).bind('hashchange', fireUrlChange);
                // polling
                else self.addPollFn(fireUrlChange);

                urlChangeInit = true;
            }

            urlChangeListeners.push(callback);
            return callback;
        };

        //////////////////////////////////////////////////////////////
        // Cookies API
        //////////////////////////////////////////////////////////////
        var lastCookies = {};
        var lastCookieString = '';

        /**
         * @ngdoc method
         * @name angular.module.ng.$browser#cookies
         * @methodOf angular.module.ng.$browser
         *
         * @param {string=} name Cookie name
         * @param {string=} value Cokkie value
         *
         * @description
         * The cookies method provides a 'private' low level access to browser cookies.
         * It is not meant to be used directly, use the $cookie service instead.
         *
         * The return values vary depending on the arguments that the method was called with as follows:
         * <ul>
         *   <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>
         *   <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>
         *   <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>
         * </ul>
         *
         * @returns {Object} Hash of all cookies (if called without any parameter)
         */
        self.cookies = function(name, value) {
            var cookieLength, cookieArray, cookie, i, keyValue, index;

            if (name) {
                if (value === undefined) {
                    rawDocument.cookie = escape(name) + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT";
                } else {
                    if (isString(value)) {
                        rawDocument.cookie = escape(name) + '=' + escape(value);

                        cookieLength = name.length + value.length + 1;
                        if (cookieLength > 4096) {
                            $log.warn("Cookie '"+ name +"' possibly not set or overflowed because it was too large ("+
                                cookieLength + " > 4096 bytes)!");
                        }
                        if (lastCookies.length > 20) {
                            $log.warn("Cookie '"+ name +"' possibly not set or overflowed because too many cookies " +
                                "were already set (" + lastCookies.length + " > 20 )");
                        }
                    }
                }
            } else {
                if (rawDocument.cookie !== lastCookieString) {
                    lastCookieString = rawDocument.cookie;
                    cookieArray = lastCookieString.split("; ");
                    lastCookies = {};

                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf('=');
                        if (index > 0) { //ignore nameless cookies
                            lastCookies[unescape(cookie.substring(0, index))] = unescape(cookie.substring(index + 1));
                        }
                    }
                }
                return lastCookies;
            }
        };


        /**
         * @ngdoc method
         * @name angular.module.ng.$browser#defer
         * @methodOf angular.module.ng.$browser
         * @param {function()} fn A function, who's execution should be defered.
         * @param {number=} [delay=0] of milliseconds to defer the function execution.
         * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.
         *
         * @description
         * Executes a fn asynchroniously via `setTimeout(fn, delay)`.
         *
         * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using
         * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed
         * via `$browser.defer.flush()`.
         *
         */
        self.defer = function(fn, delay) {
            var timeoutId;
            outstandingRequestCount++;
            timeoutId = setTimeout(function() {
                delete pendingDeferIds[timeoutId];
                completeOutstandingRequest(fn);
            }, delay || 0);
            pendingDeferIds[timeoutId] = true;
            return timeoutId;
        };


        /**
         * THIS DOC IS NOT VISIBLE because ngdocs can't process docs for foo#method.method
         *
         * @name angular.module.ng.$browser#defer.cancel
         * @methodOf angular.module.ng.$browser.defer
         *
         * @description
         * Cancels a defered task identified with `deferId`.
         *
         * @param {*} deferId Token returned by the `$browser.defer` function.
         * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfuly canceled.
         */
        self.defer.cancel = function(deferId) {
            if (pendingDeferIds[deferId]) {
                delete pendingDeferIds[deferId];
                clearTimeout(deferId);
                completeOutstandingRequest(noop);
                return true;
            }
            return false;
        };


        //////////////////////////////////////////////////////////////
        // Misc API
        //////////////////////////////////////////////////////////////

        /**
         * @ngdoc method
         * @name angular.module.ng.$browser#addCss
         * @methodOf angular.module.ng.$browser
         *
         * @param {string} url Url to css file
         * @description
         * Adds a stylesheet tag to the head.
         */
        self.addCss = function(url) {
            var link = jqLite(rawDocument.createElement('link'));
            link.attr('rel', 'stylesheet');
            link.attr('type', 'text/css');
            link.attr('href', url);
            body.append(link);
        };


        /**
         * @ngdoc method
         * @name angular.module.ng.$browser#addJs
         * @methodOf angular.module.ng.$browser
         *
         * @param {string} url Url to js file
         *
         * @description
         * Adds a script tag to the head.
         */
        self.addJs = function(url, done) {
            // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:
            // - fetches local scripts via XHR and evals them
            // - adds and immediately removes script elements from the document
            var script = rawDocument.createElement('script');

            script.type = 'text/javascript';
            script.src = url;

            if (msie) {
                script.onreadystatechange = function() {
                    /loaded|complete/.test(script.readyState) && done && done();
                };
            } else {
                if (done) script.onload = script.onerror = done;
            }

            body[0].appendChild(script);

            return script;
        };

        /**
         * Returns current <base href>
         * (always relative - without domain)
         *
         * @returns {string=}
         */
        self.baseHref = function() {
            var href = document.find('base').attr('href');
            return href ? href.replace(/^https?\:\/\/[^\/]*/, '') : href;
        };
    }

    function $BrowserProvider(){
        this.$get = ['$window', '$log', '$sniffer', '$document',
            function( $window,   $log,   $sniffer,   $document){
                return new Browser($window, $document, $document.find('body'), $log, $sniffer);
            }];
    }
    /**
     * @ngdoc object
     * @name angular.module.ng.$cacheFactory
     *
     * @description
     * Factory that constructs cache objects.
     *
     *
     * @param {string} cacheId Name or id of the newly created cache.
     * @param {object=} options Options object that specifies the cache behavior. Properties:
     *
     *   - `{number=}` `capacity` — turns the cache into LRU cache.
     *
     * @returns {object} Newly created cache object with the following set of methods:
     *
     * - `{object}` `info()` — Returns id, size, and options of cache.
     * - `{void}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache.
     * - `{{*}} `get({string} key) — Returns cached value for `key` or undefined for cache miss.
     * - `{void}` `remove({string} key) — Removes a key-value pair from the cache.
     * - `{void}` `removeAll() — Removes all cached values.
     * - `{void}` `destroy() — Removes references to this cache from $cacheFactory.
     *
     */
    function $CacheFactoryProvider() {

        this.$get = function() {
            var caches = {};

            function cacheFactory(cacheId, options) {
                if (cacheId in caches) {
                    throw Error('cacheId ' + cacheId + ' taken');
                }

                var size = 0,
                    stats = extend({}, options, {id: cacheId}),
                    data = {},
                    capacity = (options && options.capacity) || Number.MAX_VALUE,
                    lruHash = {},
                    freshEnd = null,
                    staleEnd = null;

                return caches[cacheId] = {

                    put: function(key, value) {
                        var lruEntry = lruHash[key] || (lruHash[key] = {key: key});

                        refresh(lruEntry);

                        if (isUndefined(value)) return;
                        if (!(key in data)) size++;
                        data[key] = value;

                        if (size > capacity) {
                            this.remove(staleEnd.key);
                        }
                    },


                    get: function(key) {
                        var lruEntry = lruHash[key];

                        if (!lruEntry) return;

                        refresh(lruEntry);

                        return data[key];
                    },


                    remove: function(key) {
                        var lruEntry = lruHash[key];

                        if (lruEntry == freshEnd) freshEnd = lruEntry.p;
                        if (lruEntry == staleEnd) staleEnd = lruEntry.n;
                        link(lruEntry.n,lruEntry.p);

                        delete lruHash[key];
                        delete data[key];
                        size--;
                    },


                    removeAll: function() {
                        data = {};
                        size = 0;
                        lruHash = {};
                        freshEnd = staleEnd = null;
                    },


                    destroy: function() {
                        data = null;
                        stats = null;
                        lruHash = null;
                        delete caches[cacheId];
                    },


                    info: function() {
                        return extend({}, stats, {size: size});
                    }
                };


                /**
                 * makes the `entry` the freshEnd of the LRU linked list
                 */
                function refresh(entry) {
                    if (entry != freshEnd) {
                        if (!staleEnd) {
                            staleEnd = entry;
                        } else if (staleEnd == entry) {
                            staleEnd = entry.n;
                        }

                        link(entry.n, entry.p);
                        link(entry, freshEnd);
                        freshEnd = entry;
                        freshEnd.n = null;
                    }
                }


                /**
                 * bidirectionally links two entries of the LRU linked list
                 */
                function link(nextEntry, prevEntry) {
                    if (nextEntry != prevEntry) {
                        if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify
                        if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify
                    }
                }
            }


            cacheFactory.info = function() {
                var info = {};
                forEach(caches, function(cache, cacheId) {
                    info[cacheId] = cache.info();
                });
                return info;
            };


            cacheFactory.get = function(cacheId) {
                return caches[cacheId];
            };


            return cacheFactory;
        };
    }

    function $TemplateCacheProvider() {
        this.$get = ['$cacheFactory', function($cacheFactory) {
            return $cacheFactory('templates');
        }];
    }

    /**
     * @ngdoc function
     * @name angular.module.ng.$compile
     * @function
     *
     * @description
     * Compiles a piece of HTML string or DOM into a template and produces a template function, which
     * can then be used to link {@link angular.module.ng.$rootScope.Scope scope} and the template together.
     *
     * The compilation is a process of walking the DOM tree and trying to match DOM elements to
     * {@link angular.module.ng.$compileProvider.directive directives}. For each match it
     * executes corresponding template function and collects the
     * instance functions into a single template function which is then returned.
     *
     * The template function can then be used once to produce the view or as it is the case with
     * {@link angular.module.ng.$compileProvider.directive.ng-repeat repeater} many-times, in which
     * case each call results in a view that is a DOM clone of the original template.
     *
     <doc:example module="compile">
     <doc:source>
     <script>
     // declare a new module, and inject the $compileProvider
     angular.module('compile', [], function($compileProvider) {
     // configure new 'compile' directive by passing a directive
     // factory function. The factory function injects the '$compile'
     $compileProvider.directive('compile', function($compile) {
     // directive factory creates a link function
     return function(scope, element, attrs) {
     scope.$watch(
     function(scope) {
     // watch the 'compile' expression for changes
     return scope.$eval(attrs.compile);
     },
     function(value) {
     // when the 'compile' expression changes
     // assign it into the current DOM
     element.html(value);

     // compile the new DOM and link it to the current
     // scope.
     // NOTE: we only compile .childNodes so that
     // we don't get into infinite loop compiling ourselves
     $compile(element.contents())(scope);
     }
     );
     };
     })
     });

     function Ctrl($scope) {
     $scope.name = 'Angular';
     $scope.html = 'Hello {{name}}';
     }
     </script>
     <div ng-controller="Ctrl">
     <input ng-model="name"> <br>
     <textarea ng-model="html"></textarea> <br>
     <div compile="html"></div>
     </div>
     </doc:source>
     <doc:scenario>
     it('should auto compile', function() {
     expect(element('div[compile]').text()).toBe('Hello Angular');
     input('html').enter('{{name}}!');
     expect(element('div[compile]').text()).toBe('Angular!');
     });
     </doc:scenario>
     </doc:example>

     *
     *
     * @param {string|DOMElement} element Element or HTML string to compile into a template function.
     * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.
     * @param {number} maxPriority only apply directives lower then given priority (Only effects the
     *                 root element(s), not their children)
     * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template
     * (a DOM element/tree) to a scope. Where:
     *
     *  * `scope` - A {@link angular.module.ng.$rootScope.Scope Scope} to bind to.
     *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the
     *               `template` and call the `cloneAttachFn` function allowing the caller to attach the
     *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is
     *               called as: <br> `cloneAttachFn(clonedElement, scope)` where:
     *
     *      * `clonedElement` - is a clone of the original `element` passed into the compiler.
     *      * `scope` - is the current scope with which the linking function is working with.
     *
     * Calling the linking function returns the element of the template. It is either the original element
     * passed in, or the clone of the element if the `cloneAttachFn` is provided.
     *
     * After linking the view is not updateh until after a call to $digest which typically is done by
     * Angular automatically.
     *
     * If you need access to the bound view, there are two ways to do it:
     *
     * - If you are not asking the linking function to clone the template, create the DOM element(s)
     *   before you send them to the compiler and keep this reference around.
     *   <pre>
     *     var element = $compile('<p>{{total}}</p>')(scope);
     *   </pre>
     *
     * - if on the other hand, you need the element to be cloned, the view reference from the original
     *   example would not point to the clone, but rather to the original template that was cloned. In
     *   this case, you can access the clone via the cloneAttachFn:
     *   <pre>
     *     var templateHTML = angular.element('<p>{{total}}</p>'),
     *         scope = ....;
     *
     *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {
     *       //attach the clone to DOM document at the right place
     *     });
     *
     *     //now we have reference to the cloned DOM via `clone`
     *   </pre>
     *
     *
     * For information on how the compiler works, see the
     * {@link guide/dev_guide.compiler Angular HTML Compiler} section of the Developer Guide.
     */


    $CompileProvider.$inject = ['$provide'];
    function $CompileProvider($provide) {
        var hasDirectives = {},
            Suffix = 'Directive',
            COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\d\w\-_]+)\s+(.*)$/,
            CLASS_DIRECTIVE_REGEXP = /(([\d\w\-_]+)(?:\:([^;]+))?;?)/,
            CONTENT_REGEXP = /\<\<content\>\>/i,
            HAS_ROOT_ELEMENT = /^\<[\s\S]*\>$/;


        this.directive = function registerDirective(name, directiveFactory) {
            if (isString(name)) {
                assertArg(directiveFactory, 'directive');
                if (!hasDirectives.hasOwnProperty(name)) {
                    hasDirectives[name] = [];
                    $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',
                        function($injector, $exceptionHandler) {
                            var directives = [];
                            forEach(hasDirectives[name], function(directiveFactory) {
                                try {
                                    var directive = $injector.invoke(directiveFactory);
                                    if (isFunction(directive)) {
                                        directive = { compile: valueFn(directive) };
                                    } else if (!directive.compile && directive.link) {
                                        directive.compile = valueFn(directive.link);
                                    }
                                    directive.priority = directive.priority || 0;
                                    directive.name = directive.name || name;
                                    directive.require = directive.require || (directive.controller && directive.name);
                                    directive.restrict = directive.restrict || 'A';
                                    directives.push(directive);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            });
                            return directives;
                        }]);
                }
                hasDirectives[name].push(directiveFactory);
            } else {
                forEach(name, reverseParams(registerDirective));
            }
            return this;
        };


        this.$get = [
            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',
            '$controller',
            function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,
                     $controller) {

                var LOCAL_MODE = {
                    attribute: function(localName, mode, parentScope, scope, attr) {
                        scope[localName] = attr[localName];
                    },

                    evaluate: function(localName, mode, parentScope, scope, attr) {
                        scope[localName] = parentScope.$eval(attr[localName]);
                    },

                    bind: function(localName, mode, parentScope, scope, attr) {
                        var getter = $interpolate(attr[localName]);
                        scope.$watch(
                            function() { return getter(parentScope); },
                            function(v) { scope[localName] = v; }
                        );
                    },

                    accessor: function(localName, mode, parentScope, scope, attr) {
                        var getter = noop,
                            setter = noop,
                            exp = attr[localName];

                        if (exp) {
                            getter = $parse(exp);
                            setter = getter.assign || function() {
                                throw Error("Expression '" + exp + "' not assignable.");
                            };
                        }

                        scope[localName] = function(value) {
                            return arguments.length ? setter(parentScope, value) : getter(parentScope);
                        };
                    },

                    expression: function(localName, mode, parentScope, scope, attr) {
                        scope[localName] = function(locals) {
                            $parse(attr[localName])(parentScope, locals);
                        };
                    }
                };

                var Attributes = function(element, attr) {
                    this.$$element = element;
                    this.$$observers = {};
                    this.$attr = attr || {};
                };

                Attributes.prototype = {
                    $normalize: directiveNormalize,


                    /**
                     * Set a normalized attribute on the element in a way such that all directives
                     * can share the attribute. This function properly handles boolean attributes.
                     * @param {string} key Normalized key. (ie ngAttribute)
                     * @param {string|boolean} value The value to set. If `null` attribute will be deleted.
                     * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.
                     *     Defaults to true.
                     * @param {string=} attrName Optional none normalized name. Defaults to key.
                     */
                    $set: function(key, value, writeAttr, attrName) {
                        var booleanKey = isBooleanAttr(this.$$element[0], key.toLowerCase());

                        if (booleanKey) {
                            this.$$element.prop(key, value);
                            attrName = booleanKey;
                        }

                        this[key] = value;

                        // translate normalized key to actual key
                        if (attrName) {
                            this.$attr[key] = attrName;
                        } else {
                            attrName = this.$attr[key];
                            if (!attrName) {
                                this.$attr[key] = attrName = snake_case(key, '-');
                            }
                        }

                        if (writeAttr !== false) {
                            if (value === null || value === undefined) {
                                this.$$element.removeAttr(attrName);
                            } else {
                                this.$$element.attr(attrName, value);
                            }
                        }

                        // fire observers
                        forEach(this.$$observers[key], function(fn) {
                            try {
                                fn(value);
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        });
                    },


                    /**
                     * Observe an interpolated attribute.
                     * The observer will never be called, if given attribute is not interpolated.
                     *
                     * @param {string} key Normalized key. (ie ngAttribute) .
                     * @param {function(*)} fn Function that will be called whenever the attribute value changes.
                     */
                    $observe: function(key, fn) {
                        // keep only observers for interpolated attrs
                        if (this.$$observers[key]) {
                            this.$$observers[key].push(fn);
                        }
                    }
                };

                return compile;

                //================================

                function compile(templateElement, transcludeFn, maxPriority) {
                    if (!(templateElement instanceof jqLite)) {
                        // jquery always rewraps, where as we need to preserve the original selector so that we can modify it.
                        templateElement = jqLite(templateElement);
                    }
                    // We can not compile top level text elements since text nodes can be merged and we will
                    // not be able to attach scope data to them, so we will wrap them in <span>
                    forEach(templateElement, function(node, index){
                        if (node.nodeType == 3 /* text node */) {
                            templateElement[index] = jqLite(node).wrap('<span>').parent()[0];
                        }
                    });
                    var linkingFn = compileNodes(templateElement, transcludeFn, templateElement, maxPriority);
                    return function(scope, cloneConnectFn){
                        assertArg(scope, 'scope');
                        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart
                        // and sometimes changes the structure of the DOM.
                        var element = cloneConnectFn
                            ? JQLitePrototype.clone.call(templateElement) // IMPORTANT!!!
                            : templateElement;
                        safeAddClass(element.data('$scope', scope), 'ng-scope');
                        if (cloneConnectFn) cloneConnectFn(element, scope);
                        if (linkingFn) linkingFn(scope, element, element);
                        return element;
                    };
                }

                function wrongMode(localName, mode) {
                    throw Error("Unsupported '" + mode + "' for '" + localName + "'.");
                }

                function safeAddClass(element, className) {
                    try {
                        element.addClass(className);
                    } catch(e) {
                        // ignore, since it means that we are trying to set class on
                        // SVG element, where class name is read-only.
                    }
                }

                /**
                 * Compile function matches each node in nodeList against the directives. Once all directives
                 * for a particular node are collected their compile functions are executed. The compile
                 * functions return values - the linking functions - are combined into a composite linking
                 * function, which is the a linking function for the node.
                 *
                 * @param {NodeList} nodeList an array of nodes to compile
                 * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
                 *        scope argument is auto-generated to the new child of the transcluded parent scope.
                 * @param {DOMElement=} rootElement If the nodeList is the root of the compilation tree then the
                 *        rootElement must be set the jqLite collection of the compile root. This is
                 *        needed so that the jqLite collection items can be replaced with widgets.
                 * @param {number=} max directive priority
                 * @returns {?function} A composite linking function of all of the matched directives or null.
                 */
                function compileNodes(nodeList, transcludeFn, rootElement, maxPriority) {
                    var linkingFns = [],
                        directiveLinkingFn, childLinkingFn, directives, attrs, linkingFnFound;

                    for(var i = 0, ii = nodeList.length; i < ii; i++) {
                        attrs = new Attributes();

                        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.
                        directives = collectDirectives(nodeList[i], [], attrs, maxPriority);

                        directiveLinkingFn = (directives.length)
                            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, rootElement)
                            : null;

                        childLinkingFn = (directiveLinkingFn && directiveLinkingFn.terminal)
                            ? null
                            : compileNodes(nodeList[i].childNodes,
                            directiveLinkingFn ? directiveLinkingFn.transclude : transcludeFn);

                        linkingFns.push(directiveLinkingFn);
                        linkingFns.push(childLinkingFn);
                        linkingFnFound = (linkingFnFound || directiveLinkingFn || childLinkingFn);
                    }

                    // return a linking function if we have found anything, null otherwise
                    return linkingFnFound ? linkingFn : null;

                    /* nodesetLinkingFn */ function linkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
                        if (linkingFns.length != nodeList.length * 2) {
                            throw Error('Template changed structure!');
                        }

                        var childLinkingFn, directiveLinkingFn, node, childScope, childTransclusionFn;

                        for(var i=0, n=0, ii=linkingFns.length; i<ii; n++) {
                            node = nodeList[n];
                            directiveLinkingFn = /* directiveLinkingFn */ linkingFns[i++];
                            childLinkingFn = /* nodesetLinkingFn */ linkingFns[i++];

                            if (directiveLinkingFn) {
                                if (directiveLinkingFn.scope) {
                                    childScope = scope.$new(isObject(directiveLinkingFn.scope));
                                    jqLite(node).data('$scope', childScope);
                                } else {
                                    childScope = scope;
                                }
                                childTransclusionFn = directiveLinkingFn.transclude;
                                if (childTransclusionFn || (!boundTranscludeFn && transcludeFn)) {
                                    directiveLinkingFn(childLinkingFn, childScope, node, rootElement,
                                        (function(transcludeFn) {
                                            return function(cloneFn) {
                                                var transcludeScope = scope.$new();

                                                return transcludeFn(transcludeScope, cloneFn).
                                                    bind('$destroy', bind(transcludeScope, transcludeScope.$destroy));
                                            };
                                        })(childTransclusionFn || transcludeFn)
                                    );
                                } else {
                                    directiveLinkingFn(childLinkingFn, childScope, node, undefined, boundTranscludeFn);
                                }
                            } else if (childLinkingFn) {
                                childLinkingFn(scope, node.childNodes, undefined, boundTranscludeFn);
                            }
                        }
                    }
                }


                /**
                 * Looks for directives on the given node ands them to the directive collection which is sorted.
                 *
                 * @param node node to search
                 * @param directives an array to which the directives are added to. This array is sorted before
                 *        the function returns.
                 * @param attrs the shared attrs object which is used to populate the normalized attributes.
                 * @param {number=} max directive priority
                 */
                function collectDirectives(node, directives, attrs, maxPriority) {
                    var nodeType = node.nodeType,
                        attrsMap = attrs.$attr,
                        match,
                        className;

                    switch(nodeType) {
                        case 1: /* Element */
                            // use the node name: <directive>
                            addDirective(directives,
                                directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority);

                            // iterate over the attributes
                            for (var attr, name, nName, value, nAttrs = node.attributes,
                                     j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                attr = nAttrs[j];
                                if (attr.specified) {
                                    name = attr.name;
                                    nName = directiveNormalize(name.toLowerCase());
                                    attrsMap[nName] = name;
                                    attrs[nName] = value = trim((msie && name == 'href')
                                        ? decodeURIComponent(node.getAttribute(name, 2))
                                        : attr.value);
                                    if (isBooleanAttr(node, nName)) {
                                        attrs[nName] = true; // presence means true
                                    }
                                    addAttrInterpolateDirective(node, directives, value, nName)
                                    addDirective(directives, nName, 'A', maxPriority);
                                }
                            }

                            // use class as directive
                            className = node.className;
                            if (isString(className)) {
                                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                                    nName = directiveNormalize(match[2]);
                                    if (addDirective(directives, nName, 'C', maxPriority)) {
                                        attrs[nName] = trim(match[3]);
                                    }
                                    className = className.substr(match.index + match[0].length);
                                }
                            }
                            break;
                        case 3: /* Text Node */
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;
                        case 8: /* Comment */
                            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                            if (match) {
                                nName = directiveNormalize(match[1]);
                                if (addDirective(directives, nName, 'M', maxPriority)) {
                                    attrs[nName] = trim(match[2]);
                                }
                            }
                            break;
                    }

                    directives.sort(byPriority);
                    return directives;
                }


                /**
                 * Once the directives have been collected their compile functions is executed. This method
                 * is responsible for inlining directive templates as well as terminating the application
                 * of the directives if the terminal directive has been reached..
                 *
                 * @param {Array} directives Array of collected directives to execute their compile function.
                 *        this needs to be pre-sorted by priority order.
                 * @param {Node} templateNode The raw DOM node to apply the compile functions to
                 * @param {Object} templateAttrs The shared attribute function
                 * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the
                 *        scope argument is auto-generated to the new child of the transcluded parent scope.
                 * @param {DOMElement} rootElement If we are working on the root of the compile tree then this
                 *        argument has the root jqLite array so that we can replace widgets on it.
                 * @returns linkingFn
                 */
                function applyDirectivesToNode(directives, templateNode, templateAttrs, transcludeFn, rootElement) {
                    var terminalPriority = -Number.MAX_VALUE,
                        preLinkingFns = [],
                        postLinkingFns = [],
                        newScopeDirective = null,
                        newIsolatedScopeDirective = null,
                        templateDirective = null,
                        delayedLinkingFn = null,
                        element = templateAttrs.$$element = jqLite(templateNode),
                        directive,
                        directiveName,
                        template,
                        transcludeDirective,
                        childTranscludeFn = transcludeFn,
                        controllerDirectives,
                        linkingFn,
                        directiveValue;

                    // executes all directives on the current element
                    for(var i = 0, ii = directives.length; i < ii; i++) {
                        directive = directives[i];
                        template = undefined;

                        if (terminalPriority > directive.priority) {
                            break; // prevent further processing of directives
                        }

                        if (directiveValue = directive.scope) {
                            assertNoDuplicate('isolated scope', newIsolatedScopeDirective, directive, element);
                            if (isObject(directiveValue)) {
                                safeAddClass(element, 'ng-isolate-scope');
                                newIsolatedScopeDirective = directive;
                            }
                            safeAddClass(element, 'ng-scope');
                            newScopeDirective = newScopeDirective || directive;
                        }

                        directiveName = directive.name;

                        if (directiveValue = directive.controller) {
                            controllerDirectives = controllerDirectives || {};
                            assertNoDuplicate("'" + directiveName + "' controller",
                                controllerDirectives[directiveName], directive, element);
                            controllerDirectives[directiveName] = directive;
                        }

                        if (directiveValue = directive.transclude) {
                            assertNoDuplicate('transclusion', transcludeDirective, directive, element);
                            transcludeDirective = directive;
                            terminalPriority = directive.priority;
                            if (directiveValue == 'element') {
                                template = jqLite(templateNode);
                                templateNode = (element = templateAttrs.$$element = jqLite(
                                    '<!-- ' + directiveName + ': ' + templateAttrs[directiveName]  + ' -->'))[0];
                                replaceWith(rootElement, jqLite(template[0]), templateNode);
                                childTranscludeFn = compile(template, transcludeFn, terminalPriority);
                            } else {
                                template = jqLite(JQLiteClone(templateNode));
                                element.html(''); // clear contents
                                childTranscludeFn = compile(template.contents(), transcludeFn);
                            }
                        }

                        if (directiveValue = directive.template) {
                            assertNoDuplicate('template', templateDirective, directive, element);
                            templateDirective = directive;

                            // include the contents of the original element into the template and replace the element
                            var content = directiveValue.replace(CONTENT_REGEXP, element.html());
                            templateNode = jqLite(content)[0];
                            if (directive.replace) {
                                replaceWith(rootElement, element, templateNode);

                                var newTemplateAttrs = {$attr: {}};

                                // combine directives from the original node and from the template:
                                // - take the array of directives for this element
                                // - split it into two parts, those that were already applied and those that weren't
                                // - collect directives from the template, add them to the second group and sort them
                                // - append the second group with new directives to the first group
                                directives = directives.concat(
                                    collectDirectives(
                                        templateNode,
                                        directives.splice(i + 1, directives.length - (i + 1)),
                                        newTemplateAttrs
                                    )
                                );
                                mergeTemplateAttributes(templateAttrs, newTemplateAttrs);

                                ii = directives.length;
                            } else {
                                element.html(content);
                            }
                        }

                        if (directive.templateUrl) {
                            assertNoDuplicate('template', templateDirective, directive, element);
                            templateDirective = directive;
                            delayedLinkingFn = compileTemplateUrl(directives.splice(i, directives.length - i),
                                /* directiveLinkingFn */ compositeLinkFn, element, templateAttrs, rootElement,
                                directive.replace, childTranscludeFn);
                            ii = directives.length;
                        } else if (directive.compile) {
                            try {
                                linkingFn = directive.compile(element, templateAttrs, childTranscludeFn);
                                if (isFunction(linkingFn)) {
                                    addLinkingFns(null, linkingFn);
                                } else if (linkingFn) {
                                    addLinkingFns(linkingFn.pre, linkingFn.post);
                                }
                            } catch (e) {
                                $exceptionHandler(e, startingTag(element));
                            }
                        }

                        if (directive.terminal) {
                            compositeLinkFn.terminal = true;
                            terminalPriority = Math.max(terminalPriority, directive.priority);
                        }

                    }

                    linkingFn = delayedLinkingFn || compositeLinkFn;
                    linkingFn.scope = newScopeDirective && newScopeDirective.scope;
                    linkingFn.transclude = transcludeDirective && childTranscludeFn;

                    // if we have templateUrl, then we have to delay linking
                    return linkingFn;

                    ////////////////////

                    function addLinkingFns(pre, post) {
                        if (pre) {
                            pre.require = directive.require;
                            preLinkingFns.push(pre);
                        }
                        if (post) {
                            post.require = directive.require;
                            postLinkingFns.push(post);
                        }
                    }


                    function getControllers(require, element) {
                        var value, retrievalMethod = 'data', optional = false;
                        if (isString(require)) {
                            while((value = require.charAt(0)) == '^' || value == '?') {
                                require = require.substr(1);
                                if (value == '^') {
                                    retrievalMethod = 'inheritedData';
                                }
                                optional = optional || value == '?';
                            }
                            value = element[retrievalMethod]('$' + require + 'Controller');
                            if (!value && !optional) {
                                throw Error("No controller: " + require);
                            }
                            return value;
                        } else if (isArray(require)) {
                            value = [];
                            forEach(require, function(require) {
                                value.push(getControllers(require, element));
                            });
                        }
                        return value;
                    }


                    /* directiveLinkingFn */
                    function compositeLinkFn(/* nodesetLinkingFn */ childLinkingFn,
                                             scope, linkNode, rootElement, boundTranscludeFn) {
                        var attrs, element, i, ii, linkingFn, controller;

                        if (templateNode === linkNode) {
                            attrs = templateAttrs;
                        } else {
                            attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));
                        }
                        element = attrs.$$element;

                        if (newScopeDirective && isObject(newScopeDirective.scope)) {
                            forEach(newScopeDirective.scope, function(mode, name) {
                                (LOCAL_MODE[mode] || wrongMode)(name, mode,
                                    scope.$parent || scope, scope, attrs);
                            });
                        }

                        if (controllerDirectives) {
                            forEach(controllerDirectives, function(directive) {
                                var locals = {
                                    $scope: scope,
                                    $element: element,
                                    $attrs: attrs,
                                    $transclude: boundTranscludeFn
                                };


                                forEach(directive.inject || {}, function(mode, name) {
                                    (LOCAL_MODE[mode] || wrongMode)(name, mode,
                                        newScopeDirective ? scope.$parent || scope : scope, locals, attrs);
                                });

                                controller = directive.controller;
                                if (controller == '@') {
                                    controller = attrs[directive.name];
                                }

                                element.data(
                                    '$' + directive.name + 'Controller',
                                    $controller(controller, locals));
                            });
                        }

                        // PRELINKING
                        for(i = 0, ii = preLinkingFns.length; i < ii; i++) {
                            try {
                                linkingFn = preLinkingFns[i];
                                linkingFn(scope, element, attrs,
                                    linkingFn.require && getControllers(linkingFn.require, element));
                            } catch (e) {
                                $exceptionHandler(e, startingTag(element));
                            }
                        }

                        // RECURSION
                        childLinkingFn && childLinkingFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);

                        // POSTLINKING
                        for(i = 0, ii = postLinkingFns.length; i < ii; i++) {
                            try {
                                linkingFn = postLinkingFns[i];
                                linkingFn(scope, element, attrs,
                                    linkingFn.require && getControllers(linkingFn.require, element));
                            } catch (e) {
                                $exceptionHandler(e, startingTag(element));
                            }
                        }
                    }
                }


                /**
                 * looks up the directive and decorates it with exception handling and proper parameters. We
                 * call this the boundDirective.
                 *
                 * @param {string} name name of the directive to look up.
                 * @param {string} location The directive must be found in specific format.
                 *   String containing any of theses characters:
                 *
                 *   * `E`: element name
                 *   * `A': attribute
                 *   * `C`: class
                 *   * `M`: comment
                 * @returns true if directive was added.
                 */
                function addDirective(tDirectives, name, location, maxPriority) {
                    var match = false;
                    if (hasDirectives.hasOwnProperty(name)) {
                        for(var directive, directives = $injector.get(name + Suffix),
                                i=0, ii = directives.length; i<ii; i++) {
                            try {
                                directive = directives[i];
                                if ( (maxPriority === undefined || maxPriority > directive.priority) &&
                                    directive.restrict.indexOf(location) != -1) {
                                    tDirectives.push(directive);
                                    match = true;
                                }
                            } catch(e) { $exceptionHandler(e); }
                        }
                    }
                    return match;
                }


                /**
                 * When the element is replaced with HTML template then the new attributes
                 * on the template need to be merged with the existing attributes in the DOM.
                 * The desired effect is to have both of the attributes present.
                 *
                 * @param {object} dst destination attributes (original DOM)
                 * @param {object} src source attributes (from the directive template)
                 */
                function mergeTemplateAttributes(dst, src) {
                    var srcAttr = src.$attr,
                        dstAttr = dst.$attr,
                        element = dst.$$element;
                    // reapply the old attributes to the new element
                    forEach(dst, function(value, key) {
                        if (key.charAt(0) != '$') {
                            if (src[key]) {
                                value += (key === 'style' ? ';' : ' ') + src[key];
                            }
                            dst.$set(key, value, true, srcAttr[key]);
                        }
                    });
                    // copy the new attributes on the old attrs object
                    forEach(src, function(value, key) {
                        if (key == 'class') {
                            safeAddClass(element, value);
                        } else if (key == 'style') {
                            element.attr('style', element.attr('style') + ';' + value);
                        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                            dst[key] = value;
                            dstAttr[key] = srcAttr[key];
                        }
                    });
                }


                function compileTemplateUrl(directives, /* directiveLinkingFn */ beforeWidgetLinkFn,
                                            tElement, tAttrs, rootElement, replace, transcludeFn) {
                    var linkQueue = [],
                        afterWidgetLinkFn,
                        afterWidgetChildrenLinkFn,
                        originalWidgetNode = tElement[0],
                        asyncWidgetDirective = directives.shift(),
                        // The fact that we have to copy and patch the directive seems wrong!
                        syncWidgetDirective = extend({}, asyncWidgetDirective, {templateUrl:null, transclude:null}),
                        html = tElement.html();

                    tElement.html('');

                    $http.get(asyncWidgetDirective.templateUrl, {cache: $templateCache}).
                        success(function(content) {
                            content = trim(content).replace(CONTENT_REGEXP, html);
                            if (replace && !content.match(HAS_ROOT_ELEMENT)) {
                                throw Error('Template must have exactly one root element: ' + content);
                            }

                            var templateNode, tempTemplateAttrs;

                            if (replace) {
                                tempTemplateAttrs = {$attr: {}};
                                templateNode = jqLite(content)[0];
                                replaceWith(rootElement, tElement, templateNode);
                                collectDirectives(tElement[0], directives, tempTemplateAttrs);
                                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else {
                                templateNode = tElement[0];
                                tElement.html(content);
                            }

                            directives.unshift(syncWidgetDirective);
                            afterWidgetLinkFn = /* directiveLinkingFn */ applyDirectivesToNode(directives, tElement, tAttrs, transcludeFn);
                            afterWidgetChildrenLinkFn = /* nodesetLinkingFn */ compileNodes(tElement.contents(), transcludeFn);


                            while(linkQueue.length) {
                                var controller = linkQueue.pop(),
                                    linkRootElement = linkQueue.pop(),
                                    cLinkNode = linkQueue.pop(),
                                    scope = linkQueue.pop(),
                                    node = templateNode;

                                if (cLinkNode !== originalWidgetNode) {
                                    // it was cloned therefore we have to clone as well.
                                    node = JQLiteClone(templateNode);
                                    replaceWith(linkRootElement, jqLite(cLinkNode), node);
                                }
                                afterWidgetLinkFn(function() {
                                    beforeWidgetLinkFn(afterWidgetChildrenLinkFn, scope, node, rootElement, controller);
                                }, scope, node, rootElement, controller);
                            }
                            linkQueue = null;
                        }).
                        error(function(response, code, headers, config) {
                            throw Error('Failed to load template: ' + config.url);
                        });

                    return /* directiveLinkingFn */ function(ignoreChildLinkingFn, scope, node, rootElement,
                                                             controller) {
                        if (linkQueue) {
                            linkQueue.push(scope);
                            linkQueue.push(node);
                            linkQueue.push(rootElement);
                            linkQueue.push(controller);
                        } else {
                            afterWidgetLinkFn(function() {
                                beforeWidgetLinkFn(afterWidgetChildrenLinkFn, scope, node, rootElement, controller);
                            }, scope, node, rootElement, controller);
                        }
                    };
                }


                /**
                 * Sorting function for bound directives.
                 */
                function byPriority(a, b) {
                    return b.priority - a.priority;
                }


                function assertNoDuplicate(what, previousDirective, directive, element) {
                    if (previousDirective) {
                        throw Error('Multiple directives [' + previousDirective.name + ', ' +
                            directive.name + '] asking for ' + what + ' on: ' +  startingTag(element));
                    }
                }


                function addTextInterpolateDirective(directives, text) {
                    var interpolateFn = $interpolate(text, true);
                    if (interpolateFn) {
                        directives.push({
                            priority: 0,
                            compile: valueFn(function(scope, node) {
                                var parent = node.parent(),
                                    bindings = parent.data('$binding') || [];
                                bindings.push(interpolateFn);
                                safeAddClass(parent.data('$binding', bindings), 'ng-binding');
                                scope.$watch(interpolateFn, function(value) {
                                    node[0].nodeValue = value;
                                });
                            })
                        });
                    }
                }


                function addAttrInterpolateDirective(node, directives, value, name) {
                    var interpolateFn = $interpolate(value, true);


                    // no interpolation found -> ignore
                    if (!interpolateFn) return;

                    directives.push({
                        priority: 100,
                        compile: valueFn(function(scope, element, attr) {
                            if (name === 'class') {
                                // we need to interpolate classes again, in the case the element was replaced
                                // and therefore the two class attrs got merged - we want to interpolate the result
                                interpolateFn = $interpolate(attr[name], true);
                            }

                            // we define observers array only for interpolated attrs
                            // and ignore observers for non interpolated attrs to save some memory
                            attr.$$observers[name] = [];
                            attr[name] = undefined;
                            scope.$watch(interpolateFn, function(value) {
                                attr.$set(name, value);
                            });
                        })
                    });
                }


                /**
                 * This is a special jqLite.replaceWith, which can replace items which
                 * have no parents, provided that the containing jqLite collection is provided.
                 *
                 * @param {JqLite=} rootElement The root of the compile tree. Used so that we can replace nodes
                 *    in the root of the tree.
                 * @param {JqLite} element The jqLite element which we are going to replace. We keep the shell,
                 *    but replace its DOM node reference.
                 * @param {Node} newNode The new DOM node.
                 */
                function replaceWith(rootElement, element, newNode) {
                    var oldNode = element[0],
                        parent = oldNode.parentNode,
                        i, ii;

                    if (rootElement) {
                        for(i = 0, ii = rootElement.length; i<ii; i++) {
                            if (rootElement[i] == oldNode) {
                                rootElement[i] = newNode;
                            }
                        }
                    }
                    if (parent) {
                        parent.replaceChild(newNode, oldNode);
                    }
                    element[0] = newNode;
                }
            }];
    }

    var PREFIX_REGEXP = /^(x[\:\-_]|data[\:\-_])/i;
    /**
     * Converts all accepted directives format into proper directive name.
     * All of these will become 'myDirective':
     *   my:DiRective
     *   my-directive
     *   x-my-directive
     *   data-my:directive
     *
     * Also there is special case for Moz prefix starting with upper case letter.
     * @param name Name to normalize
     */
    function directiveNormalize(name) {
        return camelCase(name.replace(PREFIX_REGEXP, ''));
    }



    /**
     * Closure compiler type information
     */

    function nodesetLinkingFn(
        /* angular.Scope */ scope,
        /* NodeList */ nodeList,
        /* Element */ rootElement,
        /* function(Function) */ boundTranscludeFn
        ){}

    function directiveLinkingFn(
        /* nodesetLinkingFn */ nodesetLinkingFn,
        /* angular.Scope */ scope,
        /* Node */ node,
        /* Element */ rootElement,
        /* function(Function) */ boundTranscludeFn
        ){}

    /**
     * @ngdoc object
     * @name angular.module.ng.$controllerProvider
     * @description
     * The {@link angular.module.ng.$controller $controller service} is used by Angular to create new
     * controllers.
     *
     * This provider allows controller registration via the
     * {@link angular.module.ng.$controllerProvider#register register} method.
     */
    function $ControllerProvider() {
        var controllers = {};


        /**
         * @ngdoc function
         * @name angular.module.ng.$controllerProvider#register
         * @methodOf angular.module.ng.$controllerProvider
         * @param {string} name Controller name
         * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI
         *    annotations in the array notation).
         */
        this.register = function(name, constructor) {
            controllers[name] = constructor;
        };


        this.$get = ['$injector', '$window', function($injector, $window) {

            /**
             * @ngdoc function
             * @name angular.module.ng.$controller
             * @requires $injector
             *
             * @param {Function|string} constructor If called with a function then it's considered to be the
             *    controller constructor function. Otherwise it's considered to be a string which is used
             *    to retrieve the controller constructor using the following steps:
             *
             *    * check if a controller with given name is registered via `$controllerProvider`
             *    * check if evaluating the string on the current scope returns a constructor
             *    * check `window[constructor]` on the global `window` object
             *
             * @param {Object} locals Injection locals for Controller.
             * @return {Object} Instance of given controller.
             *
             * @description
             * `$controller` service is responsible for instantiating controllers.
             *
             * It's just simple call to {@link angular.module.AUTO.$injector $injector}, but extracted into
             * a service, so that one can override this service with {@link https://gist.github.com/1649788
             * BC version}.
             */
            return function(constructor, locals) {
                if(isString(constructor)) {
                    var name = constructor;
                    constructor = controllers.hasOwnProperty(name)
                        ? controllers[name]
                        : getter(locals.$scope, name, true) || getter($window, name, true);

                    assertArgFn(constructor, name, true);
                }

                return $injector.instantiate(constructor, locals);
            };
        }];
    }

    /**
     * @ngdoc function
     * @name angular.module.ng.$defer
     * @requires $browser
     *
     * @description
     * Delegates to {@link angular.module.ng.$browser#defer $browser.defer}, but wraps the `fn` function
     * into a try/catch block and delegates any exceptions to
     * {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.
     *
     * In tests you can use `$browser.defer.flush()` to flush the queue of deferred functions.
     *
     * @param {function()} fn A function, who's execution should be deferred.
     * @param {number=} [delay=0] of milliseconds to defer the function execution.
     * @returns {*} DeferId that can be used to cancel the task via `$defer.cancel()`.
     */

    /**
     * @ngdoc function
     * @name angular.module.ng.$defer#cancel
     * @methodOf angular.module.ng.$defer
     *
     * @description
     * Cancels a defered task identified with `deferId`.
     *
     * @param {*} deferId Token returned by the `$defer` function.
     * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfuly canceled.
     */
    function $DeferProvider(){
        this.$get = ['$rootScope', '$browser', function($rootScope, $browser) {
            function defer(fn, delay) {
                return $browser.defer(function() {
                    $rootScope.$apply(fn);
                }, delay);
            }

            defer.cancel = function(deferId) {
                return $browser.defer.cancel(deferId);
            };

            return defer;
        }];
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$document
     * @requires $window
     *
     * @description
     * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`
     * element.
     */
    function $DocumentProvider(){
        this.$get = ['$window', function(window){
            return jqLite(window.document);
        }];
    }

    /**
     * @ngdoc function
     * @name angular.module.ng.$exceptionHandler
     * @requires $log
     *
     * @description
     * Any uncaught exception in angular expressions is delegated to this service.
     * The default implementation simply delegates to `$log.error` which logs it into
     * the browser console.
     *
     * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by
     * {@link angular.module.ngMock.$exceptionHandler mock $exceptionHandler}
     *
     * @param {Error} exception Exception associated with the error.
     * @param {string=} cause optional information about the context in which
     *       the error was thrown.
     */
    function $ExceptionHandlerProvider() {
        this.$get = ['$log', function($log){
            return function(exception, cause) {
                $log.error.apply($log, arguments);
            };
        }];
    }

    /**
     * @ngdoc function
     * @name angular.module.ng.$interpolateProvider
     * @function
     *
     * @description
     *
     * Used for configuring the interpolation markup. Deafults to `{{` and `}}`.
     */
    function $InterpolateProvider() {
        var startSymbol = '{{';
        var endSymbol = '}}';

        /**
         * @ngdoc method
         * @name angular.module.ng.$interpolateProvider#startSymbol
         * @methodOf angular.module.ng.$interpolateProvider
         * @description
         * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.
         *
         * @prop {string=} value new value to set the starting symbol to.
         */
        this.startSymbol = function(value){
            if (value) {
                startSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };

        /**
         * @ngdoc method
         * @name angular.module.ng.$interpolateProvider#endSymbol
         * @methodOf angular.module.ng.$interpolateProvider
         * @description
         * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.
         *
         * @prop {string=} value new value to set the ending symbol to.
         */
        this.endSymbol = function(value){
            if (value) {
                endSymbol = value;
                return this;
            } else {
                return startSymbol;
            }
        };


        this.$get = ['$parse', function($parse) {
            var startSymbolLength = startSymbol.length,
                endSymbolLength = endSymbol.length;

            /**
             * @ngdoc function
             * @name angular.module.ng.$interpolate
             * @function
             *
             * @requires $parse
             *
             * @description
             *
             * Compiles a string with markup into an interpolation function. This service is used by the
             * HTML {@link angular.module.ng.$compile $compile} service for data binding. See
             * {@link angular.module.ng.$interpolateProvider $interpolateProvider} for configuring the
             * interpolation markup.
             *
             *
             <pre>
             var $interpolate = ...; // injected
             var exp = $interpolate('Hello {{name}}!');
             expect(exp({name:'Angular'}).toEqual('Hello Angular!');
             </pre>
             *
             *
             * @param {string} text The text with markup to interpolate.
             * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have
             *    embedded expression in order to return an interpolation function. Strings with no
             *    embedded expression will return null for the interpolation function.
             * @returns {function(context)} an interpolation function which is used to compute the interpolated
             *    string. The function has these parameters:
             *
             *    * `context`: an object against which any expressions embedded in the strings are evaluated
             *      against.
             *
             */
            return function(text, mustHaveExpression) {
                var startIndex,
                    endIndex,
                    index = 0,
                    parts = [],
                    length = text.length,
                    hasInterpolation = false,
                    fn,
                    exp,
                    concat = [];

                while(index < length) {
                    if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&
                        ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {
                        (index != startIndex) && parts.push(text.substring(index, startIndex));
                        parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));
                        fn.exp = exp;
                        index = endIndex + endSymbolLength;
                        hasInterpolation = true;
                    } else {
                        // we did not find anything, so we have to add the remainder to the parts array
                        (index != length) && parts.push(text.substring(index));
                        index = length;
                    }
                }

                if (!(length = parts.length)) {
                    // we added, nothing, must have been an empty string.
                    parts.push('');
                    length = 1;
                }

                if (!mustHaveExpression  || hasInterpolation) {
                    concat.length = length;
                    fn = function(context) {
                        for(var i = 0, ii = length, part; i<ii; i++) {
                            if (typeof (part = parts[i]) == 'function') {
                                part = part(context);
                                if (part == null || part == undefined) {
                                    part = '';
                                } else if (typeof part != 'string') {
                                    part = toJson(part);
                                }
                            }
                            concat[i] = part;
                        }
                        return concat.join('');
                    };
                    fn.exp = text;
                    fn.parts = parts;
                    return fn;
                }
            };
        }];
    }

    var URL_MATCH = /^(file|ftp|http|https):\/\/(\w+:{0,1}\w*@)?([\w\.-]*)(:([0-9]+))?(\/[^\?#]*)?(\?([^#]*))?(#(.*))?$/,
        PATH_MATCH = /^([^\?#]*)?(\?([^#]*))?(#(.*))?$/,
        HASH_MATCH = PATH_MATCH,
        DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};


    /**
     * Encode path using encodeUriSegment, ignoring forward slashes
     *
     * @param {string} path Path to encode
     * @returns {string}
     */
    function encodePath(path) {
        var segments = path.split('/'),
            i = segments.length;

        while (i--) {
            segments[i] = encodeUriSegment(segments[i]);
        }

        return segments.join('/');
    }


    function matchUrl(url, obj) {
        var match = URL_MATCH.exec(url);

        match = {
            protocol: match[1],
            host: match[3],
            port: int(match[5]) || DEFAULT_PORTS[match[1]] || null,
            path: match[6] || '/',
            search: match[8],
            hash: match[10]
        };

        if (obj) {
            obj.$$protocol = match.protocol;
            obj.$$host = match.host;
            obj.$$port = match.port;
        }

        return match;
    }


    function composeProtocolHostPort(protocol, host, port) {
        return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);
    }


    function pathPrefixFromBase(basePath) {
        return basePath.substr(0, basePath.lastIndexOf('/'));
    }


    function convertToHtml5Url(url, basePath, hashPrefix) {
        var match = matchUrl(url);

        // already html5 url
        if (decodeURIComponent(match.path) != basePath || isUndefined(match.hash) ||
            match.hash.indexOf(hashPrefix) !== 0) {
            return url;
            // convert hashbang url -> html5 url
        } else {
            return composeProtocolHostPort(match.protocol, match.host, match.port) +
                pathPrefixFromBase(basePath) + match.hash.substr(hashPrefix.length);
        }
    }


    function convertToHashbangUrl(url, basePath, hashPrefix) {
        var match = matchUrl(url);

        // already hashbang url
        if (decodeURIComponent(match.path) == basePath) {
            return url;
            // convert html5 url -> hashbang url
        } else {
            var search = match.search && '?' + match.search || '',
                hash = match.hash && '#' + match.hash || '',
                pathPrefix = pathPrefixFromBase(basePath),
                path = match.path.substr(pathPrefix.length);

            if (match.path.indexOf(pathPrefix) !== 0) {
                throw 'Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !';
            }

            return composeProtocolHostPort(match.protocol, match.host, match.port) + basePath +
                '#' + hashPrefix + path + search + hash;
        }
    }


    /**
     * LocationUrl represents an url
     * This object is exposed as $location service when HTML5 mode is enabled and supported
     *
     * @constructor
     * @param {string} url HTML5 url
     * @param {string} pathPrefix
     */
    function LocationUrl(url, pathPrefix) {
        pathPrefix = pathPrefix || '';

        /**
         * Parse given html5 (regular) url string into properties
         * @param {string} url HTML5 url
         * @private
         */
        this.$$parse = function(url) {
            var match = matchUrl(url, this);

            if (match.path.indexOf(pathPrefix) !== 0) {
                throw 'Invalid url "' + url + '", missing path prefix "' + pathPrefix + '" !';
            }

            this.$$path = decodeURIComponent(match.path.substr(pathPrefix.length));
            this.$$search = parseKeyValue(match.search);
            this.$$hash = match.hash && decodeURIComponent(match.hash) || '';

            this.$$compose();
        };

        /**
         * Compose url and update `absUrl` property
         * @private
         */
        this.$$compose = function() {
            var search = toKeyValue(this.$$search),
                hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

            this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
            this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) +
                pathPrefix + this.$$url;
        };

        this.$$parse(url);
    }


    /**
     * LocationHashbangUrl represents url
     * This object is exposed as $location service when html5 history api is disabled or not supported
     *
     * @constructor
     * @param {string} url Legacy url
     * @param {string} hashPrefix Prefix for hash part (containing path and search)
     */
    function LocationHashbangUrl(url, hashPrefix) {
        var basePath;

        /**
         * Parse given hashbang url into properties
         * @param {string} url Hashbang url
         * @private
         */
        this.$$parse = function(url) {
            var match = matchUrl(url, this);

            if (match.hash && match.hash.indexOf(hashPrefix) !== 0) {
                throw 'Invalid url "' + url + '", missing hash prefix "' + hashPrefix + '" !';
            }

            basePath = match.path + (match.search ? '?' + match.search : '');
            match = HASH_MATCH.exec((match.hash || '').substr(hashPrefix.length));
            if (match[1]) {
                this.$$path = (match[1].charAt(0) == '/' ? '' : '/') + decodeURIComponent(match[1]);
            } else {
                this.$$path = '';
            }

            this.$$search = parseKeyValue(match[3]);
            this.$$hash = match[5] && decodeURIComponent(match[5]) || '';

            this.$$compose();
        };

        /**
         * Compose hashbang url and update `absUrl` property
         * @private
         */
        this.$$compose = function() {
            var search = toKeyValue(this.$$search),
                hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';

            this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
            this.$$absUrl = composeProtocolHostPort(this.$$protocol, this.$$host, this.$$port) +
                basePath + (this.$$url ? '#' + hashPrefix + this.$$url : '');
        };

        this.$$parse(url);
    }


    LocationUrl.prototype = {

        /**
         * Has any change been replacing ?
         * @private
         */
        $$replace: false,

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#absUrl
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter only.
         *
         * Return full url representation with all segments encoded according to rules specified in
         * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.
         *
         * @return {string}
         */
        absUrl: locationGetter('$$absUrl'),

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#url
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter / setter.
         *
         * Return url (e.g. `/path?a=b#hash`) when called without any parameter.
         *
         * Change path, search and hash, when called with parameter and return `$location`.
         *
         * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)
         * @return {string}
         */
        url: function(url, replace) {
            if (isUndefined(url))
                return this.$$url;

            var match = PATH_MATCH.exec(url);
            if (match[1]) this.path(decodeURIComponent(match[1]));
            if (match[2] || match[1]) this.search(match[3] || '');
            this.hash(match[5] || '', replace);

            return this;
        },

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#protocol
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter only.
         *
         * Return protocol of current url.
         *
         * @return {string}
         */
        protocol: locationGetter('$$protocol'),

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#host
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter only.
         *
         * Return host of current url.
         *
         * @return {string}
         */
        host: locationGetter('$$host'),

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#port
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter only.
         *
         * Return port of current url.
         *
         * @return {Number}
         */
        port: locationGetter('$$port'),

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#path
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter / setter.
         *
         * Return path of current url when called without any parameter.
         *
         * Change path when called with parameter and return `$location`.
         *
         * Note: Path should always begin with forward slash (/), this method will add the forward slash
         * if it is missing.
         *
         * @param {string=} path New path
         * @return {string}
         */
        path: locationGetterSetter('$$path', function(path) {
            return path.charAt(0) == '/' ? path : '/' + path;
        }),

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#search
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter / setter.
         *
         * Return search part (as object) of current url when called without any parameter.
         *
         * Change search part when called with parameter and return `$location`.
         *
         * @param {string|object<string,string>=} search New search params - string or hash object
         * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a
         *    single search parameter. If the value is `null`, the parameter will be deleted.
         *
         * @return {string}
         */
        search: function(search, paramValue) {
            if (isUndefined(search))
                return this.$$search;

            if (isDefined(paramValue)) {
                if (paramValue === null) {
                    delete this.$$search[search];
                } else {
                    this.$$search[search] = encodeUriQuery(paramValue);
                }
            } else {
                this.$$search = isString(search) ? parseKeyValue(search) : search;
            }

            this.$$compose();
            return this;
        },

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#hash
         * @methodOf angular.module.ng.$location
         *
         * @description
         * This method is getter / setter.
         *
         * Return hash fragment when called without any parameter.
         *
         * Change hash fragment when called with parameter and return `$location`.
         *
         * @param {string=} hash New hash fragment
         * @return {string}
         */
        hash: locationGetterSetter('$$hash', identity),

        /**
         * @ngdoc method
         * @name angular.module.ng.$location#replace
         * @methodOf angular.module.ng.$location
         *
         * @description
         * If called, all changes to $location during current `$digest` will be replacing current history
         * record, instead of adding new one.
         */
        replace: function() {
            this.$$replace = true;
            return this;
        }
    };

    LocationHashbangUrl.prototype = inherit(LocationUrl.prototype);

    function locationGetter(property) {
        return function() {
            return this[property];
        };
    }


    function locationGetterSetter(property, preprocess) {
        return function(value) {
            if (isUndefined(value))
                return this[property];

            this[property] = preprocess(value);
            this.$$compose();

            return this;
        };
    }


    /**
     * @ngdoc object
     * @name angular.module.ng.$location
     *
     * @requires $browser
     * @requires $sniffer
     * @requires $document
     *
     * @description
     * The $location service parses the URL in the browser address bar (based on the {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL available to your application. Changes to the URL in the address bar are reflected into $location service and changes to $location are reflected into the browser address bar.
     *
     * **The $location service:**
     *
     * - Exposes the current URL in the browser address bar, so you can
     *   - Watch and observe the URL.
     *   - Change the URL.
     * - Synchronizes the URL with the browser when the user
     *   - Changes the address bar.
     *   - Clicks the back or forward button (or clicks a History link).
     *   - Clicks on a link.
     * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).
     *
     * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular Services: Using $location}
     */

    /**
     * @ngdoc object
     * @name angular.module.ng.$locationProvider
     * @description
     * Use the `$locationProvider` to configure how the application deep linking paths are stored.
     */
    function $LocationProvider(){
        var hashPrefix = '',
            html5Mode = false;

        /**
         * @ngdoc property
         * @name angular.module.ng.$locationProvider#hashPrefix
         * @methodOf angular.module.ng.$locationProvider
         * @description
         * @param {string=} prefix Prefix for hash part (containing path and search)
         * @returns {*} current value if used as getter or itself (chaining) if used as setter
         */
        this.hashPrefix = function(prefix) {
            if (isDefined(prefix)) {
                hashPrefix = prefix;
                return this;
            } else {
                return hashPrefix;
            }
        }

        /**
         * @ngdoc property
         * @name angular.module.ng.$locationProvider#html5Mode
         * @methodOf angular.module.ng.$locationProvider
         * @description
         * @param {string=} mode Use HTML5 strategy if available.
         * @returns {*} current value if used as getter or itself (chaining) if used as setter
         */
        this.html5Mode = function(mode) {
            if (isDefined(mode)) {
                html5Mode = mode;
                return this;
            } else {
                return html5Mode;
            }
        };

        this.$get = ['$rootScope', '$browser', '$sniffer', '$document',
            function( $rootScope,   $browser,   $sniffer,   $document) {
                var currentUrl,
                    basePath = $browser.baseHref() || '/',
                    pathPrefix = pathPrefixFromBase(basePath),
                    initUrl = $browser.url();

                if (html5Mode) {
                    if ($sniffer.history) {
                        currentUrl = new LocationUrl(convertToHtml5Url(initUrl, basePath, hashPrefix), pathPrefix);
                    } else {
                        currentUrl = new LocationHashbangUrl(convertToHashbangUrl(initUrl, basePath, hashPrefix),
                            hashPrefix);
                    }

                    // link rewriting
                    var u = currentUrl,
                        absUrlPrefix = composeProtocolHostPort(u.protocol(), u.host(), u.port()) + pathPrefix;

                    $document.bind('click', function(event) {
                        // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)
                        // currently we open nice url link and redirect then

                        if (event.ctrlKey || event.metaKey || event.which == 2) return;

                        var elm = jqLite(event.target);

                        // traverse the DOM up to find first A tag
                        while (elm.length && lowercase(elm[0].nodeName) !== 'a') {
                            elm = elm.parent();
                        }

                        var href = elm.attr('href');
                        if (!href || isDefined(elm.attr('ng-ext-link')) || elm.attr('target')) return;

                        // remove same domain from full url links (IE7 always returns full hrefs)
                        href = href.replace(absUrlPrefix, '');

                        // link to different domain (or base path)
                        if (href.substr(0, 4) == 'http') return;

                        // remove pathPrefix from absolute links
                        href = href.indexOf(pathPrefix) === 0 ? href.substr(pathPrefix.length) : href;

                        currentUrl.url(href);
                        $rootScope.$apply();
                        event.preventDefault();
                        // hack to work around FF6 bug 684208 when scenario runner clicks on links
                        window.angular['ff-684208-preventDefault'] = true;
                    });
                } else {
                    currentUrl = new LocationHashbangUrl(initUrl, hashPrefix);
                }

                // rewrite hashbang url <> html5 url
                if (currentUrl.absUrl() != initUrl) {
                    $browser.url(currentUrl.absUrl(), true);
                }

                // update $location when $browser url changes
                $browser.onUrlChange(function(newUrl) {
                    if (currentUrl.absUrl() != newUrl) {
                        $rootScope.$evalAsync(function() {
                            currentUrl.$$parse(newUrl);
                        });
                        if (!$rootScope.$$phase) $rootScope.$digest();
                    }
                });

                // update browser
                var changeCounter = 0;
                $rootScope.$watch(function $locationWatch() {
                    if ($browser.url() != currentUrl.absUrl()) {
                        changeCounter++;
                        $rootScope.$evalAsync(function() {
                            $browser.url(currentUrl.absUrl(), currentUrl.$$replace);
                            currentUrl.$$replace = false;
                        });
                    }

                    return changeCounter;
                });

                return currentUrl;
            }];
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$log
     * @requires $window
     *
     * @description
     * Simple service for logging. Default implementation writes the message
     * into the browser's console (if present).
     *
     * The main purpose of this service is to simplify debugging and troubleshooting.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function LogCtrl($log) {
     this.$log = $log;
     this.message = 'Hello World!';
     }
     </script>
     <div ng-controller="LogCtrl">
     <p>Reload this page with open console, enter text and hit the log button...</p>
     Message:
     <input type="text" ng-model="message"/>
     <button ng-click="$log.log(message)">log</button>
     <button ng-click="$log.warn(message)">warn</button>
     <button ng-click="$log.info(message)">info</button>
     <button ng-click="$log.error(message)">error</button>
     </div>
     </doc:source>
     <doc:scenario>
     </doc:scenario>
     </doc:example>
     */

    function $LogProvider(){
        this.$get = ['$window', function($window){
            return {
                /**
                 * @ngdoc method
                 * @name angular.module.ng.$log#log
                 * @methodOf angular.module.ng.$log
                 *
                 * @description
                 * Write a log message
                 */
                log: consoleLog('log'),

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$log#warn
                 * @methodOf angular.module.ng.$log
                 *
                 * @description
                 * Write a warning message
                 */
                warn: consoleLog('warn'),

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$log#info
                 * @methodOf angular.module.ng.$log
                 *
                 * @description
                 * Write an information message
                 */
                info: consoleLog('info'),

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$log#error
                 * @methodOf angular.module.ng.$log
                 *
                 * @description
                 * Write an error message
                 */
                error: consoleLog('error')
            };

            function formatError(arg) {
                if (arg instanceof Error) {
                    if (arg.stack) {
                        arg = (arg.message && arg.stack.indexOf(arg.message) === -1)
                            ? 'Error: ' + arg.message + '\n' + arg.stack
                            : arg.stack;
                    } else if (arg.sourceURL) {
                        arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
                    }
                }
                return arg;
            }

            function consoleLog(type) {
                var console = $window.console || {},
                    logFn = console[type] || console.log || noop;

                if (logFn.apply) {
                    return function() {
                        var args = [];
                        forEach(arguments, function(arg) {
                            args.push(formatError(arg));
                        });
                        return logFn.apply(console, args);
                    };
                }

                // we are IE which either doesn't have window.console => this is noop and we do nothing,
                // or we are IE where console.log doesn't have apply so we log at least first 2 args
                return function(arg1, arg2) {
                    logFn(arg1, arg2);
                }
            }
        }];
    }

    var OPERATORS = {
        'null':function(){return null;},
        'true':function(){return true;},
        'false':function(){return false;},
        undefined:noop,
        '+':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)+(isDefined(b)?b:0);},
        '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},
        '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},
        '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},
        '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},
        '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},
        '=':noop,
        '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},
        '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},
        '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},
        '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},
        '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},
        '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},
        '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},
        '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},
        '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},
//    '|':function(self, locals, a,b){return a|b;},
        '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},
        '!':function(self, locals, a){return !a(self, locals);}
    };
    var ESCAPE = {"n":"\n", "f":"\f", "r":"\r", "t":"\t", "v":"\v", "'":"'", '"':'"'};

    function lex(text){
        var tokens = [],
            token,
            index = 0,
            json = [],
            ch,
            lastCh = ':'; // can start regexp

        while (index < text.length) {
            ch = text.charAt(index);
            if (is('"\'')) {
                readString(ch);
            } else if (isNumber(ch) || is('.') && isNumber(peek())) {
                readNumber();
            } else if (isIdent(ch)) {
                readIdent();
                // identifiers can only be if the preceding char was a { or ,
                if (was('{,') && json[0]=='{' &&
                    (token=tokens[tokens.length-1])) {
                    token.json = token.text.indexOf('.') == -1;
                }
            } else if (is('(){}[].,;:')) {
                tokens.push({
                    index:index,
                    text:ch,
                    json:(was(':[,') && is('{[')) || is('}]:,')
                });
                if (is('{[')) json.unshift(ch);
                if (is('}]')) json.shift();
                index++;
            } else if (isWhitespace(ch)) {
                index++;
                continue;
            } else {
                var ch2 = ch + peek(),
                    fn = OPERATORS[ch],
                    fn2 = OPERATORS[ch2];
                if (fn2) {
                    tokens.push({index:index, text:ch2, fn:fn2});
                    index += 2;
                } else if (fn) {
                    tokens.push({index:index, text:ch, fn:fn, json: was('[,:') && is('+-')});
                    index += 1;
                } else {
                    throwError("Unexpected next character ", index, index+1);
                }
            }
            lastCh = ch;
        }
        return tokens;

        function is(chars) {
            return chars.indexOf(ch) != -1;
        }

        function was(chars) {
            return chars.indexOf(lastCh) != -1;
        }

        function peek() {
            return index + 1 < text.length ? text.charAt(index + 1) : false;
        }
        function isNumber(ch) {
            return '0' <= ch && ch <= '9';
        }
        function isWhitespace(ch) {
            return ch == ' ' || ch == '\r' || ch == '\t' ||
                ch == '\n' || ch == '\v' || ch == '\u00A0'; // IE treats non-breaking space as \u00A0
        }
        function isIdent(ch) {
            return 'a' <= ch && ch <= 'z' ||
                'A' <= ch && ch <= 'Z' ||
                '_' == ch || ch == '$';
        }
        function isExpOperator(ch) {
            return ch == '-' || ch == '+' || isNumber(ch);
        }

        function throwError(error, start, end) {
            end = end || index;
            throw Error("Lexer Error: " + error + " at column" +
                (isDefined(start)
                    ? "s " + start +  "-" + index + " [" + text.substring(start, end) + "]"
                    : " " + end) +
                " in expression [" + text + "].");
        }

        function readNumber() {
            var number = "";
            var start = index;
            while (index < text.length) {
                var ch = lowercase(text.charAt(index));
                if (ch == '.' || isNumber(ch)) {
                    number += ch;
                } else {
                    var peekCh = peek();
                    if (ch == 'e' && isExpOperator(peekCh)) {
                        number += ch;
                    } else if (isExpOperator(ch) &&
                        peekCh && isNumber(peekCh) &&
                        number.charAt(number.length - 1) == 'e') {
                        number += ch;
                    } else if (isExpOperator(ch) &&
                        (!peekCh || !isNumber(peekCh)) &&
                        number.charAt(number.length - 1) == 'e') {
                        throwError('Invalid exponent');
                    } else {
                        break;
                    }
                }
                index++;
            }
            number = 1 * number;
            tokens.push({index:start, text:number, json:true,
                fn:function() {return number;}});
        }
        function readIdent() {
            var ident = "",
                start = index,
                lastDot, peekIndex, methodName;

            while (index < text.length) {
                var ch = text.charAt(index);
                if (ch == '.' || isIdent(ch) || isNumber(ch)) {
                    if (ch == '.') lastDot = index;
                    ident += ch;
                } else {
                    break;
                }
                index++;
            }

            //check if this is not a method invocation and if it is back out to last dot
            if (lastDot) {
                peekIndex = index
                while(peekIndex < text.length) {
                    var ch = text.charAt(peekIndex);
                    if (ch == '(') {
                        methodName = ident.substr(lastDot - start + 1);
                        ident = ident.substr(0, lastDot - start);
                        index = peekIndex;
                        break;
                    }
                    if(isWhitespace(ch)) {
                        peekIndex++;
                    } else {
                        break;
                    }
                }
            }


            var token = {
                index:start,
                text:ident
            };

            if (OPERATORS.hasOwnProperty(ident)) {
                token.fn = token.json = OPERATORS[ident];
            } else {
                var getter = getterFn(ident);
                token.fn = extend(function(self, locals) {
                    return (getter(self, locals));
                }, {
                    assign: function(self, value) {
                        return setter(self, ident, value);
                    }
                });
            }

            tokens.push(token);

            if (methodName) {
                tokens.push({
                    index:lastDot,
                    text: '.',
                    json: false
                });
                tokens.push({
                    index: lastDot + 1,
                    text: methodName,
                    json: false
                });
            }
        }

        function readString(quote) {
            var start = index;
            index++;
            var string = "";
            var rawString = quote;
            var escape = false;
            while (index < text.length) {
                var ch = text.charAt(index);
                rawString += ch;
                if (escape) {
                    if (ch == 'u') {
                        var hex = text.substring(index + 1, index + 5);
                        if (!hex.match(/[\da-f]{4}/i))
                            throwError( "Invalid unicode escape [\\u" + hex + "]");
                        index += 4;
                        string += String.fromCharCode(parseInt(hex, 16));
                    } else {
                        var rep = ESCAPE[ch];
                        if (rep) {
                            string += rep;
                        } else {
                            string += ch;
                        }
                    }
                    escape = false;
                } else if (ch == '\\') {
                    escape = true;
                } else if (ch == quote) {
                    index++;
                    tokens.push({
                        index:start,
                        text:rawString,
                        string:string,
                        json:true,
                        fn:function() { return string; }
                    });
                    return;
                } else {
                    string += ch;
                }
                index++;
            }
            throwError("Unterminated quote", start);
        }
    }

/////////////////////////////////////////

    function parser(text, json, $filter){
        var ZERO = valueFn(0),
            value,
            tokens = lex(text),
            assignment = _assignment,
            functionCall = _functionCall,
            fieldAccess = _fieldAccess,
            objectIndex = _objectIndex,
            filterChain = _filterChain
        if(json){
            // The extra level of aliasing is here, just in case the lexer misses something, so that
            // we prevent any accidental execution in JSON.
            assignment = logicalOR;
            functionCall =
                fieldAccess =
                    objectIndex =
                        filterChain =
                            function() { throwError("is not valid json", {text:text, index:0}); };
            value = primary();
        } else {
            value = statements();
        }
        if (tokens.length !== 0) {
            throwError("is an unexpected token", tokens[0]);
        }
        return value;

        ///////////////////////////////////
        function throwError(msg, token) {
            throw Error("Syntax Error: Token '" + token.text +
                "' " + msg + " at column " +
                (token.index + 1) + " of the expression [" +
                text + "] starting at [" + text.substring(token.index) + "].");
        }

        function peekToken() {
            if (tokens.length === 0)
                throw Error("Unexpected end of expression: " + text);
            return tokens[0];
        }

        function peek(e1, e2, e3, e4) {
            if (tokens.length > 0) {
                var token = tokens[0];
                var t = token.text;
                if (t==e1 || t==e2 || t==e3 || t==e4 ||
                    (!e1 && !e2 && !e3 && !e4)) {
                    return token;
                }
            }
            return false;
        }

        function expect(e1, e2, e3, e4){
            var token = peek(e1, e2, e3, e4);
            if (token) {
                if (json && !token.json) {
                    throwError("is not valid json", token);
                }
                tokens.shift();
                return token;
            }
            return false;
        }

        function consume(e1){
            if (!expect(e1)) {
                throwError("is unexpected, expecting [" + e1 + "]", peek());
            }
        }

        function unaryFn(fn, right) {
            return function(self, locals) {
                return fn(self, locals, right);
            };
        }

        function binaryFn(left, fn, right) {
            return function(self, locals) {
                return fn(self, locals, left, right);
            };
        }

        function hasTokens () {
            return tokens.length > 0;
        }

        function statements() {
            var statements = [];
            while(true) {
                if (tokens.length > 0 && !peek('}', ')', ';', ']'))
                    statements.push(filterChain());
                if (!expect(';')) {
                    // optimize for the common case where there is only one statement.
                    // TODO(size): maybe we should not support multiple statements?
                    return statements.length == 1
                        ? statements[0]
                        : function(self, locals){
                        var value;
                        for ( var i = 0; i < statements.length; i++) {
                            var statement = statements[i];
                            if (statement)
                                value = statement(self, locals);
                        }
                        return value;
                    };
                }
            }
        }

        function _filterChain() {
            var left = expression();
            var token;
            while(true) {
                if ((token = expect('|'))) {
                    left = binaryFn(left, token.fn, filter());
                } else {
                    return left;
                }
            }
        }

        function filter() {
            var token = expect();
            var fn = $filter(token.text);
            var argsFn = [];
            while(true) {
                if ((token = expect(':'))) {
                    argsFn.push(expression());
                } else {
                    var fnInvoke = function(self, locals, input){
                        var args = [input];
                        for ( var i = 0; i < argsFn.length; i++) {
                            args.push(argsFn[i](self, locals));
                        }
                        return fn.apply(self, args);
                    };
                    return function() {
                        return fnInvoke;
                    };
                }
            }
        }

        function expression() {
            return assignment();
        }

        function _assignment() {
            var left = logicalOR();
            var right;
            var token;
            if ((token = expect('='))) {
                if (!left.assign) {
                    throwError("implies assignment but [" +
                        text.substring(0, token.index) + "] can not be assigned to", token);
                }
                right = logicalOR();
                return function(self, locals){
                    return left.assign(self, right(self, locals), locals);
                };
            } else {
                return left;
            }
        }

        function logicalOR() {
            var left = logicalAND();
            var token;
            while(true) {
                if ((token = expect('||'))) {
                    left = binaryFn(left, token.fn, logicalAND());
                } else {
                    return left;
                }
            }
        }

        function logicalAND() {
            var left = equality();
            var token;
            if ((token = expect('&&'))) {
                left = binaryFn(left, token.fn, logicalAND());
            }
            return left;
        }

        function equality() {
            var left = relational();
            var token;
            if ((token = expect('==','!='))) {
                left = binaryFn(left, token.fn, equality());
            }
            return left;
        }

        function relational() {
            var left = additive();
            var token;
            if ((token = expect('<', '>', '<=', '>='))) {
                left = binaryFn(left, token.fn, relational());
            }
            return left;
        }

        function additive() {
            var left = multiplicative();
            var token;
            while ((token = expect('+','-'))) {
                left = binaryFn(left, token.fn, multiplicative());
            }
            return left;
        }

        function multiplicative() {
            var left = unary();
            var token;
            while ((token = expect('*','/','%'))) {
                left = binaryFn(left, token.fn, unary());
            }
            return left;
        }

        function unary() {
            var token;
            if (expect('+')) {
                return primary();
            } else if ((token = expect('-'))) {
                return binaryFn(ZERO, token.fn, unary());
            } else if ((token = expect('!'))) {
                return unaryFn(token.fn, unary());
            } else {
                return primary();
            }
        }

        function _functionIdent(fnScope) {
            var token = expect();
            var element = token.text.split('.');
            var instance = fnScope;
            var key;
            for ( var i = 0; i < element.length; i++) {
                key = element[i];
                if (instance)
                    instance = instance[key];
            }
            if (!isFunction(instance)) {
                throwError("should be a function", token);
            }
            return instance;
        }

        function primary() {
            var primary;
            if (expect('(')) {
                primary = filterChain();
                consume(')');
            } else if (expect('[')) {
                primary = arrayDeclaration();
            } else if (expect('{')) {
                primary = object();
            } else {
                var token = expect();
                primary = token.fn;
                if (!primary) {
                    throwError("not a primary expression", token);
                }
            }

            var next, context;
            while ((next = expect('(', '[', '.'))) {
                if (next.text === '(') {
                    primary = functionCall(primary, context);
                    context = null;
                } else if (next.text === '[') {
                    context = primary;
                    primary = objectIndex(primary);
                } else if (next.text === '.') {
                    context = primary;
                    primary = fieldAccess(primary);
                } else {
                    throwError("IMPOSSIBLE");
                }
            }
            return primary;
        }

        function _fieldAccess(object) {
            var field = expect().text;
            var getter = getterFn(field);
            return extend(
                function(self, locals) {
                    return getter(object(self, locals), locals);
                },
                {
                    assign:function(self, value, locals) {
                        return setter(object(self, locals), field, value);
                    }
                }
            );
        }

        function _objectIndex(obj) {
            var indexFn = expression();
            consume(']');
            return extend(
                function(self, locals){
                    var o = obj(self, locals),
                        i = indexFn(self, locals),
                        v, p;

                    if (!o) return undefined;
                    v = o[i];
                    if (v && v.then) {
                        p = v;
                        if (!('$$v' in v)) {
                            p.$$v = undefined;
                            p.then(function(val) { p.$$v = val; });
                        }
                        v = v.$$v;
                    }
                    return v;
                }, {
                    assign:function(self, value, locals){
                        return obj(self, locals)[indexFn(self, locals)] = value;
                    }
                });
        }

        function _functionCall(fn, contextGetter) {
            var argsFn = [];
            if (peekToken().text != ')') {
                do {
                    argsFn.push(expression());
                } while (expect(','));
            }
            consume(')');
            return function(self, locals){
                var args = [],
                    context = contextGetter ? contextGetter(self, locals) : self;

                for ( var i = 0; i < argsFn.length; i++) {
                    args.push(argsFn[i](self, locals));
                }
                var fnPtr = fn(self, locals) || noop;
                // IE stupidity!
                return fnPtr.apply
                    ? fnPtr.apply(context, args)
                    : fnPtr(args[0], args[1], args[2], args[3], args[4]);
            };
        }

        // This is used with json array declaration
        function arrayDeclaration () {
            var elementFns = [];
            if (peekToken().text != ']') {
                do {
                    elementFns.push(expression());
                } while (expect(','));
            }
            consume(']');
            return function(self, locals){
                var array = [];
                for ( var i = 0; i < elementFns.length; i++) {
                    array.push(elementFns[i](self, locals));
                }
                return array;
            };
        }

        function object () {
            var keyValues = [];
            if (peekToken().text != '}') {
                do {
                    var token = expect(),
                        key = token.string || token.text;
                    consume(":");
                    var value = expression();
                    keyValues.push({key:key, value:value});
                } while (expect(','));
            }
            consume('}');
            return function(self, locals){
                var object = {};
                for ( var i = 0; i < keyValues.length; i++) {
                    var keyValue = keyValues[i];
                    var value = keyValue.value(self, locals);
                    object[keyValue.key] = value;
                }
                return object;
            };
        }
    }

//////////////////////////////////////////////////
// Parser helper functions
//////////////////////////////////////////////////

    function setter(obj, path, setValue) {
        var element = path.split('.');
        for (var i = 0; element.length > 1; i++) {
            var key = element.shift();
            var propertyObj = obj[key];
            if (!propertyObj) {
                propertyObj = {};
                obj[key] = propertyObj;
            }
            obj = propertyObj;
        }
        obj[element.shift()] = setValue;
        return setValue;
    }

    /**
     * Return the value accesible from the object by path. Any undefined traversals are ignored
     * @param {Object} obj starting object
     * @param {string} path path to traverse
     * @param {boolean=true} bindFnToScope
     * @returns value as accesbile by path
     */
//TODO(misko): this function needs to be removed
    function getter(obj, path, bindFnToScope) {
        if (!path) return obj;
        var keys = path.split('.');
        var key;
        var lastInstance = obj;
        var len = keys.length;

        for (var i = 0; i < len; i++) {
            key = keys[i];
            if (obj) {
                obj = (lastInstance = obj)[key];
            }
        }
        if (!bindFnToScope && isFunction(obj)) {
            return bind(lastInstance, obj);
        }
        return obj;
    }

    var getterFnCache = {};

    function getterFn(path) {
        if (getterFnCache.hasOwnProperty(path)) {
            return getterFnCache[path];
        }

        var fn, code = 'var l, fn, p;\n';
        forEach(path.split('.'), function(key, index) {
            code += 'if(!s) return s;\n' +
                'l=s;\n' +
                's='+ (index
                // we simply direference 's' on any .dot notation
                ? 's'
                // but if we are first then we check locals firs, and if so read it first
                : '((k&&k.hasOwnProperty("' + key + '"))?k:s)') + '["' + key + '"]' + ';\n' +
                'if (s && s.then) {\n' +
                ' if (!("$$v" in s)) {\n' +
                ' p=s;\n' +
                ' p.$$v = undefined;\n' +
                ' p.then(function(v) {p.$$v=v;});\n' +
                '}\n' +
                ' s=s.$$v\n' +
                '}\n';
        });
        code += 'return s;';
        fn = Function('s', 'k', code);
        fn.toString = function() { return code; };

        return getterFnCache[path] = fn;
    }

///////////////////////////////////

    function $ParseProvider() {
        var cache = {};
        this.$get = ['$filter', function($filter) {
            return function(exp) {
                switch(typeof exp) {
                    case 'string':
                        return cache.hasOwnProperty(exp)
                            ? cache[exp]
                            : cache[exp] =  parser(exp, false, $filter);
                    case 'function':
                        return exp;
                    default:
                        return noop;
                }
            };
        }];
    }

    /**
     * @ngdoc service
     * @name angular.module.ng.$q
     * @requires $rootScope
     *
     * @description
     * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).
     *
     * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an
     * interface for interacting with an object that represents the result of an action that is
     * performed asynchronously, and may or may not be finished at any given point in time.
     *
     * From the perspective of dealing with error handling, deferred and promise apis are to
     * asynchronous programing what `try`, `catch` and `throw` keywords are to synchronous programing.
     *
     * <pre>
     *   // for the purpose of this example let's assume that variables `$q` and `scope` are
     *   // available in the current lexical scope (they could have been injected or passed in).
     *
     *   function asyncGreet(name) {
     *     var deferred = $q.defer();
     *
     *     setTimeout(function() {
     *       // since this fn executes async in a future turn of the event loop, we need to wrap
     *       // our code into an $apply call so that the model changes are properly observed.
     *       scope.$apply(function() {
     *         if (okToGreet(name)) {
     *           deferred.resolve('Hello, ' + name + '!');
     *         } else {
     *           deferred.reject('Greeting ' + name + ' is not allowed.');
     *         }
     *       });
     *     }, 1000);
     *
     *     return deferred.promise;
     *   }
     *
     *   var promise = asyncGreet('Robin Hood');
     *   promise.then(function(greeting) {
     *     alert('Success: ' + greeting);
     *   }, function(reason) {
     *     alert('Failed: ' + reason);
     *   );
     * </pre>
     *
     * At first it might not be obvious why this extra complexity is worth the trouble. The payoff
     * comes in the way of
     * [guarantees that promise and deferred apis make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).
     *
     * Additionally the promise api allows for composition that is very hard to do with the
     * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.
     * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the
     * section on serial or parallel joining of promises.
     *
     *
     * # The Deferred API
     *
     * A new instance of deferred is constructed by calling `$q.defer()`.
     *
     * The purpose of the deferred object is to expose the associated Promise instance as well as apis
     * that can be used for signaling the successful or unsuccessful completion of the task.
     *
     * **Methods**
     *
     * - `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection
     *   constructed via `$q.reject`, the promise will be rejected instead.
     * - `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to
     *   resolving it with a rejection constructed via `$q.reject`.
     *
     * **Properties**
     *
     * - promise – `{Promise}` – promise object associated with this deferred.
     *
     *
     * # The Promise API
     *
     * A new promise instance is created when a deferred instance is created and can be retrieved by
     * calling `deferred.promise`.
     *
     * The purpose of the promise object is to allow for interested parties to get access to the result
     * of the deferred task when it completes.
     *
     * **Methods**
     *
     * - `then(successCallback, errorCallback)` – regardless of when the promise was or will be resolved
     *   or rejected calls one of the success or error callbacks asynchronously as soon as the result
     *   is available. The callbacks are called with a single argument the result or rejection reason.
     *
     *   This method *returns a new promise* which is resolved or rejected via the return value of the
     *   `successCallback` or `errorCallback`.
     *
     *
     * # Chaining promises
     *
     * Because calling `then` api of a promise returns a new derived promise, it is easily possible
     * to create a chain of promises:
     *
     * <pre>
     *   promiseB = promiseA.then(function(result) {
     *     return result + 1;
     *   });
     *
     *   // promiseB will be resolved immediately after promiseA is resolved and it's value will be
     *   // the result of promiseA incremented by 1
     * </pre>
     *
     * It is possible to create chains of any length and since a promise can be resolved with another
     * promise (which will defer its resolution further), it is possible to pause/defer resolution of
     * the promises at any point in the chain. This makes it possible to implement powerful apis like
     * $http's response interceptors.
     *
     *
     * # Differences between Kris Kowal's Q and $q
     *
     *  There are three main differences:
     *
     * - $q is integrated with the {@link angular.module.ng.$rootScope.Scope} Scope model observation
     *   mechanism in angular, which means faster propagation of resolution or rejection into your
     *   models and avoiding unnecessary browser repaints, which would result in flickering UI.
     * - $q promises are recognized by the templating engine in angular, which means that in templates
     *   you can treat promises attached to a scope as if they were the resulting values.
     * - Q has many more features that $q, but that comes at a cost of bytes. $q is tiny, but contains
     *   all the important functionality needed for common async tasks.
     */
    function $QProvider() {

        this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {
            return qFactory(function(callback) {
                $rootScope.$evalAsync(callback);
            }, $exceptionHandler);
        }];
    }


    /**
     * Constructs a promise manager.
     *
     * @param {function(function)} nextTick Function for executing functions in the next turn.
     * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for
     *     debugging purposes.
     * @returns {object} Promise manager.
     */
    function qFactory(nextTick, exceptionHandler) {

        /**
         * @ngdoc
         * @name angular.module.ng.$q#defer
         * @methodOf angular.module.ng.$q
         * @description
         * Creates a `Deferred` object which represents a task which will finish in the future.
         *
         * @returns {Deferred} Returns a new instance of deferred.
         */
        var defer = function() {
            var pending = [],
                value, deferred;

            deferred = {

                resolve: function(val) {
                    if (pending) {
                        var callbacks = pending;
                        pending = undefined;
                        value = ref(val);

                        if (callbacks.length) {
                            nextTick(function() {
                                var callback;
                                for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                    callback = callbacks[i];
                                    value.then(callback[0], callback[1]);
                                }
                            });
                        }
                    }
                },


                reject: function(reason) {
                    deferred.resolve(reject(reason));
                },


                promise: {
                    then: function(callback, errback) {
                        var result = defer();

                        var wrappedCallback = function(value) {
                            try {
                                result.resolve((callback || defaultCallback)(value));
                            } catch(e) {
                                exceptionHandler(e);
                                result.reject(e);
                            }
                        };

                        var wrappedErrback = function(reason) {
                            try {
                                result.resolve((errback || defaultErrback)(reason));
                            } catch(e) {
                                exceptionHandler(e);
                                result.reject(e);
                            }
                        };

                        if (pending) {
                            pending.push([wrappedCallback, wrappedErrback]);
                        } else {
                            value.then(wrappedCallback, wrappedErrback);
                        }

                        return result.promise;
                    }
                }
            };

            return deferred;
        };


        var ref = function(value) {
            if (value && value.then) return value;
            return {
                then: function(callback) {
                    var result = defer();
                    nextTick(function() {
                        result.resolve(callback(value));
                    });
                    return result.promise;
                }
            };
        };


        /**
         * @ngdoc
         * @name angular.module.ng.$q#reject
         * @methodOf angular.module.ng.$q
         * @description
         * Creates a promise that is resolved as rejected with the specified `reason`. This api should be
         * used to forward rejection in a chain of promises. If you are dealing with the last promise in
         * a promise chain, you don't need to worry about it.
         *
         * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of
         * `reject` as the `throw` keyword in JavaScript. This also means that if you "catch" an error via
         * a promise error callback and you want to forward the error to the promise derived from the
         * current promise, you have to "rethrow" the error by returning a rejection constructed via
         * `reject`.
         *
         * <pre>
         *   promiseB = promiseA.then(function(result) {
         *     // success: do something and resolve promiseB
         *     //          with the old or a new result
         *     return result;
         *   }, function(reason) {
         *     // error: handle the error if possible and
         *     //        resolve promiseB with newPromiseOrValue,
         *     //        otherwise forward the rejection to promiseB
         *     if (canHandle(reason)) {
         *      // handle the error and recover
         *      return newPromiseOrValue;
         *     }
         *     return $q.reject(reason);
         *   });
         * </pre>
         *
         * @param {*} reason Constant, message, exception or an object representing the rejection reason.
         * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.
         */
        var reject = function(reason) {
            return {
                then: function(callback, errback) {
                    var result = defer();
                    nextTick(function() {
                        result.resolve(errback(reason));
                    });
                    return result.promise;
                }
            };
        };


        /**
         * @ngdoc
         * @name angular.module.ng.$q#when
         * @methodOf angular.module.ng.$q
         * @description
         * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.
         * This is useful when you are dealing with on object that might or might not be a promise, or if
         * the promise comes from a source that can't be trusted.
         *
         * @param {*} value Value or a promise
         * @returns {Promise} Returns a single promise that will be resolved with an array of values,
         *   each value coresponding to the promise at the same index in the `promises` array. If any of
         *   the promises is resolved with a rejection, this resulting promise will be resolved with the
         *   same rejection.
         */
        var when = function(value, callback, errback) {
            var result = defer(),
                done;

            var wrappedCallback = function(value) {
                try {
                    return (callback || defaultCallback)(value);
                } catch (e) {
                    exceptionHandler(e);
                    return reject(e);
                }
            };

            var wrappedErrback = function(reason) {
                try {
                    return (errback || defaultErrback)(reason);
                } catch (e) {
                    exceptionHandler(e);
                    return reject(e);
                }
            };

            nextTick(function() {
                ref(value).then(function(value) {
                    if (done) return;
                    done = true;
                    result.resolve(ref(value).then(wrappedCallback, wrappedErrback));
                }, function(reason) {
                    if (done) return;
                    done = true;
                    result.resolve(wrappedErrback(reason));
                });
            });

            return result.promise;
        };


        function defaultCallback(value) {
            return value;
        }


        function defaultErrback(reason) {
            return reject(reason);
        }


        /**
         * @ngdoc
         * @name angular.module.ng.$q#all
         * @methodOf angular.module.ng.$q
         * @description
         * Combines multiple promises into a single promise that is resolved when all of the input
         * promises are resolved.
         *
         * @param {Array.<Promise>} promises An array of promises.
         * @returns {Promise} Returns a single promise that will be resolved with an array of values,
         *   each value coresponding to the promise at the same index in the `promises` array. If any of
         *   the promises is resolved with a rejection, this resulting promise will be resolved with the
         *   same rejection.
         */
        function all(promises) {
            var deferred = defer(),
                counter = promises.length,
                results = [];

            if (counter) {
                forEach(promises, function(promise, index) {
                    ref(promise).then(function(value) {
                        if (index in results) return;
                        results[index] = value;
                        if (!(--counter)) deferred.resolve(results);
                    }, function(reason) {
                        if (index in results) return;
                        deferred.reject(reason);
                    });
                });
            } else {
                deferred.resolve(results);
            }

            return deferred.promise;
        }

        return {
            defer: defer,
            reject: reject,
            when: when,
            all: all
        };
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$routeProvider
     * @function
     *
     * @description
     *
     * Used for configuring routes. See {@link angular.module.ng.$route $route} for an example.
     */
    function $RouteProvider(){
        var routes = {};

        /**
         * @ngdoc method
         * @name angular.module.ng.$routeProvider#when
         * @methodOf angular.module.ng.$routeProvider
         *
         * @param {string} path Route path (matched against `$location.path`). If `$location.path`
         *    contains redudant trailing slash or is missing one, the route will still match and the
         *    `$location.path` will be updated to add or drop the trailing slash to exacly match the
         *    route definition.
         * @param {Object} route Mapping information to be assigned to `$route.current` on route
         *    match.
         *
         *    Object properties:
         *
         *    - `controller` – `{function()=}` – Controller fn that should be associated with newly
         *      created scope.
         *    - `template` – `{string=}` – path to an html template that should be used by
         *      {@link angular.module.ng.$compileProvider.directive.ng-view ng-view} or
         *      {@link angular.module.ng.$compileProvider.directive.ng-include ng-include} directives.
         *    - `redirectTo` – {(string|function())=} – value to update
         *      {@link angular.module.ng.$location $location} path with and trigger route redirection.
         *
         *      If `redirectTo` is a function, it will be called with the following parameters:
         *
         *      - `{Object.<string>}` - route parameters extracted from the current
         *        `$location.path()` by applying the current route template.
         *      - `{string}` - current `$location.path()`
         *      - `{Object}` - current `$location.search()`
         *
         *      The custom `redirectTo` function is expected to return a string which will be used
         *      to update `$location.path()` and `$location.search()`.
         *
         *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()
         *    changes.
         *
         *      If the option is set to `false` and url in the browser changes, then
         *      `$routeUpdate` event is broadcasted on the root scope.
         *
         * @returns {Object} route object
         *
         * @description
         * Adds a new route definition to the `$route` service.
         */
        this.when = function(path, route) {
            var routeDef = routes[path];
            if (!routeDef) routeDef = routes[path] = {reloadOnSearch: true};
            if (route) extend(routeDef, route); // TODO(im): what the heck? merge two route definitions?

            // create redirection for trailing slashes
            if (path) {
                var redirectPath = (path[path.length-1] == '/')
                    ? path.substr(0, path.length-1)
                    : path +'/';

                routes[redirectPath] = {redirectTo: path};
            }

            return routeDef;
        };

        /**
         * @ngdoc method
         * @name angular.module.ng.$routeProvider#otherwise
         * @methodOf angular.module.ng.$routeProvider
         *
         * @description
         * Sets route definition that will be used on route change when no other route definition
         * is matched.
         *
         * @param {Object} params Mapping information to be assigned to `$route.current`.
         */
        this.otherwise = function(params) {
            this.when(null, params);
        };


        this.$get = ['$rootScope', '$location', '$routeParams',
            function( $rootScope,  $location,  $routeParams) {

                /**
                 * @ngdoc object
                 * @name angular.module.ng.$route
                 * @requires $location
                 * @requires $routeParams
                 *
                 * @property {Object} current Reference to the current route definition.
                 * @property {Array.<Object>} routes Array of all configured routes.
                 *
                 * @description
                 * Is used for deep-linking URLs to controllers and views (HTML partials).
                 * It watches `$location.url()` and tries to map the path to an existing route definition.
                 *
                 * You can define routes through {@link angular.module.ng.$routeProvider $routeProvider}'s API.
                 *
                 * The `$route` service is typically used in conjunction with {@link angular.module.ng.$compileProvider.directive.ng-view ng-view}
                 * directive and the {@link angular.module.ng.$routeParams $routeParams} service.
                 *
                 * @example
                 This example shows how changing the URL hash causes the `$route` to match a route against the
                 URL, and the `ng-view` pulls in the partial.

                 Note that this example is using {@link angular.module.ng.$compileProvider.directive.script inlined templates}
                 to get it working on jsfiddle as well.

                 <doc:example module="route">
                 <doc:source>
                 <script type="text/ng-template" id="examples/book.html">
                 controller: {{name}}<br />
                 Book Id: {{params.bookId}}<br />
                 </script>

                 <script type="text/ng-template" id="examples/chapter.html">
                 controller: {{name}}<br />
                 Book Id: {{params.bookId}}<br />
                 Chapter Id: {{params.chapterId}}
                 </script>

                 <script>
                 angular.module('route', [], function($routeProvider, $locationProvider) {
                 $routeProvider.when('/Book/:bookId', {template: 'examples/book.html', controller: BookCntl});
                 $routeProvider.when('/Book/:bookId/ch/:chapterId', {template: 'examples/chapter.html', controller: ChapterCntl});

                 // configure html5 to get links working on jsfiddle
                 $locationProvider.html5Mode(true);
                 });

                 function MainCntl($scope, $route, $routeParams, $location) {
                 $scope.$route = $route;
                 $scope.$location = $location;
                 $scope.$routeParams = $routeParams;
                 }

                 function BookCntl($scope, $routeParams) {
                 $scope.name = "BookCntl";
                 $scope.params = $routeParams;
                 }

                 function ChapterCntl($scope, $routeParams) {
                 $scope.name = "ChapterCntl";
                 $scope.params = $routeParams;
                 }
                 </script>

                 <div ng-controller="MainCntl">
                 Choose:
                 <a href="/Book/Moby">Moby</a> |
                 <a href="/Book/Moby/ch/1">Moby: Ch1</a> |
                 <a href="/Book/Gatsby">Gatsby</a> |
                 <a href="/Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
                 <a href="/Book/Scarlet">Scarlet Letter</a><br/>

                 <div ng-view></div>
                 <hr />

                 <pre>$location.path() = {{$location.path()}}</pre>
                 <pre>$route.current.template = {{$route.current.template}}</pre>
                 <pre>$route.current.params = {{$route.current.params}}</pre>
                 <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>
                 <pre>$routeParams = {{$routeParams}}</pre>
                 </div>
                 </doc:source>
                 <doc:scenario>
                 it('should load and compile correct template', function() {
                 element('a:contains("Moby: Ch1")').click();
                 var content = element('.doc-example-live [ng-view]').text();
                 expect(content).toMatch(/controller\: ChapterCntl/);
                 expect(content).toMatch(/Book Id\: Moby/);
                 expect(content).toMatch(/Chapter Id\: 1/);

                 element('a:contains("Scarlet")').click();
                 content = element('.doc-example-live [ng-view]').text();
                 expect(content).toMatch(/controller\: BookCntl/);
                 expect(content).toMatch(/Book Id\: Scarlet/);
                 });
                 </doc:scenario>
                 </doc:example>
                 */

                /**
                 * @ngdoc event
                 * @name angular.module.ng.$route#$beforeRouteChange
                 * @eventOf angular.module.ng.$route
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted before a route change.
                 *
                 * @param {Route} next Future route information.
                 * @param {Route} current Current route information.
                 */

                /**
                 * @ngdoc event
                 * @name angular.module.ng.$route#$afterRouteChange
                 * @eventOf angular.module.ng.$route
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted after a route change.
                 *
                 * @param {Route} current Current route information.
                 * @param {Route} previous Previous route information.
                 */

                /**
                 * @ngdoc event
                 * @name angular.module.ng.$route#$routeUpdate
                 * @eventOf angular.module.ng.$route
                 * @eventType broadcast on root scope
                 * @description
                 *
                 * The `reloadOnSearch` property has been set to false, and we are reusing the same
                 * instance of the Controller.
                 */

                var matcher = switchRouteMatcher,
                    dirty = 0,
                    forceReload = false,
                    $route = {
                        routes: routes,

                        /**
                         * @ngdoc method
                         * @name angular.module.ng.$route#reload
                         * @methodOf angular.module.ng.$route
                         *
                         * @description
                         * Causes `$route` service to reload the current route even if
                         * {@link angular.module.ng.$location $location} hasn't changed.
                         *
                         * As a result of that, {@link angular.module.ng.$compileProvider.directive.ng-view ng-view}
                         * creates new scope, reinstantiates the controller.
                         */
                        reload: function() {
                            dirty++;
                            forceReload = true;
                        }
                    };

                $rootScope.$watch(function() { return dirty + $location.url(); }, updateRoute);

                return $route;

                /////////////////////////////////////////////////////

                function switchRouteMatcher(on, when) {
                    // TODO(i): this code is convoluted and inefficient, we should construct the route matching
                    //   regex only once and then reuse it
                    var regex = '^' + when.replace(/([\.\\\(\)\^\$])/g, "\\$1") + '$',
                        params = [],
                        dst = {};
                    forEach(when.split(/\W/), function(param) {
                        if (param) {
                            var paramRegExp = new RegExp(":" + param + "([\\W])");
                            if (regex.match(paramRegExp)) {
                                regex = regex.replace(paramRegExp, "([^\\/]*)$1");
                                params.push(param);
                            }
                        }
                    });
                    var match = on.match(new RegExp(regex));
                    if (match) {
                        forEach(params, function(name, index) {
                            dst[name] = match[index + 1];
                        });
                    }
                    return match ? dst : null;
                }

                function updateRoute() {
                    var next = parseRoute(),
                        last = $route.current;

                    if (next && last && next.$route === last.$route
                        && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {
                        last.params = next.params;
                        copy(last.params, $routeParams);
                        $rootScope.$broadcast('$routeUpdate', last);
                    } else if (next || last) {
                        forceReload = false;
                        $rootScope.$broadcast('$beforeRouteChange', next, last);
                        $route.current = next;
                        if (next) {
                            if (next.redirectTo) {
                                if (isString(next.redirectTo)) {
                                    $location.path(interpolate(next.redirectTo, next.params)).search(next.params)
                                        .replace();
                                } else {
                                    $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))
                                        .replace();
                                }
                            } else {
                                copy(next.params, $routeParams);
                            }
                        }
                        $rootScope.$broadcast('$afterRouteChange', next, last);
                    }
                }


                /**
                 * @returns the current active route, by matching it against the URL
                 */
                function parseRoute() {
                    // Match a route
                    var params, match;
                    forEach(routes, function(route, path) {
                        if (!match && (params = matcher($location.path(), path))) {
                            match = inherit(route, {
                                params: extend({}, $location.search(), params),
                                pathParams: params});
                            match.$route = route;
                        }
                    });
                    // No route matched; fallback to "otherwise" route
                    return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});
                }

                /**
                 * @returns interpolation of the redirect path with the parametrs
                 */
                function interpolate(string, params) {
                    var result = [];
                    forEach((string||'').split(':'), function(segment, i) {
                        if (i == 0) {
                            result.push(segment);
                        } else {
                            var segmentMatch = segment.match(/(\w+)(.*)/);
                            var key = segmentMatch[1];
                            result.push(params[key]);
                            result.push(segmentMatch[2] || '');
                            delete params[key];
                        }
                    });
                    return result.join('');
                }
            }];
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$routeParams
     * @requires $route
     *
     * @description
     * Current set of route parameters. The route parameters are a combination of the
     * {@link angular.module.ng.$location $location} `search()`, and `path()`. The `path` parameters
     * are extracted when the {@link angular.module.ng.$route $route} path is matched.
     *
     * In case of parameter name collision, `path` params take precedence over `search` params.
     *
     * The service guarantees that the identity of the `$routeParams` object will remain unchanged
     * (but its properties will likely change) even when a route change occurs.
     *
     * @example
     * <pre>
     *  // Given:
     *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
     *  // Route: /Chapter/:chapterId/Section/:sectionId
     *  //
     *  // Then
     *  $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}
     * </pre>
     */
    function $RouteParamsProvider() {
        this.$get = valueFn({});
    }

    /**
     * DESIGN NOTES
     *
     * The design decisions behind the scope ware heavily favored for speed and memory consumption.
     *
     * The typical use of scope is to watch the expressions, which most of the time return the same
     * value as last time so we optimize the operation.
     *
     * Closures construction is expensive from speed as well as memory:
     *   - no closures, instead ups prototypical inheritance for API
     *   - Internal state needs to be stored on scope directly, which means that private state is
     *     exposed as $$____ properties
     *
     * Loop operations are optimized by using while(count--) { ... }
     *   - this means that in order to keep the same order of execution as addition we have to add
     *     items to the array at the begging (shift) instead of at the end (push)
     *
     * Child scopes are created and removed often
     *   - Using array would be slow since inserts in meddle are expensive so we use linked list
     *
     * There are few watches then a lot of observers. This is why you don't want the observer to be
     * implemented in the same way as watch. Watch requires return of initialization function which
     * are expensive to construct.
     */


    /**
     * @ngdoc object
     * @name angular.module.ng.$rootScopeProvider
     * @description
     *
     * Provider for the $rootScope service.
     */

    /**
     * @ngdoc function
     * @name angular.module.ng.$rootScopeProvider#digestTtl
     * @methodOf angular.module.ng.$rootScopeProvider
     * @description
     *
     * Sets the number of digest iteration the scope should attempt to execute before giving up and
     * assuming that the model is unstable.
     *
     * The current default is 10 iterations.
     *
     * @param {number} limit The number of digest iterations.
     */


    /**
     * @ngdoc object
     * @name angular.module.ng.$rootScope
     * @description
     *
     * Every application has a single root {@link angular.module.ng.$rootScope.Scope scope}.
     * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide
     * event processing life-cycle. See {@link guide/dev_guide.scopes developer guide on scopes}.
     */
    function $RootScopeProvider(){
        var TTL = 10;

        this.digestTtl = function(value) {
            if (arguments.length) {
                TTL = value;
            }
            return TTL;
        }

        this.$get = ['$injector', '$exceptionHandler', '$parse',
            function( $injector,   $exceptionHandler,   $parse) {

                /**
                 * @ngdoc function
                 * @name angular.module.ng.$rootScope.Scope
                 *
                 * @description
                 * A root scope can be retrieved using the {@link angular.module.ng.$rootScope $rootScope} key from the
                 * {@link angular.module.AUTO.$injector $injector}. Child scopes are created using the
                 * {@link angular.module.ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when
                 * compiled HTML template is executed.)
                 *
                 * Here is a simple scope snippet to show how you can interact with the scope.
                 * <pre>
                 angular.injector(['ng']).invoke(function($rootScope) {
                 var scope = $rootScope.$new();
                 scope.salutation = 'Hello';
                 scope.name = 'World';

                 expect(scope.greeting).toEqual(undefined);

                 scope.$watch('name', function() {
                 this.greeting = this.salutation + ' ' + this.name + '!';
                 }); // initialize the watch

                 expect(scope.greeting).toEqual(undefined);
                 scope.name = 'Misko';
                 // still old value, since watches have not been called yet
                 expect(scope.greeting).toEqual(undefined);

                 scope.$digest(); // fire all  the watches
                 expect(scope.greeting).toEqual('Hello Misko!');
                 });
                 * </pre>
                 *
                 * # Inheritance
                 * A scope can inherit from a parent scope, as in this example:
                 * <pre>
                 var parent = $rootScope;
                 var child = parent.$new();

                 parent.salutation = "Hello";
                 child.name = "World";
                 expect(child.salutation).toEqual('Hello');

                 child.salutation = "Welcome";
                 expect(child.salutation).toEqual('Welcome');
                 expect(parent.salutation).toEqual('Hello');
                 * </pre>
                 *
                 * # Dependency Injection
                 * See {@link guide/dev_guide.di dependency injection}.
                 *
                 *
                 * @param {Object.<string, function()>=} providers Map of service factory which need to be provided
                 *     for the current scope. Defaults to {@link angular.module.ng}.
                 * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should
                 *     append/override services provided by `providers`. This is handy when unit-testing and having
                 *     the need to override a default service.
                 * @returns {Object} Newly created scope.
                 *
                 */
                function Scope() {
                    this.$id = nextUid();
                    this.$$phase = this.$parent = this.$$watchers =
                        this.$$nextSibling = this.$$prevSibling =
                            this.$$childHead = this.$$childTail = null;
                    this['this'] = this.$root =  this;
                    this.$$asyncQueue = [];
                    this.$$listeners = {};
                }

                /**
                 * @ngdoc property
                 * @name angular.module.ng.$rootScope.Scope#$id
                 * @propertyOf angular.module.ng.$rootScope.Scope
                 * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for
                 *   debugging.
                 */


                Scope.prototype = {
                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$new
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Creates a new child {@link angular.module.ng.$rootScope.Scope scope}.
                     *
                     * The parent scope will propagate the {@link angular.module.ng.$rootScope.Scope#$digest $digest()} and
                     * {@link angular.module.ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope
                     * hierarchy using {@link angular.module.ng.$rootScope.Scope#$destroy $destroy()}.
                     *
                     * {@link angular.module.ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for
                     * the scope and its child scopes to be permanently detached from the parent and thus stop
                     * participating in model change detection and listener notification by invoking.
                     *
                     * @params {boolean} isolate if true then the scoped does not prototypically inherit from the
                     *         parent scope. The scope is isolated, as it can not se parent scope properties.
                     *         When creating widgets it is useful for the widget to not accidently read parent
                     *         state.
                     *
                     * @returns {Object} The newly created child scope.
                     *
                     */
                    $new: function(isolate) {
                        var Child,
                            child;

                        if (isFunction(isolate)) {
                            // TODO: remove at some point
                            throw Error('API-CHANGE: Use $controller to instantiate controllers.');
                        }
                        if (isolate) {
                            child = new Scope();
                            child.$root = this.$root;
                        } else {
                            Child = function() {}; // should be anonymous; This is so that when the minifier munges
                            // the name it does not become random set of chars. These will then show up as class
                            // name in the debugger.
                            Child.prototype = this;
                            child = new Child();
                            child.$id = nextUid();
                        }
                        child['this'] = child;
                        child.$$listeners = {};
                        child.$parent = this;
                        child.$$asyncQueue = [];
                        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;
                        child.$$prevSibling = this.$$childTail;
                        if (this.$$childHead) {
                            this.$$childTail.$$nextSibling = child;
                            this.$$childTail = child;
                        } else {
                            this.$$childHead = this.$$childTail = child;
                        }
                        return child;
                    },

                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$watch
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Registers a `listener` callback to be executed whenever the `watchExpression` changes.
                     *
                     * - The `watchExpression` is called on every call to {@link angular.module.ng.$rootScope.Scope#$digest $digest()} and
                     *   should return the value which will be watched. (Since {@link angular.module.ng.$rootScope.Scope#$digest $digest()}
                     *   reruns when it detects changes the `watchExpression` can execute multiple times per
                     *   {@link angular.module.ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)
                     * - The `listener` is called only when the value from the current `watchExpression` and the
                     *   previous call to `watchExpression' are not equal (with the exception of the initial run
                     *   see below). The inequality is determined according to
                     *   {@link angular.equals} function. To save the value of the object for later comparison
                     *   {@link angular.copy} function is used. It also means that watching complex options will
                     *   have adverse memory and performance implications.
                     * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This
                     *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration
                     *   limit is 100 to prevent infinity loop deadlock.
                     *
                     *
                     * If you want to be notified whenever {@link angular.module.ng.$rootScope.Scope#$digest $digest} is called,
                     * you can register an `watchExpression` function with no `listener`. (Since `watchExpression`,
                     * can execute multiple times per {@link angular.module.ng.$rootScope.Scope#$digest $digest} cycle when a change is
                     * detected, be prepared for multiple calls to your listener.)
                     *
                     * After a watcher is registered with the scope, the `listener` fn is called asynchronously
                     * (via {@link angular.module.ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the
                     * watcher. In rare cases, this is undesirable because the listener is called when the result
                     * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you
                     * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the
                     * listener was called due to initialization.
                     *
                     *
                     * # Example
                     <pre>
                     // let's assume that scope was dependency injected as the $rootScope
                     var scope = $rootScope;
                     scope.name = 'misko';
                     scope.counter = 0;

                     expect(scope.counter).toEqual(0);
                     scope.$watch('name', function(newValue, oldValue) { counter = counter + 1; });
                     expect(scope.counter).toEqual(0);

                     scope.$digest();
                     // no variable change
                     expect(scope.counter).toEqual(0);

                     scope.name = 'adam';
                     scope.$digest();
                     expect(scope.counter).toEqual(1);
                     </pre>
                     *
                     *
                     *
                     * @param {(function()|string)} watchExpression Expression that is evaluated on each
                     *    {@link angular.module.ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a
                     *    call to the `listener`.
                     *
                     *    - `string`: Evaluated as {@link guide/dev_guide.expressions expression}
                     *    - `function(scope)`: called with current `scope` as a parameter.
                     * @param {(function()|string)=} listener Callback called whenever the return value of
                     *   the `watchExpression` changes.
                     *
                     *    - `string`: Evaluated as {@link guide/dev_guide.expressions expression}
                     *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.
                     *
                     * @param {boolean=} objectEquality Compare object for equality rather then for refference.
                     * @returns {function()} Returns a deregistration function for this listener.
                     */
                    $watch: function(watchExp, listener, objectEquality) {
                        var scope = this,
                            get = compileToFn(watchExp, 'watch'),
                            array = scope.$$watchers,
                            watcher = {
                                fn: listener,
                                last: initWatchVal,
                                get: get,
                                exp: watchExp,
                                eq: !!objectEquality
                            };

                        // in the case user pass string, we need to compile it, do we really need this ?
                        if (!isFunction(listener)) {
                            var listenFn = compileToFn(listener || noop, 'listener');
                            watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};
                        }

                        if (!array) {
                            array = scope.$$watchers = [];
                        }
                        // we use unshift since we use a while loop in $digest for speed.
                        // the while loop reads in reverse order.
                        array.unshift(watcher);

                        return function() {
                            arrayRemove(array, watcher);
                        };
                    },

                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$digest
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Process all of the {@link angular.module.ng.$rootScope.Scope#$watch watchers} of the current scope and its children.
                     * Because a {@link angular.module.ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the
                     * `$digest()` keeps calling the {@link angular.module.ng.$rootScope.Scope#$watch watchers} until no more listeners are
                     * firing. This means that it is possible to get into an infinite loop. This function will throw
                     * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 100.
                     *
                     * Usually you don't call `$digest()` directly in
                     * {@link angular.module.ng.$compileProvider.directive.ng-controller controllers} or in
                     * {@link angular.module.ng.$compileProvider.directive directives}.
                     * Instead a call to {@link angular.module.ng.$rootScope.Scope#$apply $apply()} (typically from within a
                     * {@link angular.module.ng.$compileProvider.directive directives}) will force a `$digest()`.
                     *
                     * If you want to be notified whenever `$digest()` is called,
                     * you can register a `watchExpression` function  with {@link angular.module.ng.$rootScope.Scope#$watch $watch()}
                     * with no `listener`.
                     *
                     * You may have a need to call `$digest()` from within unit-tests, to simulate the scope
                     * life-cycle.
                     *
                     * # Example
                     <pre>
                     var scope = ...;
                     scope.name = 'misko';
                     scope.counter = 0;

                     expect(scope.counter).toEqual(0);
                     scope.$watch('name', function(scope, newValue, oldValue) {
                     counter = counter + 1;
                     });
                     expect(scope.counter).toEqual(0);

                     scope.$digest();
                     // no variable change
                     expect(scope.counter).toEqual(0);

                     scope.name = 'adam';
                     scope.$digest();
                     expect(scope.counter).toEqual(1);
                     </pre>
                     *
                     */
                    $digest: function() {
                        var watch, value, last,
                            watchers,
                            asyncQueue,
                            length,
                            dirty, ttl = TTL,
                            next, current, target = this,
                            watchLog = [],
                            logIdx, logMsg;

                        flagPhase(target, '$digest');

                        do {
                            dirty = false;
                            current = target;
                            do {
                                asyncQueue = current.$$asyncQueue;
                                while(asyncQueue.length) {
                                    try {
                                        current.$eval(asyncQueue.shift());
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if ((watchers = current.$$watchers)) {
                                    // process our watches
                                    length = watchers.length;
                                    while (length--) {
                                        try {
                                            watch = watchers[length];
                                            // Most common watches are on primitives, in which case we can short
                                            // circuit it with === operator, only when === fails do we use .equals
                                            if ((value = watch.get(current)) !== (last = watch.last) &&
                                                !(watch.eq
                                                    ? equals(value, last)
                                                    : (typeof value == 'number' && typeof last == 'number'
                                                    && isNaN(value) && isNaN(last)))) {
                                                dirty = true;
                                                watch.last = watch.eq ? copy(value) : value;
                                                watch.fn(value, ((last === initWatchVal) ? value : last), current);
                                                if (ttl < 5) {
                                                    logIdx = 4 - ttl;
                                                    if (!watchLog[logIdx]) watchLog[logIdx] = [];
                                                    logMsg = (isFunction(watch.exp))
                                                        ? 'fn: ' + (watch.exp.name || watch.exp.toString())
                                                        : watch.exp;
                                                    logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);
                                                    watchLog[logIdx].push(logMsg);
                                                }
                                            }
                                        } catch (e) {
                                            $exceptionHandler(e);
                                        }
                                    }
                                }

                                // Insanity Warning: scope depth-first traversal
                                // yes, this code is a bit crazy, but it works and we have tests to prove it!
                                // this piece should be kept in sync with the traversal in $broadcast
                                if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
                                    while(current !== target && !(next = current.$$nextSibling)) {
                                        current = current.$parent;
                                    }
                                }
                            } while ((current = next));

                            if(dirty && !(ttl--)) {
                                throw Error(TTL + ' $digest() iterations reached. Aborting!\n' +
                                    'Watchers fired in the last 5 iterations: ' + toJson(watchLog));
                            }
                        } while (dirty || asyncQueue.length);

                        this.$root.$$phase = null;
                    },


                    /**
                     * @ngdoc event
                     * @name angular.module.$rootScope.Scope#$destroy
                     * @eventOf angular.module.ng.$rootScope.Scope
                     * @eventType broadcast on scope being destroyed
                     *
                     * @description
                     * Broadcasted when a scope and its children are being destroyed.
                     */

                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$destroy
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Remove the current scope (and all of its children) from the parent scope. Removal implies
                     * that calls to {@link angular.module.ng.$rootScope.Scope#$digest $digest()} will no longer
                     * propagate to the current scope and its children. Removal also implies that the current
                     * scope is eligible for garbage collection.
                     *
                     * The `$destroy()` is usually used by directives such as
                     * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat} for managing the
                     * unrolling of the loop.
                     *
                     * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.
                     * Application code can register a `$destroy` event handler that will give it chance to
                     * perform any necessary cleanup.
                     */
                    $destroy: function() {
                        if (this.$root == this) return; // we can't remove the root node;
                        var parent = this.$parent;

                        this.$broadcast('$destroy');

                        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;
                        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;
                        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                    },

                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$eval
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Executes the `expression` on the current scope returning the result. Any exceptions in the
                     * expression are propagated (uncaught). This is useful when evaluating engular expressions.
                     *
                     * # Example
                     <pre>
                     var scope = angular.module.ng.$rootScope.Scope();
                     scope.a = 1;
                     scope.b = 2;

                     expect(scope.$eval('a+b')).toEqual(3);
                     expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);
                     </pre>
                     *
                     * @param {(string|function())=} expression An angular expression to be executed.
                     *
                     *    - `string`: execute using the rules as defined in  {@link guide/dev_guide.expressions expression}.
                     *    - `function(scope, locals)`: execute the function with the current `scope` parameter.
                     * @param {Object=} locals Hash object of local variables for the expression.
                     *
                     * @returns {*} The result of evaluating the expression.
                     */
                    $eval: function(expr, locals) {
                        return $parse(expr)(this, locals);
                    },

                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$evalAsync
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Executes the expression on the current scope at a later point in time.
                     *
                     * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:
                     *
                     *   - it will execute in the current script execution context (before any DOM rendering).
                     *   - at least one {@link angular.module.ng.$rootScope.Scope#$digest $digest cycle} will be performed after
                     *     `expression` execution.
                     *
                     * Any exceptions from the execution of the expression are forwarded to the
                     * {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.
                     *
                     * @param {(string|function())=} expression An angular expression to be executed.
                     *
                     *    - `string`: execute using the rules as defined in  {@link guide/dev_guide.expressions expression}.
                     *    - `function(scope)`: execute the function with the current `scope` parameter.
                     *
                     */
                    $evalAsync: function(expr) {
                        this.$$asyncQueue.push(expr);
                    },

                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$apply
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * `$apply()` is used to execute an expression in angular from outside of the angular framework.
                     * (For example from browser DOM events, setTimeout, XHR or third party libraries).
                     * Because we are calling into the angular framework we need to perform proper scope life-cycle
                     * of {@link angular.module.ng.$exceptionHandler exception handling},
                     * {@link angular.module.ng.$rootScope.Scope#$digest executing watches}.
                     *
                     * ## Life cycle
                     *
                     * # Pseudo-Code of `$apply()`
                     function $apply(expr) {
                     try {
                     return $eval(expr);
                     } catch (e) {
                     $exceptionHandler(e);
                     } finally {
                     $root.$digest();
                     }
                     }
                     *
                     *
                     * Scope's `$apply()` method transitions through the following stages:
                     *
                     * 1. The {@link guide/dev_guide.expressions expression} is executed using the
                     *    {@link angular.module.ng.$rootScope.Scope#$eval $eval()} method.
                     * 2. Any exceptions from the execution of the expression are forwarded to the
                     *    {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.
                     * 3. The {@link angular.module.ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression
                     *    was executed using the {@link angular.module.ng.$rootScope.Scope#$digest $digest()} method.
                     *
                     *
                     * @param {(string|function())=} exp An angular expression to be executed.
                     *
                     *    - `string`: execute using the rules as defined in {@link guide/dev_guide.expressions expression}.
                     *    - `function(scope)`: execute the function with current `scope` parameter.
                     *
                     * @returns {*} The result of evaluating the expression.
                     */
                    $apply: function(expr) {
                        try {
                            flagPhase(this, '$apply');
                            return this.$eval(expr);
                        } catch (e) {
                            $exceptionHandler(e);
                        } finally {
                            this.$root.$$phase = null;
                            this.$root.$digest();
                        }
                    },

                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$on
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Listen on events of a given type. See {@link angular.module.ng.$rootScope.Scope#$emit $emit} for discussion of
                     * event life cycle.
                     *
                     * @param {string} name Event name to listen on.
                     * @param {function(event)} listener Function to call when the event is emitted.
                     * @returns {function()} Returns a deregistration function for this listener.
                     *
                     * The event listener function format is: `function(event)`. The `event` object passed into the
                     * listener has the following attributes
                     *
                     *   - `targetScope` - {Scope}: the scope on which the event was `$emit`-ed or `$broadcast`-ed.
                     *   - `currentScope` - {Scope}: the current scope which is handling the event.
                     *   - `name` - {string}: Name of the event.
                     *   - `cancel` - {function=}: calling `cancel` function will cancel further event propagation
                     *     (available only for events that were `$emit`-ed).
                     *   - `cancelled` - {boolean}: Whether the event was cancelled.
                     */
                    $on: function(name, listener) {
                        var namedListeners = this.$$listeners[name];
                        if (!namedListeners) {
                            this.$$listeners[name] = namedListeners = [];
                        }
                        namedListeners.push(listener);

                        return function() {
                            arrayRemove(namedListeners, listener);
                        };
                    },


                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$emit
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Dispatches an event `name` upwards through the scope hierarchy notifying the
                     * registered {@link angular.module.ng.$rootScope.Scope#$on} listeners.
                     *
                     * The event life cycle starts at the scope on which `$emit` was called. All
                     * {@link angular.module.ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
                     * Afterwards, the event traverses upwards toward the root scope and calls all registered
                     * listeners along the way. The event will stop propagating if one of the listeners cancels it.
                     *
                     * Any exception emmited from the {@link angular.module.ng.$rootScope.Scope#$on listeners} will be passed
                     * onto the {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.
                     *
                     * @param {string} name Event name to emit.
                     * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
                     * @return {Object} Event object, see {@link angular.module.ng.$rootScope.Scope#$on}
                     */
                    $emit: function(name, args) {
                        var empty = [],
                            namedListeners,
                            scope = this,
                            event = {
                                name: name,
                                targetScope: scope,
                                cancel: function() {event.cancelled = true;},
                                cancelled: false
                            },
                            listenerArgs = concat([event], arguments, 1),
                            i, length;

                        do {
                            namedListeners = scope.$$listeners[name] || empty;
                            event.currentScope = scope;
                            for (i=0, length=namedListeners.length; i<length; i++) {
                                try {
                                    namedListeners[i].apply(null, listenerArgs);
                                    if (event.cancelled) return event;
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                            //traverse upwards
                            scope = scope.$parent;
                        } while (scope);

                        return event;
                    },


                    /**
                     * @ngdoc function
                     * @name angular.module.ng.$rootScope.Scope#$broadcast
                     * @methodOf angular.module.ng.$rootScope.Scope
                     * @function
                     *
                     * @description
                     * Dispatches an event `name` downwards to all child scopes (and their children) notifying the
                     * registered {@link angular.module.ng.$rootScope.Scope#$on} listeners.
                     *
                     * The event life cycle starts at the scope on which `$broadcast` was called. All
                     * {@link angular.module.ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.
                     * Afterwards, the event propagates to all direct and indirect scopes of the current scope and
                     * calls all registered listeners along the way. The event cannot be canceled.
                     *
                     * Any exception emmited from the {@link angular.module.ng.$rootScope.Scope#$on listeners} will be passed
                     * onto the {@link angular.module.ng.$exceptionHandler $exceptionHandler} service.
                     *
                     * @param {string} name Event name to emit.
                     * @param {...*} args Optional set of arguments which will be passed onto the event listeners.
                     * @return {Object} Event object, see {@link angular.module.ng.$rootScope.Scope#$on}
                     */
                    $broadcast: function(name, args) {
                        var target = this,
                            current = target,
                            next = target,
                            event = { name: name,
                                targetScope: target },
                            listenerArgs = concat([event], arguments, 1);

                        //down while you can, then up and next sibling or up and next sibling until back at root
                        do {
                            current = next;
                            event.currentScope = current;
                            forEach(current.$$listeners[name], function(listener) {
                                try {
                                    listener.apply(null, listenerArgs);
                                } catch(e) {
                                    $exceptionHandler(e);
                                }
                            });

                            // Insanity Warning: scope depth-first traversal
                            // yes, this code is a bit crazy, but it works and we have tests to prove it!
                            // this piece should be kept in sync with the traversal in $digest
                            if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {
                                while(current !== target && !(next = current.$$nextSibling)) {
                                    current = current.$parent;
                                }
                            }
                        } while ((current = next));

                        return event;
                    }
                };


                function flagPhase(scope, phase) {
                    var root = scope.$root;

                    if (root.$$phase) {
                        throw Error(root.$$phase + ' already in progress');
                    }

                    root.$$phase = phase;
                }

                return new Scope();

                function compileToFn(exp, name) {
                    var fn = $parse(exp);
                    assertArgFn(fn, name);
                    return fn;
                }

                /**
                 * function used as an initial value for watchers.
                 * because it's uniqueue we can easily tell it apart from other values
                 */
                function initWatchVal() {}
            }];
    }

    /*
     * HTML Parser By Misko Hevery (misko@hevery.com)
     * based on:  HTML Parser By John Resig (ejohn.org)
     * Original code by Erik Arvidsson, Mozilla Public License
     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
     *
     * // Use like so:
     * htmlParser(htmlString, {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * });
     *
     */



    /**
     * @ngdoc service
     * @name angular.module.ng.$sanitize
     * @function
     *
     * @description
     *   The input is sanitized by parsing the html into tokens. All safe tokens (from a whitelist) are
     *   then serialized back to properly escaped html string. This means that no unsafe input can make
     *   it into the returned string, however, since our parser is more strict than a typical browser
     *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
     *   browser, won't make it through the sanitizer.
     *
     * @param {string} html Html input.
     * @returns {string} Sanitized html.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.snippet =
     '<p style="color:blue">an html\n' +
     '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
     'snippet</p>';
     }
     </script>
     <div ng-controller="Ctrl">
     Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
     <table>
     <tr>
     <td>Filter</td>
     <td>Source</td>
     <td>Rendered</td>
     </tr>
     <tr id="html-filter">
     <td>html filter</td>
     <td>
     <pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre>
     </td>
     <td>
     <div ng-bind-html="snippet"></div>
     </td>
     </tr>
     <tr id="escaped-html">
     <td>no filter</td>
     <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
     <td><div ng-bind="snippet"></div></td>
     </tr>
     <tr id="html-unsafe-filter">
     <td>unsafe html filter</td>
     <td><pre>&lt;div ng-bind-html-unsafe="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
     <td><div ng-bind-html-unsafe="snippet"></div></td>
     </tr>
     </table>
     </div>
     </doc:source>
     <doc:scenario>
     it('should sanitize the html snippet ', function() {
     expect(using('#html-filter').element('div').html()).
     toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should escape snippet without any filter', function() {
     expect(using('#escaped-html').element('div').html()).
     toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
     "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
     "snippet&lt;/p&gt;");
     });

     it('should inline raw snippet if filtered as unsafe', function() {
     expect(using('#html-unsafe-filter').element("div").html()).
     toBe("<p style=\"color:blue\">an html\n" +
     "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
     "snippet</p>");
     });

     it('should update', function() {
     input('snippet').enter('new <b>text</b>');
     expect(using('#html-filter').binding('snippet')).toBe('new <b>text</b>');
     expect(using('#escaped-html').element('div').html()).toBe("new &lt;b&gt;text&lt;/b&gt;");
     expect(using('#html-unsafe-filter').binding("snippet")).toBe('new <b>text</b>');
     });
     </doc:scenario>
     </doc:example>
     */

    function $SanitizeProvider() {
        this.$get = valueFn(function(html) {
            var buf = [];
            htmlParser(html, htmlSanitizeWriter(buf));
            return buf.join('');
        });
    };

// Regular Expressions for parsing tags and attributes
    var START_TAG_REGEXP = /^<\s*([\w:-]+)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*>/,
        END_TAG_REGEXP = /^<\s*\/\s*([\w:-]+)[^>]*>/,
        ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
        BEGIN_TAG_REGEXP = /^</,
        BEGING_END_TAGE_REGEXP = /^<\s*\//,
        COMMENT_REGEXP = /<!--(.*?)-->/g,
        CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
        URI_REGEXP = /^((ftp|https?):\/\/|mailto:|#)/,
        NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g; // Match everything outside of normal chars and " (quote character)


// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
    var voidElements = makeMap("area,br,col,hr,img,wbr");

// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
    var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
        optionalEndTagInlineElements = makeMap("rp,rt"),
        optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements);

// Safe Block Elements - HTML5
    var blockElements = extend({}, optionalEndTagBlockElements, makeMap("address,article,aside," +
        "blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6," +
        "header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));

// Inline Elements - HTML5
    var inlineElements = extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b,bdi,bdo," +
        "big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small," +
        "span,strike,strong,sub,sup,time,tt,u,var"));


// Special Elements (can contain anything)
    var specialElements = makeMap("script,style");

    var validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements);

//Attributes that have href and hence need to be sanitized
    var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap");
    var validAttrs = extend({}, uriAttrs, makeMap(
        'abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,'+
            'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,'+
            'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,'+
            'scope,scrolling,shape,span,start,summary,target,title,type,'+
            'valign,value,vspace,width'));

    /**
     * @example
     * htmlParser(htmlString, {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * });
     *
     * @param {string} html string
     * @param {object} handler
     */
    function htmlParser( html, handler ) {
        var index, chars, match, stack = [], last = html;
        stack.last = function() { return stack[ stack.length - 1 ]; };

        while ( html ) {
            chars = true;

            // Make sure we're not in a script or style element
            if ( !stack.last() || !specialElements[ stack.last() ] ) {

                // Comment
                if ( html.indexOf("<!--") === 0 ) {
                    index = html.indexOf("-->");

                    if ( index >= 0 ) {
                        if (handler.comment) handler.comment( html.substring( 4, index ) );
                        html = html.substring( index + 3 );
                        chars = false;
                    }

                    // end tag
                } else if ( BEGING_END_TAGE_REGEXP.test(html) ) {
                    match = html.match( END_TAG_REGEXP );

                    if ( match ) {
                        html = html.substring( match[0].length );
                        match[0].replace( END_TAG_REGEXP, parseEndTag );
                        chars = false;
                    }

                    // start tag
                } else if ( BEGIN_TAG_REGEXP.test(html) ) {
                    match = html.match( START_TAG_REGEXP );

                    if ( match ) {
                        html = html.substring( match[0].length );
                        match[0].replace( START_TAG_REGEXP, parseStartTag );
                        chars = false;
                    }
                }

                if ( chars ) {
                    index = html.indexOf("<");

                    var text = index < 0 ? html : html.substring( 0, index );
                    html = index < 0 ? "" : html.substring( index );

                    if (handler.chars) handler.chars( decodeEntities(text) );
                }

            } else {
                html = html.replace(new RegExp("(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'), function(all, text){
                    text = text.
                        replace(COMMENT_REGEXP, "$1").
                        replace(CDATA_REGEXP, "$1");

                    if (handler.chars) handler.chars( decodeEntities(text) );

                    return "";
                });

                parseEndTag( "", stack.last() );
            }

            if ( html == last ) {
                throw "Parse Error: " + html;
            }
            last = html;
        }

        // Clean up any remaining tags
        parseEndTag();

        function parseStartTag( tag, tagName, rest, unary ) {
            tagName = lowercase(tagName);
            if ( blockElements[ tagName ] ) {
                while ( stack.last() && inlineElements[ stack.last() ] ) {
                    parseEndTag( "", stack.last() );
                }
            }

            if ( optionalEndTagElements[ tagName ] && stack.last() == tagName ) {
                parseEndTag( "", tagName );
            }

            unary = voidElements[ tagName ] || !!unary;

            if ( !unary )
                stack.push( tagName );

            var attrs = {};

            rest.replace(ATTR_REGEXP, function(match, name, doubleQuotedValue, singleQoutedValue, unqoutedValue) {
                var value = doubleQuotedValue
                    || singleQoutedValue
                    || unqoutedValue
                    || '';

                attrs[name] = decodeEntities(value);
            });
            if (handler.start) handler.start( tagName, attrs, unary );
        }

        function parseEndTag( tag, tagName ) {
            var pos = 0, i;
            tagName = lowercase(tagName);
            if ( tagName )
            // Find the closest opened tag of the same type
                for ( pos = stack.length - 1; pos >= 0; pos-- )
                    if ( stack[ pos ] == tagName )
                        break;

            if ( pos >= 0 ) {
                // Close all the open elements, up the stack
                for ( i = stack.length - 1; i >= pos; i-- )
                    if (handler.end) handler.end( stack[ i ] );

                // Remove the open elements from the stack
                stack.length = pos;
            }
        }
    }

    /**
     * decodes all entities into regular string
     * @param value
     * @returns {string} A string with decoded entities.
     */
    var hiddenPre=document.createElement("pre");
    function decodeEntities(value) {
        hiddenPre.innerHTML=value.replace(/</g,"&lt;");
        return hiddenPre.innerText || hiddenPre.textContent || '';
    }

    /**
     * Escapes all potentially dangerous characters, so that the
     * resulting string can be safely inserted into attribute or
     * element text.
     * @param value
     * @returns escaped text
     */
    function encodeEntities(value) {
        return value.
            replace(/&/g, '&amp;').
            replace(NON_ALPHANUMERIC_REGEXP, function(value){
                return '&#' + value.charCodeAt(0) + ';';
            }).
            replace(/</g, '&lt;').
            replace(/>/g, '&gt;');
    }

    /**
     * create an HTML/XML writer which writes to buffer
     * @param {Array} buf use buf.jain('') to get out sanitized html string
     * @returns {object} in the form of {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * }
     */
    function htmlSanitizeWriter(buf){
        var ignore = false;
        var out = bind(buf, buf.push);
        return {
            start: function(tag, attrs, unary){
                tag = lowercase(tag);
                if (!ignore && specialElements[tag]) {
                    ignore = tag;
                }
                if (!ignore && validElements[tag] == true) {
                    out('<');
                    out(tag);
                    forEach(attrs, function(value, key){
                        var lkey=lowercase(key);
                        if (validAttrs[lkey]==true && (uriAttrs[lkey]!==true || value.match(URI_REGEXP))) {
                            out(' ');
                            out(key);
                            out('="');
                            out(encodeEntities(value));
                            out('"');
                        }
                    });
                    out(unary ? '/>' : '>');
                }
            },
            end: function(tag){
                tag = lowercase(tag);
                if (!ignore && validElements[tag] == true) {
                    out('</');
                    out(tag);
                    out('>');
                }
                if (tag == ignore) {
                    ignore = false;
                }
            },
            chars: function(chars){
                if (!ignore) {
                    out(encodeEntities(chars));
                }
            }
        };
    }

    /**
     * !!! This is an undocumented "private" service !!!
     *
     * @name angular.module.ng.$sniffer
     * @requires $window
     *
     * @property {boolean} history Does the browser support html5 history api ?
     * @property {boolean} hashchange Does the browser support hashchange event ?
     *
     * @description
     * This is very simple implementation of testing browser's features.
     */
    function $SnifferProvider(){
        this.$get = ['$window', function($window){
            return {
                history: !!($window.history && $window.history.pushState),
                hashchange: 'onhashchange' in $window &&
                    // IE8 compatible mode lies
                    (!$window.document.documentMode || $window.document.documentMode > 7)
            };
        }];
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$window
     *
     * @description
     * A reference to the browser's `window` object. While `window`
     * is globally available in JavaScript, it causes testability problems, because
     * it is a global variable. In angular we always refer to it through the
     * `$window` service, so it may be overriden, removed or mocked for testing.
     *
     * All expressions are evaluated with respect to current scope so they don't
     * suffer from window globality.
     *
     * @example
     <doc:example>
     <doc:source>
     <input ng-init="$window = $service('$window'); greeting='Hello World!'" type="text" ng-model="greeting" />
     <button ng-click="$window.alert(greeting)">ALERT</button>
     </doc:source>
     <doc:scenario>
     </doc:scenario>
     </doc:example>
     */
    function $WindowProvider(){
        this.$get = valueFn(window);
    }

    /**
     * Parse headers into key value object
     *
     * @param {string} headers Raw headers as a string
     * @returns {Object} Parsed headers as key value object
     */
    function parseHeaders(headers) {
        var parsed = {}, key, val, i;

        if (!headers) return parsed;

        forEach(headers.split('\n'), function(line) {
            i = line.indexOf(':');
            key = lowercase(trim(line.substr(0, i)));
            val = trim(line.substr(i + 1));

            if (key) {
                if (parsed[key]) {
                    parsed[key] += ', ' + val;
                } else {
                    parsed[key] = val;
                }
            }
        });

        return parsed;
    }


    /**
     * Returns a function that provides access to parsed headers.
     *
     * Headers are lazy parsed when first requested.
     * @see parseHeaders
     *
     * @param {(string|Object)} headers Headers to provide access to.
     * @returns {function(string=)} Returns a getter function which if called with:
     *
     *   - if called with single an argument returns a single header value or null
     *   - if called with no arguments returns an object containing all headers.
     */
    function headersGetter(headers) {
        var headersObj = isObject(headers) ? headers : undefined;

        return function(name) {
            if (!headersObj) headersObj =  parseHeaders(headers);

            if (name) {
                return headersObj[lowercase(name)] || null;
            }

            return headersObj;
        };
    }


    /**
     * Chain all given functions
     *
     * This function is used for both request and response transforming
     *
     * @param {*} data Data to transform.
     * @param {function(string=)} headers Http headers getter fn.
     * @param {(function|Array.<function>)} fns Function or an array of functions.
     * @returns {*} Transformed data.
     */
    function transformData(data, headers, fns) {
        if (isFunction(fns))
            return fns(data, headers);

        forEach(fns, function(fn) {
            data = fn(data, headers);
        });

        return data;
    }


    function isSuccess(status) {
        return 200 <= status && status < 300;
    }


    function $HttpProvider() {
        var JSON_START = /^\s*(\[|\{[^\{])/,
            JSON_END = /[\}\]]\s*$/,
            PROTECTION_PREFIX = /^\)\]\}',?\n/;

        var $config = this.defaults = {
            // transform incoming response data
            transformResponse: [function(data) {
                if (isString(data)) {
                    // strip json vulnerability protection prefix
                    data = data.replace(PROTECTION_PREFIX, '');
                    if (JSON_START.test(data) && JSON_END.test(data))
                        data = fromJson(data, true);
                }
                return data;
            }],

            // transform outgoing request data
            transformRequest: [function(d) {
                return isObject(d) && !isFile(d) ? toJson(d) : d;
            }],

            // default headers
            headers: {
                common: {
                    'Accept': 'application/json, text/plain, */*',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                post: {'Content-Type': 'application/json'},
                put:  {'Content-Type': 'application/json'}
            }
        };

        var providerResponseInterceptors = this.responseInterceptors = [];

        this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector',
            function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector) {

                var defaultCache = $cacheFactory('$http'),
                    responseInterceptors = [];

                forEach(providerResponseInterceptors, function(interceptor) {
                    responseInterceptors.push(
                        isString(interceptor)
                            ? $injector.get(interceptor)
                            : $injector.invoke(interceptor)
                    );
                });


                /**
                 * @ngdoc function
                 * @name angular.module.ng.$http
                 * @requires $httpBacked
                 * @requires $browser
                 * @requires $cacheFactory
                 * @requires $rootScope
                 * @requires $q
                 * @requires $injector
                 *
                 * @description
                 * The `$http` service is a core Angular service that facilitates communication with the remote
                 * HTTP servers via browser's {@link https://developer.mozilla.org/en/xmlhttprequest
                 * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.
                 *
                 * For unit testing applications that use `$http` service, see
                 * {@link angular.module.ngMock.$httpBackend $httpBackend mock}.
                 *
                 * For a higher level of abstraction, please check out the {@link angular.module.ngResource.$resource
                 * $resource} service.
                 *
                 * The $http API is based on the {@link angular.module.ng.$q deferred/promise APIs} exposed by
                 * the $q service. While for simple usage patters this doesn't matter much, for advanced usage,
                 * it is important to familiarize yourself with these apis and guarantees they provide.
                 *
                 *
                 * # General usage
                 * The `$http` service is a function which takes a single argument — a configuration object —
                 * that is used to generate an http request and returns  a {@link angular.module.ng.$q promise}
                 * with two $http specific methods: `success` and `error`.
                 *
                 * <pre>
                 *   $http({method: 'GET', url: '/someUrl'}).
                 *     success(function(data, status, headers, config) {
                 *       // this callback will be called asynchronously
                 *       // when the response is available
                 *     }).
                 *     error(function(data, status, headers, config) {
                 *       // called asynchronously if an error occurs
                 *       // or server returns response with status
                 *       // code outside of the <200, 400) range
                 *     });
                 * </pre>
                 *
                 * Since the returned value of calling the $http function is a Promise object, you can also use
                 * the `then` method to register callbacks, and these callbacks will receive a single argument –
                 * an object representing the response. See the api signature and type info below for more
                 * details.
                 *
                 *
                 * # Shortcut methods
                 *
                 * Since all invocation of the $http service require definition of the http method and url and
                 * POST and PUT requests require response body/data to be provided as well, shortcut methods
                 * were created to simplify using the api:
                 *
                 * <pre>
                 *   $http.get('/someUrl').success(successCallback);
                 *   $http.post('/someUrl', data).success(successCallback);
                 * </pre>
                 *
                 * Complete list of shortcut methods:
                 *
                 * - {@link angular.module.ng.$http#get $http.get}
                 * - {@link angular.module.ng.$http#head $http.head}
                 * - {@link angular.module.ng.$http#post $http.post}
                 * - {@link angular.module.ng.$http#put $http.put}
                 * - {@link angular.module.ng.$http#delete $http.delete}
                 * - {@link angular.module.ng.$http#jsonp $http.jsonp}
                 *
                 *
                 * # Setting HTTP Headers
                 *
                 * The $http service will automatically add certain http headers to all requests. These defaults
                 * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration
                 * object, which currently contains this default configuration:
                 *
                 * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):
                 *   - `Accept: application/json, text/plain, * / *`
                 *   - `X-Requested-With: XMLHttpRequest`
                 * - `$httpProvider.defaults.headers.post`: (header defaults for HTTP POST requests)
                 *   - `Content-Type: application/json`
                 * - `$httpProvider.defaults.headers.put` (header defaults for HTTP PUT requests)
                 *   - `Content-Type: application/json`
                 *
                 * To add or overwrite these defaults, simply add or remove a property from this configuration
                 * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object
                 * with name equal to the lower-cased http method name, e.g.
                 * `$httpProvider.defaults.headers.get['My-Header']='value'`.
                 *
                 *
                 * # Transforming Requests and Responses
                 *
                 * Both requests and responses can be transformed using transform functions. By default, Angular
                 * applies these transformations:
                 *
                 * Request transformations:
                 *
                 * - if the `data` property of the request config object contains an object, serialize it into
                 *   JSON format.
                 *
                 * Response transformations:
                 *
                 *  - if XSRF prefix is detected, strip it (see Security Considerations section below)
                 *  - if json response is detected, deserialize it using a JSON parser
                 *
                 * To override these transformation locally, specify transform functions as `transformRequest`
                 * and/or `transformResponse` properties of the config object. To globally override the default
                 * transforms, override the `$httpProvider.defaults.transformRequest` and
                 * `$httpProvider.defaults.transformResponse` properties of the `$httpProvider`.
                 *
                 *
                 * # Caching
                 *
                 * To enable caching set the configuration property `cache` to `true`. When the cache is
                 * enabled, `$http` stores the response from the server in local cache. Next time the
                 * response is served from the cache without sending a request to the server.
                 *
                 * Note that even if the response is served from cache, delivery of the data is asynchronous in
                 * the same way that real requests are.
                 *
                 * If there are multiple GET requests for the same url that should be cached using the same
                 * cache, but the cache is not populated yet, only one request to the server will be made and
                 * the remaining requests will be fulfilled using the response for the first request.
                 *
                 *
                 * # Response interceptors
                 *
                 * Before you start creating interceptors, be sure to understand the
                 * {@link angular.module.ng.$q $q and deferred/promise APIs}.
                 *
                 * For purposes of global error handling, authentication or any kind of synchronous or
                 * asynchronous preprocessing of received responses, it is desirable to be able to intercept
                 * responses for http requests before they are handed over to the application code that
                 * initiated these requests. The response interceptors leverage the {@link angular.module.ng.$q
                 * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.
                 *
                 * The interceptors are service factories that are registered with the $httpProvider by
                 * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and
                 * injected with dependencies (if specified) and returns the interceptor  — a function that
                 * takes a {@link angular.module.ng.$q promise} and returns the original or a new promise.
                 *
                 * <pre>
                 *   // register the interceptor as a service
                 *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {
                 *     return function(promise) {
                 *       return promise.then(function(response) {
                 *         // do something on success
                 *       }, function(response) {
                 *         // do something on error
                 *         if (canRecover(response)) {
                 *           return responseOrNewPromise
                 *         }
                 *         return $q.reject(response);
                 *       });
                 *     }
                 *   });
                 *
                 *   $httpProvider.responseInterceptors.push('myHttpInterceptor');
                 *
                 *
                 *   // register the interceptor via an anonymous factory
                 *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {
                 *     return function(promise) {
                 *       // same as above
                 *     }
                 *   });
                 * </pre>
                 *
                 *
                 * # Security Considerations
                 *
                 * When designing web applications, consider security threats from:
                 *
                 * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
                 *   JSON Vulnerability}
                 * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}
                 *
                 * Both server and the client must cooperate in order to eliminate these threats. Angular comes
                 * pre-configured with strategies that address these issues, but for this to work backend server
                 * cooperation is required.
                 *
                 * ## JSON Vulnerability Protection
                 *
                 * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx
                 * JSON Vulnerability} allows third party web-site to turn your JSON resource URL into
                 * {@link http://en.wikipedia.org/wiki/JSON#JSONP JSONP} request under some conditions. To
                 * counter this your server can prefix all JSON requests with following string `")]}',\n"`.
                 * Angular will automatically strip the prefix before processing it as JSON.
                 *
                 * For example if your server needs to return:
                 * <pre>
                 * ['one','two']
                 * </pre>
                 *
                 * which is vulnerable to attack, your server can return:
                 * <pre>
                 * )]}',
                 * ['one','two']
                 * </pre>
                 *
                 * Angular will strip the prefix, before processing the JSON.
                 *
                 *
                 * ## Cross Site Request Forgery (XSRF) Protection
                 *
                 * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which
                 * an unauthorized site can gain your user's private data. Angular provides following mechanism
                 * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie
                 * called `XSRF-TOKEN` and sets it as the HTTP header `X-XSRF-TOKEN`. Since only JavaScript that
                 * runs on your domain could read the cookie, your server can be assured that the XHR came from
                 * JavaScript running on your domain.
                 *
                 * To take advantage of this, your server needs to set a token in a JavaScript readable session
                 * cookie called `XSRF-TOKEN` on first HTTP GET request. On subsequent non-GET requests the
                 * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure
                 * that only JavaScript running on your domain could have read the token. The token must be
                 * unique for each user and must be verifiable by the server (to prevent the JavaScript making
                 * up its own tokens). We recommend that the token is a digest of your site's authentication
                 * cookie with {@link http://en.wikipedia.org/wiki/Rainbow_table salt for added security}.
                 *
                 *
                 * @param {object} config Object describing the request to be made and how it should be
                 *    processed. The object has following properties:
                 *
                 *    - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)
                 *    - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.
                 *    - **params** – `{Object.<string|Object>}` – Map of strings or objects which will be turned to
                 *      `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.
                 *    - **data** – `{string|Object}` – Data to be sent as the request message data.
                 *    - **headers** – `{Object}` – Map of strings representing HTTP headers to send to the server.
                 *    - **transformRequest** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
                 *      transform function or an array of such functions. The transform function takes the http
                 *      request body and headers and returns its transformed (typically serialized) version.
                 *    - **transformResponse** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –
                 *      transform function or an array of such functions. The transform function takes the http
                 *      response body and headers and returns its transformed (typically deserialized) version.
                 *    - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the
                 *      GET request, otherwise if a cache instance built with
                 *      {@link angular.module.ng.$cacheFactory $cacheFactory}, this cache will be used for
                 *      caching.
                 *    - **timeout** – `{number}` – timeout in milliseconds.
                 *
                 * @returns {HttpPromise} Returns a {@link angular.module.ng.$q promise} object with the
                 *   standard `then` method and two http specific methods: `success` and `error`. The `then`
                 *   method takes two arguments a success and an error callback which will be called with a
                 *   response object. The `success` and `error` methods take a single argument - a function that
                 *   will be called when the request succeeds or fails respectively. The arguments passed into
                 *   these functions are destructured representation of the response object passed into the
                 *   `then` method. The response object has these properties:
                 *
                 *   - **data** – `{string|Object}` – The response body transformed with the transform functions.
                 *   - **status** – `{number}` – HTTP status code of the response.
                 *   - **headers** – `{function([headerName])}` – Header getter function.
                 *   - **config** – `{Object}` – The configuration object that was used to generate the request.
                 *
                 * @property {Array.<Object>} pendingRequests Array of config objects for currently pending
                 *   requests. This is primarily meant to be used for debugging purposes.
                 *
                 *
                 * @example
                 <doc:example>
                 <doc:source jsfiddle="false">
                 <script>
                 function FetchCtrl($scope, $http) {
                 $scope.method = 'GET';
                 $scope.url = 'examples/http-hello.html';

                 $scope.fetch = function() {
                 $scope.code = null;
                 $scope.response = null;

                 $http({method: $scope.method, url: $scope.url}).
                 success(function(data, status) {
                 $scope.status = status;
                 $scope.data = data;
                 }).
                 error(function(data, status) {
                 $scope.data = data || "Request failed";
                 $scope.status = status;
                 });
                 };

                 $scope.updateModel = function(method, url) {
                 $scope.method = method;
                 $scope.url = url;
                 };
                 }
                 </script>
                 <div ng-controller="FetchCtrl">
                 <select ng-model="method">
                 <option>GET</option>
                 <option>JSONP</option>
                 </select>
                 <input type="text" ng-model="url" size="80"/>
                 <button ng-click="fetch()">fetch</button><br>
                 <button ng-click="updateModel('GET', 'examples/http-hello.html')">Sample GET</button>
                 <button ng-click="updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')">Sample JSONP</button>
                 <button ng-click="updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')">Invalid JSONP</button>
                 <pre>http status code: {{status}}</pre>
                 <pre>http response data: {{data}}</pre>
                 </div>
                 </doc:source>
                 <doc:scenario>
                 it('should make an xhr GET request', function() {
                 element(':button:contains("Sample GET")').click();
                 element(':button:contains("fetch")').click();
                 expect(binding('status')).toBe('200');
                 expect(binding('data')).toBe('Hello, $http!\n');
                 });

                 it('should make a JSONP request to angularjs.org', function() {
                 element(':button:contains("Sample JSONP")').click();
                 element(':button:contains("fetch")').click();
                 expect(binding('status')).toBe('200');
                 expect(binding('data')).toMatch(/Super Hero!/);
                 });

                 it('should make JSONP request to invalid URL and invoke the error handler',
                 function() {
                 element(':button:contains("Invalid JSONP")').click();
                 element(':button:contains("fetch")').click();
                 expect(binding('status')).toBe('0');
                 expect(binding('data')).toBe('Request failed');
                 });
                 </doc:scenario>
                 </doc:example>
                 */
                function $http(config) {
                    config.method = uppercase(config.method);

                    var reqTransformFn = config.transformRequest || $config.transformRequest,
                        respTransformFn = config.transformResponse || $config.transformResponse,
                        defHeaders = $config.headers,
                        reqHeaders = extend({'X-XSRF-TOKEN': $browser.cookies()['XSRF-TOKEN']},
                            defHeaders.common, defHeaders[lowercase(config.method)], config.headers),
                        reqData = transformData(config.data, headersGetter(reqHeaders), reqTransformFn),
                        promise;

                    // strip content-type if data is undefined
                    if (isUndefined(config.data)) {
                        delete reqHeaders['Content-Type'];
                    }

                    // send request
                    promise = sendReq(config, reqData, reqHeaders);


                    // transform future response
                    promise = promise.then(transformResponse, transformResponse);

                    // apply interceptors
                    forEach(responseInterceptors, function(interceptor) {
                        promise = interceptor(promise);
                    });

                    promise.success = function(fn) {
                        promise.then(function(response) {
                            fn(response.data, response.status, response.headers, config);
                        });
                        return promise;
                    };

                    promise.error = function(fn) {
                        promise.then(null, function(response) {
                            fn(response.data, response.status, response.headers, config);
                        });
                        return promise;
                    };

                    return promise;

                    function transformResponse(response) {
                        // make a copy since the response must be cacheable
                        var resp = extend({}, response, {
                            data: transformData(response.data, response.headers, respTransformFn)
                        });
                        return (isSuccess(response.status))
                            ? resp
                            : $q.reject(resp);
                    }
                }

                $http.pendingRequests = [];

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$http#get
                 * @methodOf angular.module.ng.$http
                 *
                 * @description
                 * Shortcut method to perform `GET` request
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$http#delete
                 * @methodOf angular.module.ng.$http
                 *
                 * @description
                 * Shortcut method to perform `DELETE` request
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$http#head
                 * @methodOf angular.module.ng.$http
                 *
                 * @description
                 * Shortcut method to perform `HEAD` request
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {Object=} config Optional configuration object
                 * @returns {XhrFuture} Future object
                 */

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$http#jsonp
                 * @methodOf angular.module.ng.$http
                 *
                 * @description
                 * Shortcut method to perform `JSONP` request
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request.
                 *                     Should contain `JSON_CALLBACK` string.
                 * @param {Object=} config Optional configuration object
                 * @returns {XhrFuture} Future object
                 */
                createShortMethods('get', 'delete', 'head', 'jsonp');

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$http#post
                 * @methodOf angular.module.ng.$http
                 *
                 * @description
                 * Shortcut method to perform `POST` request
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {*} data Request content
                 * @param {Object=} config Optional configuration object
                 * @returns {HttpPromise} Future object
                 */

                /**
                 * @ngdoc method
                 * @name angular.module.ng.$http#put
                 * @methodOf angular.module.ng.$http
                 *
                 * @description
                 * Shortcut method to perform `PUT` request
                 *
                 * @param {string} url Relative or absolute URL specifying the destination of the request
                 * @param {*} data Request content
                 * @param {Object=} config Optional configuration object
                 * @returns {XhrFuture} Future object
                 */
                createShortMethodsWithData('post', 'put');


                return $http;


                function createShortMethods(names) {
                    forEach(arguments, function(name) {
                        $http[name] = function(url, config) {
                            return $http(extend(config || {}, {
                                method: name,
                                url: url
                            }));
                        };
                    });
                }


                function createShortMethodsWithData(name) {
                    forEach(arguments, function(name) {
                        $http[name] = function(url, data, config) {
                            return $http(extend(config || {}, {
                                method: name,
                                url: url,
                                data: data
                            }));
                        };
                    });
                }


                /**
                 * Makes the request
                 *
                 * !!! ACCESSES CLOSURE VARS:
                 * $httpBackend, $config, $log, $rootScope, defaultCache, $http.pendingRequests
                 */
                function sendReq(config, reqData, reqHeaders) {
                    var deferred = $q.defer(),
                        promise = deferred.promise,
                        cache,
                        cachedResp,
                        url = buildUrl(config.url, config.params);

                    $http.pendingRequests.push(config);
                    promise.then(removePendingReq, removePendingReq);


                    if (config.cache && config.method == 'GET') {
                        cache = isObject(config.cache) ? config.cache : defaultCache;
                    }

                    if (cache) {
                        cachedResp = cache.get(url);
                        if (cachedResp) {
                            if (cachedResp.then) {
                                // cached request has already been sent, but there is no response yet
                                cachedResp.then(removePendingReq, removePendingReq);
                                return cachedResp;
                            } else {
                                // serving from cache
                                if (isArray(cachedResp)) {
                                    resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));
                                } else {
                                    resolvePromise(cachedResp, 200, {});
                                }
                            }
                        } else {
                            // put the promise for the non-transformed response into cache as a placeholder
                            cache.put(url, promise);
                        }
                    }

                    // if we won't have the response in cache, send the request to the backend
                    if (!cachedResp) {
                        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout);
                    }

                    return promise;


                    /**
                     * Callback registered to $httpBackend():
                     *  - caches the response if desired
                     *  - resolves the raw $http promise
                     *  - calls $apply
                     */
                    function done(status, response, headersString) {
                        if (cache) {
                            if (isSuccess(status)) {
                                cache.put(url, [status, response, parseHeaders(headersString)]);
                            } else {
                                // remove promise from the cache
                                cache.remove(url);
                            }
                        }

                        resolvePromise(response, status, headersString);
                        $rootScope.$apply();
                    }


                    /**
                     * Resolves the raw $http promise.
                     */
                    function resolvePromise(response, status, headers) {
                        // normalize internal statuses to 0
                        status = Math.max(status, 0);

                        (isSuccess(status) ? deferred.resolve : deferred.reject)({
                            data: response,
                            status: status,
                            headers: headersGetter(headers),
                            config: config
                        });
                    }


                    function removePendingReq() {
                        var idx = indexOf($http.pendingRequests, config);
                        if (idx !== -1) $http.pendingRequests.splice(idx, 1);
                    }
                }


                function buildUrl(url, params) {
                    if (!params) return url;
                    var parts = [];
                    forEachSorted(params, function(value, key) {
                        if (value == null || value == undefined) return;
                        if (isObject(value)) {
                            value = toJson(value);
                        }
                        parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
                    });
                    return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');
                }


            }];
    }
    var XHR = window.XMLHttpRequest || function() {
        try { return new ActiveXObject("Msxml2.XMLHTTP.6.0"); } catch (e1) {}
        try { return new ActiveXObject("Msxml2.XMLHTTP.3.0"); } catch (e2) {}
        try { return new ActiveXObject("Msxml2.XMLHTTP"); } catch (e3) {}
        throw new Error("This browser does not support XMLHttpRequest.");
    };


    /**
     * @ngdoc object
     * @name angular.module.ng.$httpBackend
     * @requires $browser
     * @requires $window
     * @requires $document
     *
     * @description
     * HTTP backend used by the {@link angular.module.ng.$http service} that delegates to
     * XMLHttpRequest object or JSONP and deals with browser incompatibilities.
     *
     * You should never need to use this service directly, instead use the higher-level abstractions:
     * {@link angular.module.ng.$http $http} or {@link angular.module.ngResource.$resource $resource}.
     *
     * During testing this implementation is swapped with {@link angular.module.ngMock.$httpBackend mock
     * $httpBackend} which can be trained with responses.
     */
    function $HttpBackendProvider() {
        this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {
            return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,
                $document[0].body, $window.location.protocol.replace(':', ''));
        }];
    }

    function createHttpBackend($browser, XHR, $browserDefer, callbacks, body, locationProtocol) {
        // TODO(vojta): fix the signature
        return function(method, url, post, callback, headers, timeout) {
            $browser.$$incOutstandingRequestCount();
            url = url || $browser.url();

            if (lowercase(method) == 'jsonp') {
                var callbackId = '_' + (callbacks.counter++).toString(36);
                callbacks[callbackId] = function(data) {
                    callbacks[callbackId].data = data;
                };

                var script = $browser.addJs(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),
                    function() {
                        if (callbacks[callbackId].data) {
                            completeRequest(callback, 200, callbacks[callbackId].data);
                        } else {
                            completeRequest(callback, -2);
                        }
                        delete callbacks[callbackId];
                        body.removeChild(script);
                    });
            } else {
                var xhr = new XHR();
                xhr.open(method, url, true);
                forEach(headers, function(value, key) {
                    if (value) xhr.setRequestHeader(key, value);
                });

                var status;

                // In IE6 and 7, this might be called synchronously when xhr.send below is called and the
                // response is in the cache. the promise api will ensure that to the app code the api is
                // always async
                xhr.onreadystatechange = function() {
                    if (xhr.readyState == 4) {
                        completeRequest(
                            callback, status || xhr.status, xhr.responseText, xhr.getAllResponseHeaders());
                    }
                };

                xhr.send(post || '');

                if (timeout > 0) {
                    $browserDefer(function() {
                        status = -1;
                        xhr.abort();
                    }, timeout);
                }
            }


            function completeRequest(callback, status, response, headersString) {
                // URL_MATCH is defined in src/service/location.js
                var protocol = (url.match(URL_MATCH) || ['', locationProtocol])[1];

                // fix status code for file protocol (it's always 0)
                status = (protocol == 'file') ? (response ? 200 : 404) : status;

                // normalize IE bug (http://bugs.jquery.com/ticket/1450)
                status = status == 1223 ? 204 : status;

                callback(status, response, headersString);
                $browser.$$completeOutstandingRequest(noop);
            }
        };
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$locale
     *
     * @description
     * $locale service provides localization rules for various Angular components. As of right now the
     * only public api is:
     *
     * * `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)
     */
    function $LocaleProvider(){
        this.$get = function() {
            return {
                id: 'en-us',

                NUMBER_FORMATS: {
                    DECIMAL_SEP: '.',
                    GROUP_SEP: ',',
                    PATTERNS: [
                        { // Decimal Pattern
                            minInt: 1,
                            minFrac: 0,
                            maxFrac: 3,
                            posPre: '',
                            posSuf: '',
                            negPre: '-',
                            negSuf: '',
                            gSize: 3,
                            lgSize: 3
                        },{ //Currency Pattern
                            minInt: 1,
                            minFrac: 2,
                            maxFrac: 2,
                            posPre: '\u00A4',
                            posSuf: '',
                            negPre: '(\u00A4',
                            negSuf: ')',
                            gSize: 3,
                            lgSize: 3
                        }
                    ],
                    CURRENCY_SYM: '$'
                },

                DATETIME_FORMATS: {
                    MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'
                        .split(','),
                    SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
                    DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
                    SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),
                    AMPMS: ['AM','PM'],
                    medium: 'MMM d, y h:mm:ss a',
                    short: 'M/d/yy h:mm a',
                    fullDate: 'EEEE, MMMM d, y',
                    longDate: 'MMMM d, y',
                    mediumDate: 'MMM d, y',
                    shortDate: 'M/d/yy',
                    mediumTime: 'h:mm:ss a',
                    shortTime: 'h:mm a'
                },

                pluralCat: function(num) {
                    if (num === 1) {
                        return 'one';
                    }
                    return 'other';
                }
            };
        };
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$filterProvider
     * @description
     *
     * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To
     * achieve this a filter definition consists of a factory function which is annotated with dependencies and is
     * responsible for creating a the filter function.
     *
     * <pre>
     *   // Filter registration
     *   function MyModule($provide, $filterProvider) {
     *     // create a service to demonstrate injection (not always needed)
     *     $provide.value('greet', function(name){
     *       return 'Hello ' + name + '!':
     *     });
     *
     *     // register a filter factory which uses the
     *     // greet service to demonstrate DI.
     *     $filterProvider.register('greet', function(greet){
     *       // return the filter function which uses the greet service
     *       // to generate salutation
     *       return function(text) {
     *         // filters need to be forgiving so check input validity
     *         return text && greet(text) || text;
     *       };
     *     };
     *   }
     * </pre>
     *
     * The filter function is registered with the `$injector` under the filter name suffixe with `Filter`.
     * <pre>
     *   it('should be the same instance', inject(
     *     function($filterProvider) {
     *       $filterProvider.register('reverse', function(){
     *         return ...;
     *       });
     *     },
     *     function($filter, reverseFilter) {
     *       expect($filter('reverse')).toBe(reverseFilter);
     *     });
     * </pre>
     *
     *
     * For more information about how angular filters work, and how to create your own filters, see
     * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer
     * Guide.
     */
    /**
     * @ngdoc method
     * @name angular.module.ng.$filterProvider#register
     * @methodOf angular.module.ng.$filterProvider
     * @description
     * Register filter factory function.
     *
     * @param {String} name Name of the filter.
     * @param {function} fn The filter factory function which is injectable.
     */


    /**
     * @ngdoc function
     * @name angular.module.ng.$filter
     * @function
     * @description
     * Filters are used for formatting data displayed to the user.
     *
     * The general syntax in templates is as follows:
     *
     *         {{ expression | [ filter_name ] }}
     *
     * @param {String} name Name of the filter function to retrieve
     * @return {Function} the filter function
     */
    $FilterProvider.$inject = ['$provide'];
    function $FilterProvider($provide) {
        var suffix = 'Filter';

        function register(name, factory) {
            return $provide.factory(name + suffix, factory);
        }
        this.register = register;

        this.$get = ['$injector', function($injector) {
            return function(name) {
                return $injector.get(name + suffix);
            }
        }];

        ////////////////////////////////////////

        register('currency', currencyFilter);
        register('date', dateFilter);
        register('filter', filterFilter);
        register('json', jsonFilter);
        register('limitTo', limitToFilter);
        register('linky', linkyFilter);
        register('lowercase', lowercaseFilter);
        register('number', numberFilter);
        register('orderBy', orderByFilter);
        register('uppercase', uppercaseFilter);
    }

    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.filter
     * @function
     *
     * @description
     * Selects a subset of items from `array` and returns it as a new array.
     *
     * Note: This function is used to augment the `Array` type in Angular expressions. See
     * {@link angular.module.ng.$filter} for more information about Angular arrays.
     *
     * @param {Array} array The source array.
     * @param {string|Object|function()} expression The predicate to be used for selecting items from
     *   `array`.
     *
     *   Can be one of:
     *
     *   - `string`: Predicate that results in a substring match using the value of `expression`
     *     string. All strings or objects with string properties in `array` that contain this string
     *     will be returned. The predicate can be negated by prefixing the string with `!`.
     *
     *   - `Object`: A pattern object can be used to filter specific properties on objects contained
     *     by `array`. For example `{name:"M", phone:"1"}` predicate will return an array of items
     *     which have property `name` containing "M" and property `phone` containing "1". A special
     *     property name `$` can be used (as in `{$:"text"}`) to accept a match against any
     *     property of the object. That's equivalent to the simple substring match with a `string`
     *     as described above.
     *
     *   - `function`: A predicate function can be used to write arbitrary filters. The function is
     *     called for each element of `array`. The final result is an array of those elements that
     *     the predicate returned true for.
     *
     * @example
     <doc:example>
     <doc:source>
     <div ng-init="friends = [{name:'John', phone:'555-1276'},
     {name:'Mary', phone:'800-BIG-MARY'},
     {name:'Mike', phone:'555-4321'},
     {name:'Adam', phone:'555-5678'},
     {name:'Julie', phone:'555-8765'}]"></div>

     Search: <input ng-model="searchText" ng-model-instant>
     <table id="searchTextResults">
     <tr><th>Name</th><th>Phone</th><tr>
     <tr ng-repeat="friend in friends | filter:searchText">
     <td>{{friend.name}}</td>
     <td>{{friend.phone}}</td>
     <tr>
     </table>
     <hr>
     Any: <input ng-model="search.$" ng-model-instant> <br>
     Name only <input ng-model="search.name" ng-model-instant><br>
     Phone only <input ng-model="search.phone" ng-model-instant><br>
     <table id="searchObjResults">
     <tr><th>Name</th><th>Phone</th><tr>
     <tr ng-repeat="friend in friends | filter:search">
     <td>{{friend.name}}</td>
     <td>{{friend.phone}}</td>
     <tr>
     </table>
     </doc:source>
     <doc:scenario>
     it('should search across all fields when filtering with a string', function() {
     input('searchText').enter('m');
     expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
     toEqual(['Mary', 'Mike', 'Adam']);

     input('searchText').enter('76');
     expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).
     toEqual(['John', 'Julie']);
     });

     it('should search in specific fields when filtering with a predicate object', function() {
     input('search.$').enter('i');
     expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).
     toEqual(['Mary', 'Mike', 'Julie']);
     });
     </doc:scenario>
     </doc:example>
     */
    function filterFilter() {
        return function(array, expression) {
            if (!(array instanceof Array)) return array;
            var predicates = [];
            predicates.check = function(value) {
                for (var j = 0; j < predicates.length; j++) {
                    if(!predicates[j](value)) {
                        return false;
                    }
                }
                return true;
            };
            var search = function(obj, text){
                if (text.charAt(0) === '!') {
                    return !search(obj, text.substr(1));
                }
                switch (typeof obj) {
                    case "boolean":
                    case "number":
                    case "string":
                        return ('' + obj).toLowerCase().indexOf(text) > -1;
                    case "object":
                        for ( var objKey in obj) {
                            if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {
                                return true;
                            }
                        }
                        return false;
                    case "array":
                        for ( var i = 0; i < obj.length; i++) {
                            if (search(obj[i], text)) {
                                return true;
                            }
                        }
                        return false;
                    default:
                        return false;
                }
            };
            switch (typeof expression) {
                case "boolean":
                case "number":
                case "string":
                    expression = {$:expression};
                case "object":
                    for (var key in expression) {
                        if (key == '$') {
                            (function() {
                                var text = (''+expression[key]).toLowerCase();
                                if (!text) return;
                                predicates.push(function(value) {
                                    return search(value, text);
                                });
                            })();
                        } else {
                            (function() {
                                var path = key;
                                var text = (''+expression[key]).toLowerCase();
                                if (!text) return;
                                predicates.push(function(value) {
                                    return search(getter(value, path), text);
                                });
                            })();
                        }
                    }
                    break;
                case 'function':
                    predicates.push(expression);
                    break;
                default:
                    return array;
            }
            var filtered = [];
            for ( var j = 0; j < array.length; j++) {
                var value = array[j];
                if (predicates.check(value)) {
                    filtered.push(value);
                }
            }
            return filtered;
        }
    }

    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.currency
     * @function
     *
     * @description
     * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default
     * symbol for current locale is used.
     *
     * @param {number} amount Input to filter.
     * @param {string=} symbol Currency symbol or identifier to be displayed.
     * @returns {string} Formatted number.
     *
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.amount = 1234.56;
     }
     </script>
     <div ng-controller="Ctrl">
     <input type="number" ng-model="amount" ng-model-instant> <br>
     default currency symbol ($): {{amount | currency}}<br>
     custom currency identifier (USD$): {{amount | currency:"USD$"}}
     </div>
     </doc:source>
     <doc:scenario>
     it('should init with 1234.56', function() {
     expect(binding('amount | currency')).toBe('$1,234.56');
     expect(binding('amount | currency:"USD$"')).toBe('USD$1,234.56');
     });
     it('should update', function() {
     input('amount').enter('-1234');
     expect(binding('amount | currency')).toBe('($1,234.00)');
     expect(binding('amount | currency:"USD$"')).toBe('(USD$1,234.00)');
     });
     </doc:scenario>
     </doc:example>
     */
    currencyFilter.$inject = ['$locale'];
    function currencyFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(amount, currencySymbol){
            if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;
            return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).
                replace(/\u00A4/g, currencySymbol);
        };
    }

    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.number
     * @function
     *
     * @description
     * Formats a number as text.
     *
     * If the input is not a number an empty string is returned.
     *
     * @param {number|string} number Number to format.
     * @param {(number|string)=} [fractionSize=2] Number of decimal places to round the number to.
     * @returns {string} Number rounded to decimalPlaces and places a “,” after each third digit.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.val = 1234.56789;
     }
     </script>
     <div ng-controller="Ctrl">
     Enter number: <input ng-model='val' ng-model-instant><br>
     Default formatting: {{val | number}}<br>
     No fractions: {{val | number:0}}<br>
     Negative number: {{-val | number:4}}
     </div>
     </doc:source>
     <doc:scenario>
     it('should format numbers', function() {
     expect(binding('val | number')).toBe('1,234.568');
     expect(binding('val | number:0')).toBe('1,235');
     expect(binding('-val | number:4')).toBe('-1,234.5679');
     });

     it('should update', function() {
     input('val').enter('3374.333');
     expect(binding('val | number')).toBe('3,374.333');
     expect(binding('val | number:0')).toBe('3,374');
     expect(binding('-val | number:4')).toBe('-3,374.3330');
     });
     </doc:scenario>
     </doc:example>
     */


    numberFilter.$inject = ['$locale'];
    function numberFilter($locale) {
        var formats = $locale.NUMBER_FORMATS;
        return function(number, fractionSize) {
            return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,
                fractionSize);
        };
    }

    var DECIMAL_SEP = '.';
    function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
        if (isNaN(number) || !isFinite(number)) return '';

        var isNegative = number < 0;
        number = Math.abs(number);
        var numStr = number + '',
            formatedText = '',
            parts = [];

        if (numStr.indexOf('e') !== -1) {
            formatedText = numStr;
        } else {
            var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;

            // determine fractionSize if it is not specified
            if (isUndefined(fractionSize)) {
                fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);
            }

            var pow = Math.pow(10, fractionSize);
            number = Math.round(number * pow) / pow;
            var fraction = ('' + number).split(DECIMAL_SEP);
            var whole = fraction[0];
            fraction = fraction[1] || '';

            var pos = 0,
                lgroup = pattern.lgSize,
                group = pattern.gSize;

            if (whole.length >= (lgroup + group)) {
                pos = whole.length - lgroup;
                for (var i = 0; i < pos; i++) {
                    if ((pos - i)%group === 0 && i !== 0) {
                        formatedText += groupSep;
                    }
                    formatedText += whole.charAt(i);
                }
            }

            for (i = pos; i < whole.length; i++) {
                if ((whole.length - i)%lgroup === 0 && i !== 0) {
                    formatedText += groupSep;
                }
                formatedText += whole.charAt(i);
            }

            // format fraction part.
            while(fraction.length < fractionSize) {
                fraction += '0';
            }

            if (fractionSize) formatedText += decimalSep + fraction.substr(0, fractionSize);
        }

        parts.push(isNegative ? pattern.negPre : pattern.posPre);
        parts.push(formatedText);
        parts.push(isNegative ? pattern.negSuf : pattern.posSuf);
        return parts.join('');
    }

    function padNumber(num, digits, trim) {
        var neg = '';
        if (num < 0) {
            neg =  '-';
            num = -num;
        }
        num = '' + num;
        while(num.length < digits) num = '0' + num;
        if (trim)
            num = num.substr(num.length - digits);
        return neg + num;
    }


    function dateGetter(name, size, offset, trim) {
        return function(date) {
            var value = date['get' + name]();
            if (offset > 0 || value > -offset)
                value += offset;
            if (value === 0 && offset == -12 ) value = 12;
            return padNumber(value, size, trim);
        };
    }

    function dateStrGetter(name, shortForm) {
        return function(date, formats) {
            var value = date['get' + name]();
            var get = uppercase(shortForm ? ('SHORT' + name) : name);

            return formats[get][value];
        };
    }

    function timeZoneGetter(date) {
        var offset = date.getTimezoneOffset();
        return padNumber(offset / 60, 2) + padNumber(Math.abs(offset % 60), 2);
    }

    function ampmGetter(date, formats) {
        return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
    }

    var DATE_FORMATS = {
        yyyy: dateGetter('FullYear', 4),
        yy: dateGetter('FullYear', 2, 0, true),
        y: dateGetter('FullYear', 1),
        MMMM: dateStrGetter('Month'),
        MMM: dateStrGetter('Month', true),
        MM: dateGetter('Month', 2, 1),
        M: dateGetter('Month', 1, 1),
        dd: dateGetter('Date', 2),
        d: dateGetter('Date', 1),
        HH: dateGetter('Hours', 2),
        H: dateGetter('Hours', 1),
        hh: dateGetter('Hours', 2, -12),
        h: dateGetter('Hours', 1, -12),
        mm: dateGetter('Minutes', 2),
        m: dateGetter('Minutes', 1),
        ss: dateGetter('Seconds', 2),
        s: dateGetter('Seconds', 1),
        EEEE: dateStrGetter('Day'),
        EEE: dateStrGetter('Day', true),
        a: ampmGetter,
        Z: timeZoneGetter
    };

    var DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,
        NUMBER_STRING = /^\d+$/;

    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.date
     * @function
     *
     * @description
     *   Formats `date` to a string based on the requested `format`.
     *
     *   `format` string can be composed of the following elements:
     *
     *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)
     *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)
     *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)
     *   * `'MMMM'`: Month in year (January-December)
     *   * `'MMM'`: Month in year (Jan-Dec)
     *   * `'MM'`: Month in year, padded (01-12)
     *   * `'M'`: Month in year (1-12)
     *   * `'dd'`: Day in month, padded (01-31)
     *   * `'d'`: Day in month (1-31)
     *   * `'EEEE'`: Day in Week,(Sunday-Saturday)
     *   * `'EEE'`: Day in Week, (Sun-Sat)
     *   * `'HH'`: Hour in day, padded (00-23)
     *   * `'H'`: Hour in day (0-23)
     *   * `'hh'`: Hour in am/pm, padded (01-12)
     *   * `'h'`: Hour in am/pm, (1-12)
     *   * `'mm'`: Minute in hour, padded (00-59)
     *   * `'m'`: Minute in hour (0-59)
     *   * `'ss'`: Second in minute, padded (00-59)
     *   * `'s'`: Second in minute (0-59)
     *   * `'a'`: am/pm marker
     *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-1200)
     *
     *   `format` string can also be one of the following predefined
     *   {@link guide/dev_guide.i18n localizable formats}:
     *
     *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale
     *     (e.g. Sep 3, 2010 12:05:08 pm)
     *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)
     *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale
     *     (e.g. Friday, September 3, 2010)
     *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010
     *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)
     *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)
     *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)
     *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)
     *
     *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.
     *   `"h 'in the morning'"`). In order to output single quote, use two single quotes in a sequence
     *   (e.g. `"h o''clock"`).
     *
     * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or
     *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and it's
     *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ).
     * @param {string=} format Formatting rules (see Description). If not specified,
     *    `mediumDate` is used.
     * @returns {string} Formatted string or the input if input is not recognized as date/millis.
     *
     * @example
     <doc:example>
     <doc:source>
     <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:
     {{1288323623006 | date:'medium'}}<br>
     <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:
     {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>
     <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:
     {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>
     </doc:source>
     <doc:scenario>
     it('should format date', function() {
     expect(binding("1288323623006 | date:'medium'")).
     toMatch(/Oct 2\d, 2010 \d{1,2}:\d{2}:\d{2} (AM|PM)/);
     expect(binding("1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'")).
     toMatch(/2010\-10\-2\d \d{2}:\d{2}:\d{2} \-?\d{4}/);
     expect(binding("'1288323623006' | date:'MM/dd/yyyy @ h:mma'")).
     toMatch(/10\/2\d\/2010 @ \d{1,2}:\d{2}(AM|PM)/);
     });
     </doc:scenario>
     </doc:example>
     */
    dateFilter.$inject = ['$locale'];
    function dateFilter($locale) {


        var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d{3}))?)?)?(Z|([+-])(\d\d):?(\d\d)))?$/;
        function jsonStringToDate(string){
            var match;
            if (match = string.match(R_ISO8601_STR)) {
                var date = new Date(0),
                    tzHour = 0,
                    tzMin  = 0;
                if (match[9]) {
                    tzHour = int(match[9] + match[10]);
                    tzMin = int(match[9] + match[11]);
                }
                date.setUTCFullYear(int(match[1]), int(match[2]) - 1, int(match[3]));
                date.setUTCHours(int(match[4]||0) - tzHour, int(match[5]||0) - tzMin, int(match[6]||0), int(match[7]||0));
                return date;
            }
            return string;
        }


        return function(date, format) {
            var text = '',
                parts = [],
                fn, match;

            format = format || 'mediumDate'
            format = $locale.DATETIME_FORMATS[format] || format;
            if (isString(date)) {
                if (NUMBER_STRING.test(date)) {
                    date = int(date);
                } else {
                    date = jsonStringToDate(date);
                }
            }

            if (isNumber(date)) {
                date = new Date(date);
            }

            if (!isDate(date)) {
                return date;
            }

            while(format) {
                match = DATE_FORMATS_SPLIT.exec(format);
                if (match) {
                    parts = concat(parts, match, 1);
                    format = parts.pop();
                } else {
                    parts.push(format);
                    format = null;
                }
            }

            forEach(parts, function(value){
                fn = DATE_FORMATS[value];
                text += fn ? fn(date, $locale.DATETIME_FORMATS)
                    : value.replace(/(^'|'$)/g, '').replace(/''/g, "'");
            });

            return text;
        };
    }


    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.json
     * @function
     *
     * @description
     *   Allows you to convert a JavaScript object into JSON string.
     *
     *   This filter is mostly useful for debugging. When using the double curly {{value}} notation
     *   the binding is automatically converted to JSON.
     *
     * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.
     * @returns {string} JSON string.
     *
     * @css ng-monospace Always applied to the encapsulating element.
     *
     * @example:
     <doc:example>
     <doc:source>
     <pre>{{ {'name':'value'} | json }}</pre>
     </doc:source>
     <doc:scenario>
     it('should jsonify filtered objects', function() {
     expect(binding("{'name':'value'}")).toMatch(/\{\n  "name": ?"value"\n}/);
     });
     </doc:scenario>
     </doc:example>
     *
     */
    function jsonFilter() {
        return function(object) {
            return toJson(object, true);
        };
    }


    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.lowercase
     * @function
     * @description
     * Converts string to lowercase.
     * @see angular.lowercase
     */
    var lowercaseFilter = valueFn(lowercase);


    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.uppercase
     * @function
     * @description
     * Converts string to uppercase.
     * @see angular.uppercase
     */
    var uppercaseFilter = valueFn(uppercase);


    /**
     * @ngdoc filter
     * @name angular.module.ng.$filter.linky
     * @function
     *
     * @description
     *   Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
     *   plain email address links.
     *
     * @param {string} text Input text.
     * @returns {string} Html-linkified text.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.snippet =
     'Pretty text with some links:\n'+
     'http://angularjs.org/,\n'+
     'mailto:us@somewhere.org,\n'+
     'another@somewhere.org,\n'+
     'and one more: ftp://127.0.0.1/.';
     }
     </script>
     <div ng-controller="Ctrl">
     Snippet: <textarea ng-model="snippet" ng-model-instant cols="60" rows="3"></textarea>
     <table>
     <tr>
     <td>Filter</td>
     <td>Source</td>
     <td>Rendered</td>
     </tr>
     <tr id="linky-filter">
     <td>linky filter</td>
     <td>
     <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
     </td>
     <td>
     <div ng-bind-html="snippet | linky"></div>
     </td>
     </tr>
     <tr id="escaped-html">
     <td>no filter</td>
     <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
     <td><div ng-bind="snippet"></div></td>
     </tr>
     </table>
     </doc:source>
     <doc:scenario>
     it('should linkify the snippet with urls', function() {
     expect(using('#linky-filter').binding('snippet | linky')).
     toBe('Pretty text with some links:&#10;' +
     '<a href="http://angularjs.org/">http://angularjs.org/</a>,&#10;' +
     '<a href="mailto:us@somewhere.org">us@somewhere.org</a>,&#10;' +
     '<a href="mailto:another@somewhere.org">another@somewhere.org</a>,&#10;' +
     'and one more: <a href="ftp://127.0.0.1/">ftp://127.0.0.1/</a>.');
     });

     it ('should not linkify snippet without the linky filter', function() {
     expect(using('#escaped-html').binding('snippet')).
     toBe("Pretty text with some links:\n" +
     "http://angularjs.org/,\n" +
     "mailto:us@somewhere.org,\n" +
     "another@somewhere.org,\n" +
     "and one more: ftp://127.0.0.1/.");
     });

     it('should update', function() {
     input('snippet').enter('new http://link.');
     expect(using('#linky-filter').binding('snippet | linky')).
     toBe('new <a href="http://link">http://link</a>.');
     expect(using('#escaped-html').binding('snippet')).toBe('new http://link.');
     });
     </doc:scenario>
     </doc:example>
     */
    function linkyFilter() {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s\.\;\,\(\)\{\}\<\>]/,
            MAILTO_REGEXP = /^mailto:/;

        return function(text) {
            if (!text) return text;
            var match;
            var raw = text;
            var html = [];
            var writer = htmlSanitizeWriter(html);
            var url;
            var i;
            while ((match = raw.match(LINKY_URL_REGEXP))) {
                // We can not end in these as they are sometimes found at the end of the sentence
                url = match[0];
                // if we did not match ftp/http/mailto then assume mailto
                if (match[2] == match[3]) url = 'mailto:' + url;
                i = match.index;
                writer.chars(raw.substr(0, i));
                writer.start('a', {href:url});
                writer.chars(match[0].replace(MAILTO_REGEXP, ''));
                writer.end('a');
                raw = raw.substring(i + match[0].length);
            }
            writer.chars(raw);
            return html.join('');
        };
    };

    /**
     * @ngdoc function
     * @name angular.module.ng.$filter.limitTo
     * @function
     *
     * @description
     * Creates a new array containing only a specified number of elements in an array. The elements
     * are taken from either the beginning or the end of the source array, as specified by the
     * value and sign (positive or negative) of `limit`.
     *
     * Note: This function is used to augment the `Array` type in Angular expressions. See
     * {@link angular.module.ng.$filter} for more information about Angular arrays.
     *
     * @param {Array} array Source array to be limited.
     * @param {string|Number} limit The length of the returned array. If the `limit` number is
     *     positive, `limit` number of items from the beginning of the source array are copied.
     *     If the number is negative, `limit` number  of items from the end of the source array are
     *     copied. The `limit` will be trimmed if it exceeds `array.length`
     * @returns {Array} A new sub-array of length `limit` or less if input array had less than `limit`
     *     elements.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.numbers = [1,2,3,4,5,6,7,8,9];
     $scope.limit = 3;
     }
     </script>
     <div ng-controller="Ctrl">
     Limit {{numbers}} to: <input type="integer" ng-model="limit" ng-model-instant>
     <p>Output: {{ numbers | limitTo:limit }}</p>
     </div>
     </doc:source>
     <doc:scenario>
     it('should limit the numer array to first three items', function() {
     expect(element('.doc-example-live input[ng-model=limit]').val()).toBe('3');
     expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3]');
     });

     it('should update the output when -3 is entered', function() {
     input('limit').enter(-3);
     expect(binding('numbers | limitTo:limit')).toEqual('[7,8,9]');
     });

     it('should not exceed the maximum size of input array', function() {
     input('limit').enter(100);
     expect(binding('numbers | limitTo:limit')).toEqual('[1,2,3,4,5,6,7,8,9]');
     });
     </doc:scenario>
     </doc:example>
     */
    function limitToFilter(){
        return function(array, limit) {
            if (!(array instanceof Array)) return array;
            limit = int(limit);
            var out = [],
                i, n;

            // check that array is iterable
            if (!array || !(array instanceof Array))
                return out;

            // if abs(limit) exceeds maximum length, trim it
            if (limit > array.length)
                limit = array.length;
            else if (limit < -array.length)
                limit = -array.length;

            if (limit > 0) {
                i = 0;
                n = limit;
            } else {
                i = array.length + limit;
                n = array.length;
            }

            for (; i<n; i++) {
                out.push(array[i]);
            }

            return out;
        }
    }

    /**
     * @ngdoc function
     * @name angular.module.ng.$filter.orderBy
     * @function
     *
     * @description
     * Orders a specified `array` by the `expression` predicate.
     *
     * Note: this function is used to augment the `Array` type in Angular expressions. See
     * {@link angular.module.ng.$filter} for more informaton about Angular arrays.
     *
     * @param {Array} array The array to sort.
     * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be
     *    used by the comparator to determine the order of elements.
     *
     *    Can be one of:
     *
     *    - `function`: Getter function. The result of this function will be sorted using the
     *      `<`, `=`, `>` operator.
     *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'
     *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control
     *      ascending or descending sort order (for example, +name or -name).
     *    - `Array`: An array of function or string predicates. The first predicate in the array
     *      is used for sorting, but when two items are equivalent, the next predicate is used.
     *
     * @param {boolean=} reverse Reverse the order the array.
     * @returns {Array} Sorted copy of the source array.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.friends =
     [{name:'John', phone:'555-1212', age:10},
     {name:'Mary', phone:'555-9876', age:19},
     {name:'Mike', phone:'555-4321', age:21},
     {name:'Adam', phone:'555-5678', age:35},
     {name:'Julie', phone:'555-8765', age:29}]
     $scope.predicate = '-age';
     }
     </script>
     <div ng-controller="Ctrl">
     <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>
     <hr/>
     [ <a href="" ng-click="predicate=''">unsorted</a> ]
     <table class="friend">
     <tr>
     <th><a href="" ng-click="predicate = 'name'; reverse=false">Name</a>
     (<a href ng-click="predicate = '-name'; reverse=false">^</a>)</th>
     <th><a href="" ng-click="predicate = 'phone'; reverse=!reverse">Phone Number</a></th>
     <th><a href="" ng-click="predicate = 'age'; reverse=!reverse">Age</a></th>
     <tr>
     <tr ng-repeat="friend in friends | orderBy:predicate:reverse">
     <td>{{friend.name}}</td>
     <td>{{friend.phone}}</td>
     <td>{{friend.age}}</td>
     <tr>
     </table>
     </div>
     </doc:source>
     <doc:scenario>
     it('should be reverse ordered by aged', function() {
     expect(binding('predicate')).toBe('-age');
     expect(repeater('table.friend', 'friend in friends').column('friend.age')).
     toEqual(['35', '29', '21', '19', '10']);
     expect(repeater('table.friend', 'friend in friends').column('friend.name')).
     toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);
     });

     it('should reorder the table when user selects different predicate', function() {
     element('.doc-example-live a:contains("Name")').click();
     expect(repeater('table.friend', 'friend in friends').column('friend.name')).
     toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);
     expect(repeater('table.friend', 'friend in friends').column('friend.age')).
     toEqual(['35', '10', '29', '19', '21']);

     element('.doc-example-live a:contains("Phone")').click();
     expect(repeater('table.friend', 'friend in friends').column('friend.phone')).
     toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);
     expect(repeater('table.friend', 'friend in friends').column('friend.name')).
     toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);
     });
     </doc:scenario>
     </doc:example>
     */
    orderByFilter.$inject = ['$parse'];
    function orderByFilter($parse){
        return function(array, sortPredicate, reverseOrder) {
            if (!(array instanceof Array)) return array;
            if (!sortPredicate) return array;
            sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];
            sortPredicate = map(sortPredicate, function(predicate){
                var descending = false, get = predicate || identity;
                if (isString(predicate)) {
                    if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {
                        descending = predicate.charAt(0) == '-';
                        predicate = predicate.substring(1);
                    }
                    get = $parse(predicate);
                }
                return reverseComparator(function(a,b){
                    return compare(get(a),get(b));
                }, descending);
            });
            var arrayCopy = [];
            for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }
            return arrayCopy.sort(reverseComparator(comparator, reverseOrder));

            function comparator(o1, o2){
                for ( var i = 0; i < sortPredicate.length; i++) {
                    var comp = sortPredicate[i](o1, o2);
                    if (comp !== 0) return comp;
                }
                return 0;
            }
            function reverseComparator(comp, descending) {
                return toBoolean(descending)
                    ? function(a,b){return comp(b,a);}
                    : comp;
            }
            function compare(v1, v2){
                var t1 = typeof v1;
                var t2 = typeof v2;
                if (t1 == t2) {
                    if (t1 == "string") v1 = v1.toLowerCase();
                    if (t1 == "string") v2 = v2.toLowerCase();
                    if (v1 === v2) return 0;
                    return v1 < v2 ? -1 : 1;
                } else {
                    return t1 < t2 ? -1 : 1;
                }
            }
        }
    }

    function ngDirective(directive) {
        if (isFunction(directive)) {
            directive = {
                link: directive
            }
        }
        directive.restrict = directive.restrict || 'AC';
        return valueFn(directive);
    };

    /*
     * Modifies the default behavior of html A tag, so that the default action is prevented when href
     * attribute is empty.
     *
     * The reasoning for this change is to allow easy creation of action links with ng-click without
     * changing the location or causing page reloads, e.g.:
     * <a href="" ng-click="model.$save()">Save</a>
     */
    var htmlAnchorDirective = valueFn({
        restrict: 'E',
        compile: function(element, attr) {
            // turn <a href ng-click="..">link</a> into a link in IE
            // but only if it doesn't have name attribute, in which case it's an anchor
            if (!attr.href) {
                attr.$set('href', '');
            }

            return function(scope, element) {
                element.bind('click', function(event){
                    // if we have no href url, then don't navigate anywhere.
                    if (!element.attr('href')) {
                        event.preventDefault();
                    }
                });
            }
        }
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-href
     * @restrict A
     *
     * @description
     * Using <angular/> markup like {{hash}} in an href attribute makes
     * the page open to a wrong URL, if the user clicks that link before
     * angular has a chance to replace the {{hash}} with actual URL, the
     * link will be broken and will most likely return a 404 error.
     * The `ng-href` solves this problem by placing the `href` in the
     * `ng-` namespace.
     *
     * The buggy way to write it:
     * <pre>
     * <a href="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * The correct way to write it:
     * <pre>
     * <a ng-href="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * @element A
     * @param {template} ng-href any string which can contain `{{}}` markup.
     *
     * @example
     * This example uses `link` variable inside `href` attribute:
     <doc:example>
     <doc:source>
     <input ng-model="value" /><br />
     <a id="link-1" href ng-click="value = 1">link 1</a> (link, don't reload)<br />
     <a id="link-2" href="" ng-click="value = 2">link 2</a> (link, don't reload)<br />
     <a id="link-3" ng-href="/{{'123'}}" ng-ext-link>link 3</a> (link, reload!)<br />
     <a id="link-4" href="" name="xx" ng-click="value = 4">anchor</a> (link, don't reload)<br />
     <a id="link-5" name="xxx" ng-click="value = 5">anchor</a> (no link)<br />
     <a id="link-6" ng-href="/{{value}}" ng-ext-link>link</a> (link, change hash)
     </doc:source>
     <doc:scenario>
     it('should execute ng-click but not reload when href without value', function() {
     element('#link-1').click();
     expect(input('value').val()).toEqual('1');
     expect(element('#link-1').attr('href')).toBe("");
     });

     it('should execute ng-click but not reload when href empty string', function() {
     element('#link-2').click();
     expect(input('value').val()).toEqual('2');
     expect(element('#link-2').attr('href')).toBe("");
     });

     it('should execute ng-click and change url when ng-href specified', function() {
     expect(element('#link-3').attr('href')).toBe("/123");

     element('#link-3').click();
     expect(browser().window().path()).toEqual('/123');
     });

     it('should execute ng-click but not reload when href empty string and name specified', function() {
     element('#link-4').click();
     expect(input('value').val()).toEqual('4');
     expect(element('#link-4').attr('href')).toBe("");
     });

     it('should execute ng-click but not reload when no href but name specified', function() {
     element('#link-5').click();
     expect(input('value').val()).toEqual('5');
     expect(element('#link-5').attr('href')).toBe("");
     });

     it('should only change url when only ng-href', function() {
     input('value').enter('6');
     expect(element('#link-6').attr('href')).toBe("/6");

     element('#link-6').click();
     expect(browser().window().path()).toEqual('/6');
     });
     </doc:scenario>
     </doc:example>
     */

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-src
     * @restrict A
     *
     * @description
     * Using <angular/> markup like `{{hash}}` in a `src` attribute doesn't
     * work right: The browser will fetch from the URL with the literal
     * text `{{hash}}` until <angular/> replaces the expression inside
     * `{{hash}}`. The `ng-src` attribute solves this problem by placing
     *  the `src` attribute in the `ng-` namespace.
     *
     * The buggy way to write it:
     * <pre>
     * <img src="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * The correct way to write it:
     * <pre>
     * <img ng-src="http://www.gravatar.com/avatar/{{hash}}"/>
     * </pre>
     *
     * @element IMG
     * @param {template} ng-src any string which can contain `{{}}` markup.
     */

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-disabled
     * @restrict A
     *
     * @description
     *
     * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:
     * <pre>
     * <div ng-init="scope = { isDisabled: false }">
     *  <button disabled="{{scope.isDisabled}}">Disabled</button>
     * </div>
     * </pre>
     *
     * The HTML specs do not require browsers to preserve the special attributes such as disabled.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce ng-disabled.
     *
     * @example
     <doc:example>
     <doc:source>
     Click me to toggle: <input type="checkbox" ng-model="checked"><br/>
     <button ng-model="button" ng-disabled="checked">Button</button>
     </doc:source>
     <doc:scenario>
     it('should toggle button', function() {
     expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();
     input('checked').check();
     expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();
     });
     </doc:scenario>
     </doc:example>
     *
     * @element INPUT
     * @param {string} expression Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-checked
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as checked.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce ng-checked.
     * @example
     <doc:example>
     <doc:source>
     Check me to check both: <input type="checkbox" ng-model="master"><br/>
     <input id="checkSlave" type="checkbox" ng-checked="master">
     </doc:source>
     <doc:scenario>
     it('should check both checkBoxes', function() {
     expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();
     input('master').check();
     expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();
     });
     </doc:scenario>
     </doc:example>
     *
     * @element INPUT
     * @param {string} expression Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-multiple
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as multiple.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce ng-multiple.
     *
     * @example
     <doc:example>
     <doc:source>
     Check me check multiple: <input type="checkbox" ng-model="checked"><br/>
     <select id="select" ng-multiple="checked">
     <option>Misko</option>
     <option>Igor</option>
     <option>Vojta</option>
     <option>Di</option>
     </select>
     </doc:source>
     <doc:scenario>
     it('should toggle multiple', function() {
     expect(element('.doc-example-live #select').prop('multiple')).toBeFalsy();
     input('checked').check();
     expect(element('.doc-example-live #select').prop('multiple')).toBeTruthy();
     });
     </doc:scenario>
     </doc:example>
     *
     * @element SELECT
     * @param {string} expression Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-readonly
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as readonly.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce ng-readonly.
     * @example
     <doc:example>
     <doc:source>
     Check me to make text readonly: <input type="checkbox" ng-model="checked"><br/>
     <input type="text" ng-readonly="checked" value="I'm Angular"/>
     </doc:source>
     <doc:scenario>
     it('should toggle readonly attr', function() {
     expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();
     input('checked').check();
     expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();
     });
     </doc:scenario>
     </doc:example>
     *
     * @element INPUT
     * @param {string} expression Angular expression that will be evaluated.
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-selected
     * @restrict A
     *
     * @description
     * The HTML specs do not require browsers to preserve the special attributes such as selected.
     * (The presence of them means true and absence means false)
     * This prevents the angular compiler from correctly retrieving the binding expression.
     * To solve this problem, we introduce ng-selected.
     * @example
     <doc:example>
     <doc:source>
     Check me to select: <input type="checkbox" ng-model="selected"><br/>
     <select>
     <option>Hello!</option>
     <option id="greet" ng-selected="selected">Greetings!</option>
     </select>
     </doc:source>
     <doc:scenario>
     it('should select Greetings!', function() {
     expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();
     input('selected').check();
     expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();
     });
     </doc:scenario>
     </doc:example>
     *
     * @element OPTION
     * @param {string} expression Angular expression that will be evaluated.
     */


    var ngAttributeAliasDirectives = {};


// boolean attrs are evaluated
    forEach(BOOLEAN_ATTR, function(propName, attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 100,
                compile: function(tpl, attr) {
                    return function(scope, element, attr) {
                        attr.$$observers[attrName] = [];
                        scope.$watch(attr[normalized], function(value) {
                            attr.$set(attrName, value);
                        });
                    };
                }
            };
        };
    });


// ng-src, ng-href are interpolated
    forEach(['src', 'href'], function(attrName) {
        var normalized = directiveNormalize('ng-' + attrName);
        ngAttributeAliasDirectives[normalized] = function() {
            return {
                priority: 100,
                compile: function(tpl, attr) {
                    return function(scope, element, attr) {
                        attr.$$observers[attrName] = [];
                        attr.$observe(normalized, function(value) {
                            attr.$set(attrName, value);
                        });
                    };
                }
            };
        };
    });

    var nullFormCtrl = {
        $addControl: noop,
        $removeControl: noop,
        $setValidity: noop,
        $setDirty: noop
    }

    /**
     * @ngdoc object
     * @name angular.module.ng.$compileProvider.directive.form.FormController
     *
     * @property {boolean} $pristine True if user has not interacted with the form yet.
     * @property {boolean} $dirty True if user has already interacted with the form.
     * @property {boolean} $valid True if all of the containg forms and controls are valid.
     * @property {boolean} $invalid True if at least one containing control or form is invalid.
     *
     * @property {Object} $error Is an object hash, containing references to all invalid controls or
     *  forms, where:
     *
     *  - keys are validation tokens (error names) — such as `REQUIRED`, `URL` or `EMAIL`),
     *  - values are arrays of controls or forms that are invalid with given error.
     *
     * @description
     * `FormController` keeps track of all its controls and nested forms as well as state of them,
     * such as being valid/invalid or dirty/pristine.
     *
     * Each {@link angular.module.ng.$compileProvider.directive.form form} directive creates an instance
     * of `FormController`.
     *
     */
//asks for $scope to fool the BC controller module
    FormController.$inject = ['$element', '$attrs', '$scope'];
    function FormController(element, attrs) {
        var form = this,
            parentForm = element.parent().controller('form') || nullFormCtrl,
            invalidCount = 0, // used to easily determine if we are valid
            errors = form.$error = {};

        // init state
        form.$name = attrs.name;
        form.$dirty = false;
        form.$pristine = true;
        form.$valid = true;
        form.$invalid = false;

        parentForm.$addControl(form);

        // Setup initial state of the control
        element.addClass(PRISTINE_CLASS);
        toggleValidCss(true);

        // convenience method for easy toggling of classes
        function toggleValidCss(isValid, validationErrorKey) {
            validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
            element.
                removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
                addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
        }

        form.$addControl = function(control) {
            if (control.$name && !form.hasOwnProperty(control.$name)) {
                form[control.$name] = control;
            }
        };

        form.$removeControl = function(control) {
            if (control.$name && form[control.$name] === control) {
                delete form[control.$name];
            }
            forEach(errors, cleanupControlErrors, control);
        };

        form.$setValidity = function(validationToken, isValid, control) {
            if (isValid) {
                cleanupControlErrors(errors[validationToken], validationToken, control);

                if (!invalidCount) {
                    toggleValidCss(isValid);
                    form.$valid = true;
                    form.$invalid = false;
                }
            } else {
                if (!invalidCount) {
                    toggleValidCss(isValid);
                }
                addControlError(validationToken, control);

                form.$valid = false;
                form.$invalid = true;
            }
        };

        form.$setDirty = function() {
            element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
            form.$dirty = true;
            form.$pristine = false;
        };

        function cleanupControlErrors(queue, validationToken, control) {
            if (queue) {
                control = control || this; // so that we can be used in forEach;
                arrayRemove(queue, control);
                if (!queue.length) {
                    invalidCount--;
                    errors[validationToken] = false;
                    toggleValidCss(true, validationToken);
                    parentForm.$setValidity(validationToken, true, form);
                }
            }
        }

        function addControlError(validationToken, control) {
            var queue = errors[validationToken];
            if (queue) {
                if (includes(queue, control)) return;
            } else {
                errors[validationToken] = queue = [];
                invalidCount++;
                toggleValidCss(false, validationToken);
                parentForm.$setValidity(validationToken, false, form);
            }
            queue.push(control);
        }
    }


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-form
     * @restrict EAC
     *
     * @description
     * Nestable alias of {@link angular.module.ng.$compileProvider.directive.form `form`} directive. HTML
     * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a
     * sub-group of controls needs to be determined.
     *
     * @param {string=} ng-form|name Name of the form. If specified, the form controller will be published into
     *                       related scope, under this name.
     *
     */

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.form
     * @restrict E
     *
     * @description
     * Directive that instantiates
     * {@link angular.module.ng.$compileProvider.directive.form.FormController FormController}.
     *
     * If `name` attribute is specified, the form controller is published onto the current scope under
     * this name.
     *
     * # Alias: {@link angular.module.ng.$compileProvider.directive.ng-form `ng-form`}
     *
     * In angular forms can be nested. This means that the outer form is valid when all of the child
     * forms are valid as well. However browsers do not allow nesting of `<form>` elements, for this
     * reason angular provides {@link angular.module.ng.$compileProvider.directive.ng-form `ng-form`} alias
     * which behaves identical to `<form>` but allows form nesting.
     *
     *
     * # CSS classes
     *  - `ng-valid` Is set if the form is valid.
     *  - `ng-invalid` Is set if the form is invalid.
     *  - `ng-pristine` Is set if the form is pristine.
     *  - `ng-dirty` Is set if the form is dirty.
     *
     *
     * # Submitting a form and preventing default action
     *
     * Since the role of forms in client-side Angular applications is different than in classical
     * roundtrip apps, it is desirable for the browser not to translate the form submission into a full
     * page reload that sends the data to the server. Instead some javascript logic should be triggered
     * to handle the form submission in application specific way.
     *
     * For this reason, Angular prevents the default action (form submission to the server) unless the
     * `<form>` element has an `action` attribute specified.
     *
     * You can use one of the following two ways to specify what javascript method should be called when
     * a form is submitted:
     *
     * - ng-submit on the form element (add link to ng-submit)
     * - ng-click on the first button or input field of type submit (input[type=submit])
     *
     * To prevent double execution of the handler, use only one of ng-submit or ng-click. This is
     * because of the following form submission rules coming from the html spec:
     *
     * - If a form has only one input field then hitting enter in this field triggers form submit
     * (`ng-submit`)
     * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter
     * doesn't trigger submit
     * - if a form has one or more input fields and one or more buttons or input[type=submit] then
     * hitting enter in any of the input fields will trigger the click handler on the *first* button or
     * input[type=submit] (`ng-click`) *and* a submit handler on the enclosing form (`ng-submit`)
     *
     * @param {string=} name Name of the form. If specified, the form controller will be published into
     *                       related scope, under this name.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.userType = 'guest';
     }
     </script>
     <form name="myForm" ng-controller="Ctrl">
     userType: <input name="input" ng-model="userType" required>
     <span class="error" ng-show="myForm.input.$error.REQUIRED">Required!</span><br>
     <tt>userType = {{userType}}</tt><br>
     <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>
     <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>
     <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
     <tt>myForm.$error.REQUIRED = {{!!myForm.$error.REQUIRED}}</tt><br>
     </form>
     </doc:source>
     <doc:scenario>
     it('should initialize to model', function() {
     expect(binding('userType')).toEqual('guest');
     expect(binding('myForm.input.$valid')).toEqual('true');
     });

     it('should be invalid if empty', function() {
     input('userType').enter('');
     expect(binding('userType')).toEqual('');
     expect(binding('myForm.input.$valid')).toEqual('false');
     });
     </doc:scenario>
     </doc:example>
     */
    var formDirectiveDir = {
        name: 'form',
        restrict: 'E',
        controller: FormController,
        compile: function() {
            return {
                pre: function(scope, formElement, attr, controller) {
                    if (!attr.action) {
                        formElement.bind('submit', function(event) {
                            event.preventDefault();
                        });
                    }

                    var parentFormCtrl = formElement.parent().controller('form'),
                        alias = attr.name || attr.ngForm;

                    if (alias) {
                        scope[alias] = controller;
                    }
                    if (parentFormCtrl) {
                        formElement.bind('$destroy', function() {
                            parentFormCtrl.$removeControl(controller);
                            if (alias) {
                                scope[alias] = undefined;
                            }
                            extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards
                        });
                    }
                }
            };
        }
    };

    var formDirective = valueFn(formDirectiveDir);
    var ngFormDirective = valueFn(extend(copy(formDirectiveDir), {restrict: 'EAC'}));

    var URL_REGEXP = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?$/;
    var EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,4}$/;
    var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))\s*$/;

    var inputType = {

        /**
         * @ngdoc inputType
         * @name angular.module.ng.$compileProvider.directive.input.text
         *
         * @description
         * Standard HTML text input with angular data binding.
         *
         * @param {string} ng-model Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} required Sets `required` validation error key if the value is not entered.
         * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         * @param {string=} ng-change Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
         $scope.text = 'guest';
         $scope.word = /^\w*$/;
         }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Single word: <input type="text" name="input" ng-model="text"
         ng-pattern="word" required>
         <span class="error" ng-show="myForm.input.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.input.$error.pattern">
         Single word only!</span>

         <tt>text = {{text}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
         expect(binding('text')).toEqual('guest');
         expect(binding('myForm.input.$valid')).toEqual('true');
         });

         it('should be invalid if empty', function() {
         input('text').enter('');
         expect(binding('text')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });

         it('should be invalid if multi word', function() {
         input('text').enter('hello world');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });
         </doc:scenario>
         </doc:example>
         */
        'text': textInputType,


        /**
         * @ngdoc inputType
         * @name angular.module.ng.$compileProvider.directive.input.number
         *
         * @description
         * Text input with number validation and transformation. Sets the `number` validation
         * error if not a valid number.
         *
         * @param {string} ng-model Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} min Sets the `min` validation error key if the value entered is less then `min`.
         * @param {string=} max Sets the `max` validation error key if the value entered is greater then `min`.
         * @param {string=} required Sets `required` validation error key if the value is not entered.
         * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         * @param {string=} ng-change Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
         $scope.value = 12;
         }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Number: <input type="number" name="input" ng-model="value"
         min="0" max="99" required>
         <span class="error" ng-show="myForm.list.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.list.$error.number">
         Not valid number!</span>
         <tt>value = {{value}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
         expect(binding('value')).toEqual('12');
         expect(binding('myForm.input.$valid')).toEqual('true');
         });

         it('should be invalid if empty', function() {
         input('value').enter('');
         expect(binding('value')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });

         it('should be invalid if over max', function() {
         input('value').enter('123');
         expect(binding('value')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });
         </doc:scenario>
         </doc:example>
         */
        'number': numberInputType,


        /**
         * @ngdoc inputType
         * @name angular.module.ng.$compileProvider.directive.input.url
         *
         * @description
         * Text input with URL validation. Sets the `url` validation error key if the content is not a
         * valid URL.
         *
         * @param {string} ng-model Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} required Sets `required` validation error key if the value is not entered.
         * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         * @param {string=} ng-change Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
         $scope.text = 'http://google.com';
         }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         URL: <input type="url" name="input" ng-model="text" required>
         <span class="error" ng-show="myForm.input.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.input.$error.url">
         Not valid url!</span>
         <tt>text = {{text}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
         expect(binding('text')).toEqual('http://google.com');
         expect(binding('myForm.input.$valid')).toEqual('true');
         });

         it('should be invalid if empty', function() {
         input('text').enter('');
         expect(binding('text')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });

         it('should be invalid if not url', function() {
         input('text').enter('xxx');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });
         </doc:scenario>
         </doc:example>
         */
        'url': urlInputType,


        /**
         * @ngdoc inputType
         * @name angular.module.ng.$compileProvider.directive.input.email
         *
         * @description
         * Text input with email validation. Sets the `email` validation error key if not a valid email
         * address.
         *
         * @param {string} ng-model Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} required Sets `required` validation error key if the value is not entered.
         * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than
         *    minlength.
         * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than
         *    maxlength.
         * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the
         *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
         *    patterns defined as scope expressions.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
         $scope.text = 'me@example.com';
         }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Email: <input type="email" name="input" ng-model="text" required>
         <span class="error" ng-show="myForm.input.$error.required">
         Required!</span>
         <span class="error" ng-show="myForm.input.$error.email">
         Not valid email!</span>
         <tt>text = {{text}}</tt><br/>
         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>
         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>
         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
         <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should initialize to model', function() {
         expect(binding('text')).toEqual('me@example.com');
         expect(binding('myForm.input.$valid')).toEqual('true');
         });

         it('should be invalid if empty', function() {
         input('text').enter('');
         expect(binding('text')).toEqual('');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });

         it('should be invalid if not email', function() {
         input('text').enter('xxx');
         expect(binding('myForm.input.$valid')).toEqual('false');
         });
         </doc:scenario>
         </doc:example>
         */
        'email': emailInputType,


        /**
         * @ngdoc inputType
         * @name angular.module.ng.$compileProvider.directive.input.radio
         *
         * @description
         * HTML radio button.
         *
         * @param {string} ng-model Assignable angular expression to data-bind to.
         * @param {string} value The value to which the expression should be set when selected.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} ng-change Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
         $scope.color = 'blue';
         }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         <input type="radio" ng-model="color" value="red">  Red <br/>
         <input type="radio" ng-model="color" value="green"> Green <br/>
         <input type="radio" ng-model="color" value="blue"> Blue <br/>
         <tt>color = {{color}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should change state', function() {
         expect(binding('color')).toEqual('blue');

         input('color').select('red');
         expect(binding('color')).toEqual('red');
         });
         </doc:scenario>
         </doc:example>
         */
        'radio': radioInputType,


        /**
         * @ngdoc inputType
         * @name angular.module.ng.$compileProvider.directive.input.checkbox
         *
         * @description
         * HTML checkbox.
         *
         * @param {string} ng-model Assignable angular expression to data-bind to.
         * @param {string=} name Property name of the form under which the control is published.
         * @param {string=} ng-true-value The value to which the expression should be set when selected.
         * @param {string=} ng-false-value The value to which the expression should be set when not selected.
         * @param {string=} ng-change Angular expression to be executed when input changes due to user
         *    interaction with the input element.
         *
         * @example
         <doc:example>
         <doc:source>
         <script>
         function Ctrl($scope) {
         $scope.value1 = true;
         $scope.value2 = 'YES'
         }
         </script>
         <form name="myForm" ng-controller="Ctrl">
         Value1: <input type="checkbox" ng-model="value1"> <br/>
         Value2: <input type="checkbox" ng-model="value2"
         ng-true-value="YES" ng-false-value="NO"> <br/>
         <tt>value1 = {{value1}}</tt><br/>
         <tt>value2 = {{value2}}</tt><br/>
         </form>
         </doc:source>
         <doc:scenario>
         it('should change state', function() {
         expect(binding('value1')).toEqual('true');
         expect(binding('value2')).toEqual('YES');

         input('value1').check();
         input('value2').check();
         expect(binding('value1')).toEqual('false');
         expect(binding('value2')).toEqual('NO');
         });
         </doc:scenario>
         </doc:example>
         */
        'checkbox': checkboxInputType,

        'hidden': noop,
        'button': noop,
        'submit': noop,
        'reset': noop
    };


    function isEmpty(value) {
        return isUndefined(value) || value === '' || value === null || value !== value;
    }


    function textInputType(scope, element, attr, ctrl) {
        element.bind('blur', function() {
            scope.$apply(function() {
                ctrl.$setViewValue(trim(element.val()));
            });
        });

        ctrl.$render = function() {
            element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);
        };

        // pattern validator
        var pattern = attr.ngPattern,
            patternValidator;

        var validate = function(regexp, value) {
            if (isEmpty(value) || regexp.test(value)) {
                ctrl.$setValidity('pattern', true);
                return value;
            } else {
                ctrl.$setValidity('pattern', false);
                return undefined;
            }
        };

        if (pattern) {
            if (pattern.match(/^\/(.*)\/$/)) {
                pattern = new RegExp(pattern.substr(1, pattern.length - 2));
                patternValidator = function(value) {
                    return validate(pattern, value)
                };
            } else {
                patternValidator = function(value) {
                    var patternObj = scope.$eval(pattern);

                    if (!patternObj || !patternObj.test) {
                        throw new Error('Expected ' + pattern + ' to be a RegExp but was ' + patternObj);
                    }
                    return validate(patternObj, value);
                };
            }

            ctrl.$formatters.push(patternValidator);
            ctrl.$parsers.push(patternValidator);
        }

        // min length validator
        if (attr.ngMinlength) {
            var minlength = int(attr.ngMinlength);
            var minLengthValidator = function(value) {
                if (!isEmpty(value) && value.length < minlength) {
                    ctrl.$setValidity('minlength', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('minlength', true);
                    return value;
                }
            };

            ctrl.$parsers.push(minLengthValidator);
            ctrl.$formatters.push(minLengthValidator);
        }

        // max length validator
        if (attr.ngMaxlength) {
            var maxlength = int(attr.ngMaxlength);
            var maxLengthValidator = function(value) {
                if (!isEmpty(value) && value.length > maxlength) {
                    ctrl.$setValidity('maxlength', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('maxlength', true);
                    return value;
                }
            };

            ctrl.$parsers.push(maxLengthValidator);
            ctrl.$formatters.push(maxLengthValidator);
        }
    };

    function numberInputType(scope, element, attr, ctrl) {
        textInputType(scope, element, attr, ctrl);

        ctrl.$parsers.push(function(value) {
            var empty = isEmpty(value);
            if (empty || NUMBER_REGEXP.test(value)) {
                ctrl.$setValidity('number', true);
                return value === '' ? null : (empty ? value : parseFloat(value));
            } else {
                ctrl.$setValidity('number', false);
                return undefined;
            }
        });

        ctrl.$formatters.push(function(value) {
            return isEmpty(value) ? '' : '' + value;
        });

        if (attr.min) {
            var min = parseFloat(attr.min);
            var minValidator = function(value) {
                if (!isEmpty(value) && value < min) {
                    ctrl.$setValidity('min', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('min', true);
                    return value;
                }
            };

            ctrl.$parsers.push(minValidator);
            ctrl.$formatters.push(minValidator);
        }

        if (attr.max) {
            var max = parseFloat(attr.max);
            var maxValidator = function(value) {
                if (!isEmpty(value) && value > max) {
                    ctrl.$setValidity('max', false);
                    return undefined;
                } else {
                    ctrl.$setValidity('max', true);
                    return value;
                }
            };

            ctrl.$parsers.push(maxValidator);
            ctrl.$formatters.push(maxValidator);
        }

        ctrl.$formatters.push(function(value) {

            if (isEmpty(value) || isNumber(value)) {
                ctrl.$setValidity('number', true);
                return value;
            } else {
                ctrl.$setValidity('number', false);
                return undefined;
            }
        });
    }

    function urlInputType(scope, element, attr, ctrl) {
        textInputType(scope, element, attr, ctrl);

        var urlValidator = function(value) {
            if (isEmpty(value) || URL_REGEXP.test(value)) {
                ctrl.$setValidity('url', true);
                return value;
            } else {
                ctrl.$setValidity('url', false);
                return undefined;
            }
        };

        ctrl.$formatters.push(urlValidator);
        ctrl.$parsers.push(urlValidator);
    }

    function emailInputType(scope, element, attr, ctrl) {
        textInputType(scope, element, attr, ctrl);

        var emailValidator = function(value) {
            if (isEmpty(value) || EMAIL_REGEXP.test(value)) {
                ctrl.$setValidity('email', true);
                return value;
            } else {
                ctrl.$setValidity('email', false);
                return undefined;
            }
        };

        ctrl.$formatters.push(emailValidator);
        ctrl.$parsers.push(emailValidator);
    }

    function radioInputType(scope, element, attr, ctrl) {
        // correct the name
        element.attr('name', attr.id + '@' + attr.name);

        element.bind('click', function() {
            if (element[0].checked) {
                scope.$apply(function() {
                    ctrl.$setViewValue(attr.value);
                });
            };
        });

        ctrl.$render = function() {
            var value = attr.value;
            element[0].checked = (value == ctrl.$viewValue);
        };

        attr.$observe('value', ctrl.$render);
    }

    function checkboxInputType(scope, element, attr, ctrl) {
        var trueValue = attr.ngTrueValue,
            falseValue = attr.ngFalseValue;

        if (!isString(trueValue)) trueValue = true;
        if (!isString(falseValue)) falseValue = false;

        element.bind('click', function() {
            scope.$apply(function() {
                ctrl.$setViewValue(element[0].checked);
            });
        });

        ctrl.$render = function() {
            element[0].checked = ctrl.$viewValue;
        };

        ctrl.$formatters.push(function(value) {
            return value === trueValue;
        });

        ctrl.$parsers.push(function(value) {
            return value ? trueValue : falseValue;
        });
    }


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.textarea
     *
     * @description
     * HTML textarea element control with angular data-binding. The data-binding and validation
     * properties of this element are exactly the same as those of the
     * {@link angular.module.ng.$compileProvider.directive.input input element}.
     *
     * @param {string} ng-model Assignable angular expression to data-bind to.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {string=} required Sets `required` validation error key if the value is not entered.
     * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than
     *    minlength.
     * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than
     *    maxlength.
     * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the
     *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
     *    patterns defined as scope expressions.
     * @param {string=} ng-change Angular expression to be executed when input changes due to user
     *    interaction with the input element.
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.input
     * @restrict E
     *
     * @description
     * HTML input element control with angular data-binding. Input control follows HTML5 input types
     * and polyfills the HTML5 validation behavior for older browsers.
     *
     * @param {string} ng-model Assignable angular expression to data-bind to.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {string=} required Sets `required` validation error key if the value is not entered.
     * @param {number=} ng-minlength Sets `minlength` validation error key if the value is shorter than
     *    minlength.
     * @param {number=} ng-maxlength Sets `maxlength` validation error key if the value is longer than
     *    maxlength.
     * @param {string=} ng-pattern Sets `pattern` validation error key if the value does not match the
     *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for
     *    patterns defined as scope expressions.
     * @param {string=} ng-change Angular expression to be executed when input changes due to user
     *    interaction with the input element.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.user = {name: 'guest', last: 'visitor'};
     }
     </script>
     <div ng-controller="Ctrl">
     <form name="myForm">
     User name: <input type="text" name="userName" ng-model="user.name" required>
     <span class="error" ng-show="myForm.userName.$error.required">
     Required!</span><br>
     Last name: <input type="text" name="lastName" ng-model="user.last"
     ng-minlength="3" ng-maxlength="10">
     <span class="error" ng-show="myForm.lastName.$error.minlength">
     Too short!</span>
     <span class="error" ng-show="myForm.lastName.$error.maxlength">
     Too long!</span><br>
     </form>
     <hr>
     <tt>user = {{user}}</tt><br/>
     <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>
     <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>
     <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>
     <tt>myForm.userName.$error = {{myForm.lastName.$error}}</tt><br>
     <tt>myForm.$valid = {{myForm.$valid}}</tt><br>
     <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>
     <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>
     <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>
     </div>
     </doc:source>
     <doc:scenario>
     it('should initialize to model', function() {
     expect(binding('user')).toEqual('{"name":"guest","last":"visitor"}');
     expect(binding('myForm.userName.$valid')).toEqual('true');
     expect(binding('myForm.$valid')).toEqual('true');
     });

     it('should be invalid if empty when required', function() {
     input('user.name').enter('');
     expect(binding('user')).toEqual('{"last":"visitor"}');
     expect(binding('myForm.userName.$valid')).toEqual('false');
     expect(binding('myForm.$valid')).toEqual('false');
     });

     it('should be valid if empty when min length is set', function() {
     input('user.last').enter('');
     expect(binding('user')).toEqual('{"name":"guest","last":""}');
     expect(binding('myForm.lastName.$valid')).toEqual('true');
     expect(binding('myForm.$valid')).toEqual('true');
     });

     it('should be invalid if less than required min length', function() {
     input('user.last').enter('xx');
     expect(binding('user')).toEqual('{"name":"guest"}');
     expect(binding('myForm.lastName.$valid')).toEqual('false');
     expect(binding('myForm.lastName.$error')).toMatch(/minlength/);
     expect(binding('myForm.$valid')).toEqual('false');
     });

     it('should be invalid if longer than max length', function() {
     input('user.last').enter('some ridiculously long name');
     expect(binding('user'))
     .toEqual('{"name":"guest"}');
     expect(binding('myForm.lastName.$valid')).toEqual('false');
     expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);
     expect(binding('myForm.$valid')).toEqual('false');
     });
     </doc:scenario>
     </doc:example>
     */
    var inputDirective = [function() {
        return {
            restrict: 'E',
            require: '?ngModel',
            link: function(scope, element, attr, ctrl) {
                if (ctrl) {
                    (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl);
                }
            }
        };
    }];

    var VALID_CLASS = 'ng-valid',
        INVALID_CLASS = 'ng-invalid',
        PRISTINE_CLASS = 'ng-pristine',
        DIRTY_CLASS = 'ng-dirty';

    /**
     * @ngdoc object
     * @name angular.module.ng.$compileProvider.directive.ng-model.NgModelController
     *
     * @property {string} $viewValue Actual string value in the view.
     * @property {*} $modelValue The value in the model, that the control is bound to.
     * @property {Array.<Function>} $parsers Whenever the control reads value from the DOM, it executes
     *     all of these functions to sanitize / convert the value as well as validate.
     *
     * @property {Array.<Function>} $formatters Whenever the model value changes, it executes all of
     *     these functions to convert the value as well as validate.
     *
     * @property {Object} $error An bject hash with all errors as keys.
     *
     * @property {boolean} $pristine True if user has not interacted with the control yet.
     * @property {boolean} $dirty True if user has already interacted with the control.
     * @property {boolean} $valid True if there is no error.
     * @property {boolean} $invalid True if at least one error on the control.
     *
     * @description
     *
     */
    var NgModelController = ['$scope', '$exceptionHandler', '$attrs', 'ngModel', '$element',
        function($scope, $exceptionHandler, $attr, ngModel, $element) {
            this.$viewValue = Number.NaN;
            this.$modelValue = Number.NaN;
            this.$parsers = [];
            this.$formatters = [];
            this.$viewChangeListeners = [];
            this.$pristine = true;
            this.$dirty = false;
            this.$valid = true;
            this.$invalid = false;
            this.$render = noop;
            this.$name = $attr.name;

            var parentForm = $element.inheritedData('$formController') || nullFormCtrl,
                invalidCount = 0, // used to easily determine if we are valid
                $error = this.$error = {}; // keep invalid keys here


            // Setup initial state of the control
            $element.addClass(PRISTINE_CLASS);
            toggleValidCss(true);

            // convenience method for easy toggling of classes
            function toggleValidCss(isValid, validationErrorKey) {
                validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
                $element.
                    removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).
                    addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);
            }

            /**
             * @ngdoc function
             * @name angular.module.ng.$compileProvider.directive.ng-model.NgModelController#$setValidity
             * @methodOf angular.module.ng.$compileProvider.directive.ng-model.NgModelController
             *
             * @description
             * Change the validity state, and notifies the form when the control changes validity. (i.e. it
             * does not notify form if given validator is already marked as invalid).
             *
             * This method should be called by validators - i.e. the parser or formatter functions.
             *
             * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign
             *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.
             *        The `validationErrorKey` should be in camelCase and will get converted into dash-case
             *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`
             *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .
             * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).
             */
            this.$setValidity = function(validationErrorKey, isValid) {
                if ($error[validationErrorKey] === !isValid) return;

                if (isValid) {
                    if ($error[validationErrorKey]) invalidCount--;
                    if (!invalidCount) {
                        toggleValidCss(true);
                        this.$valid = true;
                        this.$invalid = false;
                    }
                } else {
                    toggleValidCss(false)
                    this.$invalid = true;
                    this.$valid = false;
                    invalidCount++;
                }

                $error[validationErrorKey] = !isValid;
                toggleValidCss(isValid, validationErrorKey);

                parentForm.$setValidity(validationErrorKey, isValid, this);
            };


            /**
             * @ngdoc function
             * @name angular.module.ng.$compileProvider.directive.ng-model.NgModelController#$setViewValue
             * @methodOf angular.module.ng.$compileProvider.directive.ng-model.NgModelController
             *
             * @description
             * Read a value from view.
             *
             * This method should be called from within a DOM event handler.
             * For example {@link angular.module.ng.$compileProvider.directive.input input} or
             * {@link angular.module.ng.$compileProvider.directive.select select} directives call it.
             *
             * It internally calls all `formatters` and if resulted value is valid, updates the model and
             * calls all registered change listeners.
             *
             * @param {string} value Value from the view.
             */
            this.$setViewValue = function(value) {
                this.$viewValue = value;

                // change to dirty
                if (this.$pristine) {
                    this.$dirty = true;
                    this.$pristine = false;
                    $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);
                    parentForm.$setDirty();
                }

                forEach(this.$parsers, function(fn) {
                    value = fn(value);
                });

                if (this.$modelValue !== value) {
                    this.$modelValue = value;
                    ngModel(value);
                    forEach(this.$viewChangeListeners, function(listener) {
                        try {
                            listener();
                        } catch(e) {
                            $exceptionHandler(e);
                        }
                    })
                }
            };

            // model -> value
            var ctrl = this;
            $scope.$watch(function() {
                return ngModel();
            }, function(value) {

                // ignore change from view
                if (ctrl.$modelValue === value) return;

                var formatters = ctrl.$formatters,
                    idx = formatters.length;

                ctrl.$modelValue = value;
                while(idx--) {
                    value = formatters[idx](value);
                }

                if (ctrl.$viewValue !== value) {
                    ctrl.$viewValue = value;
                    ctrl.$render();
                }
            });
        }];


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-model
     *
     * @element input
     *
     * @description
     * Is directive that tells Angular to do two-way data binding. It works together with `input`,
     * `select`, `textarea`. You can easily write your own directives to use `ng-model` as well.
     *
     * `ng-model` is responsible for:
     *
     * - binding the view into the model, which other directives such as `input`, `textarea` or `select`
     *   require,
     * - providing validation behavior (i.e. required, number, email, url),
     * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),
     * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),
     * - register the control with parent {@link angular.module.ng.$compileProvider.directive.form form}.
     *
     * For basic examples, how to use `ng-model`, see:
     *
     *  - {@link angular.module.ng.$compileProvider.directive.input input}
     *    - {@link angular.module.ng.$compileProvider.directive.input.text text}
     *    - {@link angular.module.ng.$compileProvider.directive.input.checkbox checkbox}
     *    - {@link angular.module.ng.$compileProvider.directive.input.radio radio}
     *    - {@link angular.module.ng.$compileProvider.directive.input.number number}
     *    - {@link angular.module.ng.$compileProvider.directive.input.email email}
     *    - {@link angular.module.ng.$compileProvider.directive.input.url url}
     *  - {@link angular.module.ng.$compileProvider.directive.select select}
     *  - {@link angular.module.ng.$compileProvider.directive.textarea textarea}
     *
     */
    var ngModelDirective = [function() {
        return {
            inject: {
                ngModel: 'accessor'
            },
            require: ['ngModel', '^?form'],
            controller: NgModelController,
            link: function(scope, element, attr, ctrls) {
                // notify others, especially parent forms

                var modelCtrl = ctrls[0],
                    formCtrl = ctrls[1] || nullFormCtrl;

                formCtrl.$addControl(modelCtrl);

                element.bind('$destroy', function() {
                    formCtrl.$removeControl(modelCtrl);
                });
            }
        };
    }];


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-change
     * @restrict E
     *
     * @description
     * Evaluate given expression when user changes the input.
     * The expression is not evaluated when the value change is coming from the model.
     *
     * Note, this directive requires `ng-model` to be present.
     *
     * @element input
     *
     * @example
     * <doc:example>
     *   <doc:source>
     *     <script>
     *       function Controller($scope) {
     *         $scope.counter = 0;
     *         $scope.change = function() {
     *           $scope.counter++;
     *         };
     *       }
     *     </script>
     *     <div ng-controller="Controller">
     *       <input type="checkbox" ng-model="confirmed" ng-change="change()" id="ng-change-example1" />
     *       <input type="checkbox" ng-model="confirmed" id="ng-change-example2" />
     *       <label for="ng-change-example2">Confirmed</label><br />
     *       debug = {{confirmed}}<br />
     *       counter = {{counter}}
     *     </div>
     *   </doc:source>
     *   <doc:scenario>
     *     it('should evaluate the expression if changing from view', function() {
     *       expect(binding('counter')).toEqual('0');
     *       element('#ng-change-example1').click();
     *       expect(binding('counter')).toEqual('1');
     *       expect(binding('confirmed')).toEqual('true');
     *     });
     *
     *     it('should not evaluate the expression if changing from model', function() {
     *       element('#ng-change-example2').click();
     *       expect(binding('counter')).toEqual('0');
     *       expect(binding('confirmed')).toEqual('true');
     *     });
     *   </doc:scenario>
     * </doc:example>
     */
    var ngChangeDirective = valueFn({
        require: 'ngModel',
        link: function(scope, element, attr, ctrl) {
            ctrl.$viewChangeListeners.push(function() {
                scope.$eval(attr.ngChange);
            });
        }
    });


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-model-instant
     *
     * @element input
     *
     * @description
     * By default, Angular udpates the model only on `blur` event - when the input looses focus.
     * If you want to update after every key stroke, use `ng-model-instant`.
     *
     * @example
     * <doc:example>
     *   <doc:source>
     *     First name: <input type="text" ng-model="firstName" /><br />
     *     Last name: <input type="text" ng-model="lastName" ng-model-instant /><br />
     *
     *     First name ({{firstName}}) is only updated on `blur` event, but the last name ({{lastName}})
     *     is updated immediately, because of using `ng-model-instant`.
     *   </doc:source>
     *   <doc:scenario>
     *     it('should update first name on blur', function() {
     *       input('firstName').enter('santa', 'blur');
     *       expect(binding('firstName')).toEqual('santa');
     *     });
     *
     *     it('should update last name immediately', function() {
     *       input('lastName').enter('santa', 'keydown');
     *       expect(binding('lastName')).toEqual('santa');
     *     });
     *   </doc:scenario>
     * </doc:example>
     */
    var ngModelInstantDirective = ['$browser', function($browser) {
        return {
            require: 'ngModel',
            link: function(scope, element, attr, ctrl) {
                var handler = function() {
                    scope.$apply(function() {
                        ctrl.$setViewValue(trim(element.val()));
                    });
                };

                var timeout;
                element.bind('keydown', function(event) {
                    var key = event.keyCode;

                    //    command            modifiers                   arrows
                    if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;

                    if (!timeout) {
                        timeout = $browser.defer(function() {
                            handler();
                            timeout = null;
                        });
                    }
                });

                element.bind('change input', handler);
            }
        };
    }];


    var requiredDirective = [function() {
        return {
            require: '?ngModel',
            link: function(scope, elm, attr, ctrl) {
                if (!ctrl) return;

                var validator = function(value) {
                    if (attr.required && (isEmpty(value) || value === false)) {
                        ctrl.$setValidity('required', false);
                        return;
                    } else {
                        ctrl.$setValidity('required', true);
                        return value;
                    }
                };

                ctrl.$formatters.push(validator);
                ctrl.$parsers.unshift(validator);

                attr.$observe('required', function() {
                    validator(ctrl.$viewValue);
                });
            }
        };
    }];


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-list
     *
     * @description
     * Text input that converts between comma-seperated string into an array of strings.
     *
     * @element input
     * @param {string=} ng-list optional delimiter that should be used to split the value. If
     *   specified in form `/something/` then the value will be converted into a regular expression.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.names = ['igor', 'misko', 'vojta'];
     }
     </script>
     <form name="myForm" ng-controller="Ctrl">
     List: <input name="namesInput" ng-model="names" ng-list required>
     <span class="error" ng-show="myForm.list.$error.required">
     Required!</span>
     <tt>names = {{names}}</tt><br/>
     <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>
     <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>
     <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>
     <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>
     </form>
     </doc:source>
     <doc:scenario>
     it('should initialize to model', function() {
     expect(binding('names')).toEqual('["igor","misko","vojta"]');
     expect(binding('myForm.namesInput.$valid')).toEqual('true');
     });

     it('should be invalid if empty', function() {
     input('names').enter('');
     expect(binding('names')).toEqual('[]');
     expect(binding('myForm.namesInput.$valid')).toEqual('false');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngListDirective = function() {
        return {
            require: 'ngModel',
            link: function(scope, element, attr, ctrl) {
                var match = /\/(.*)\//.exec(attr.ngList),
                    separator = match && new RegExp(match[1]) || attr.ngList || ',';

                var parse = function(viewValue) {
                    var list = [];

                    if (viewValue) {
                        forEach(viewValue.split(separator), function(value) {
                            if (value) list.push(trim(value));
                        });
                    }

                    return list;
                };

                ctrl.$parsers.push(parse);
                ctrl.$formatters.push(function(value) {
                    if (isArray(value) && !equals(parse(ctrl.$viewValue), value)) {
                        return value.join(', ');
                    }

                    return undefined;
                });
            }
        };
    };


    var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;

    var ngValueDirective = [function() {
        return {
            priority: 100,
            compile: function(tpl, attr) {
                if (CONSTANT_VALUE_REGEXP.test(attr.ngValue)) {
                    return function(scope) {
                        attr.$set('value', scope.$eval(attr.ngValue));
                    };
                } else {
                    return function(scope, elm, attr) {
                        attr.$$observers.value = [];
                        scope.$watch(attr.ngValue, function(value) {
                            attr.$set('value', value, false);
                        });
                    };
                }
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-bind
     *
     * @description
     * The `ng-bind` attribute tells Angular to replace the text content of the specified HTML element
     * with the value of a given expression, and to update the text content when the value of that
     * expression changes.
     *
     * Typically, you don't use `ng-bind` directly, but instead you use the double curly markup like
     * `{{ expression }}` and let the Angular compiler transform it to
     * `<span ng-bind="expression"></span>` when the template is compiled.
     *
     * @element ANY
     * @param {expression} ng-bind {@link guide/dev_guide.expressions Expression} to evaluate.
     *
     * @example
     * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.name = 'Whirled';
     }
     </script>
     <div ng-controller="Ctrl">
     Enter name: <input type="text" ng-model="name" ng-model-instant><br>
     Hello <span ng-bind="name"></span>!
     </div>
     </doc:source>
     <doc:scenario>
     it('should check ng-bind', function() {
     expect(using('.doc-example-live').binding('name')).toBe('Whirled');
     using('.doc-example-live').input('name').enter('world');
     expect(using('.doc-example-live').binding('name')).toBe('world');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngBindDirective = ngDirective(function(scope, element, attr) {
        element.addClass('ng-binding').data('$binding', attr.ngBind);
        scope.$watch(attr.ngBind, function(value) {
            element.text(value == undefined ? '' : value);
        });
    });


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-bind-html-unsafe
     *
     * @description
     * Creates a binding that will innerHTML the result of evaluating the `expression` into the current
     * element. *The innerHTML-ed content will not be sanitized!* You should use this directive only if
     * {@link angular.module.ng.$compileProvider.directive.ng-bind-html ng-bind-html} directive is too
     * restrictive and when you absolutely trust the source of the content you are binding to.
     *
     * See {@link angular.module.ng.$sanitize $sanitize} docs for examples.
     *
     * @element ANY
     * @param {expression} ng-bind-html-unsafe {@link guide/dev_guide.expressions Expression} to evaluate.
     */
    var ngBindHtmlUnsafeDirective = ngDirective(function(scope, element, attr) {
        element.addClass('ng-binding').data('$binding', attr.ngBindHtmlUnsafe);
        scope.$watch(attr.ngBindHtmlUnsafe, function(value) {
            element.html(value == undefined ? '' : value);
        });
    });


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-bind-html
     *
     * @description
     * Creates a binding that will sanitize the result of evaluating the `expression` with the
     * {@link angular.module.ng.$sanitize $sanitize} service and innerHTML the result into the current
     * element.
     *
     * See {@link angular.module.ng.$sanitize $sanitize} docs for examples.
     *
     * @element ANY
     * @param {expression} ng-bind-html {@link guide/dev_guide.expressions Expression} to evaluate.
     */
    var ngBindHtmlDirective = ['$sanitize', function($sanitize) {
        return function(scope, element, attr) {
            element.addClass('ng-binding').data('$binding', attr.ngBindHtml);
            scope.$watch(attr.ngBindHtml, function(value) {
                if (value = $sanitize(value)) {
                    element.html(value);
                }
            });
        }
    }];


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-bind-template
     *
     * @description
     * The `ng-bind-template` attribute specifies that the element
     * text should be replaced with the template in ng-bind-template.
     * Unlike ng-bind the ng-bind-template can contain multiple `{{` `}}`
     * expressions. (This is required since some HTML elements
     * can not have SPAN elements such as TITLE, or OPTION to name a few.)
     *
     * @element ANY
     * @param {string} ng-bind-template template of form
     *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.
     *
     * @example
     * Try it here: enter text in text box and watch the greeting change.
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.salutation = 'Hello';
     $scope.name = 'World';
     }
     </script>
     <div ng-controller="Ctrl">
     Salutation: <input type="text" ng-model="salutation" ng-model-instant><br>
     Name: <input type="text" ng-model="name" ng-model-instant><br>
     <pre ng-bind-template="{{salutation}} {{name}}!"></pre>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check ng-bind', function() {
     expect(using('.doc-example-live').binding('salutation')).
     toBe('Hello');
     expect(using('.doc-example-live').binding('name')).
     toBe('World');
     using('.doc-example-live').input('salutation').enter('Greetings');
     using('.doc-example-live').input('name').enter('user');
     expect(using('.doc-example-live').binding('salutation')).
     toBe('Greetings');
     expect(using('.doc-example-live').binding('name')).
     toBe('user');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngBindTemplateDirective = ['$interpolate', function($interpolate) {
        return function(scope, element, attr) {
            // TODO: move this to scenario runner
            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
            element.addClass('ng-binding').data('$binding', interpolateFn);
            attr.$observe('ngBindTemplate', function(value) {
                element.text(value);
            });
        }
    }];

    function classDirective(name, selector) {
        name = 'ngClass' + name;
        return ngDirective(function(scope, element, attr) {
            scope.$watch(attr[name], function(newVal, oldVal) {
                if (selector === true || scope.$index % 2 === selector) {
                    if (oldVal && (newVal !== oldVal)) {
                        if (isObject(oldVal) && !isArray(oldVal))
                            oldVal = map(oldVal, function(v, k) { if (v) return k });
                        element.removeClass(isArray(oldVal) ? oldVal.join(' ') : oldVal);
                    }
                    if (isObject(newVal) && !isArray(newVal))
                        newVal = map(newVal, function(v, k) { if (v) return k });
                    if (newVal) element.addClass(isArray(newVal) ? newVal.join(' ') : newVal);      }
            }, true);
        });
    }

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-class
     *
     * @description
     * The `ng-class` allows you to set CSS class on HTML element dynamically by databinding an
     * expression that represents all classes to be added.
     *
     * The directive won't add duplicate classes if a particular class was already set.
     *
     * When the expression changes, the previously added classes are removed and only then the classes
     * new classes are added.
     *
     * @element ANY
     * @param {expression} ng-class {@link guide/dev_guide.expressions Expression} to eval. The result
     *   of the evaluation can be a string representing space delimited class
     *   names, an array, or a map of class names to boolean values.
     *
     * @example
     <doc:example>
     <doc:source>
     <input type="button" value="set" ng-click="myVar='ng-invalid'">
     <input type="button" value="clear" ng-click="myVar=''">
     <br>
     <span ng-class="myVar">Sample Text &nbsp;&nbsp;&nbsp;&nbsp;</span>
     </doc:source>
     <doc:scenario>
     it('should check ng-class', function() {
     expect(element('.doc-example-live span').prop('className')).not().
     toMatch(/ng-invalid/);

     using('.doc-example-live').element(':button:first').click();

     expect(element('.doc-example-live span').prop('className')).
     toMatch(/ng-invalid/);

     using('.doc-example-live').element(':button:last').click();

     expect(element('.doc-example-live span').prop('className')).not().
     toMatch(/ng-invalid/);
     });
     </doc:scenario>
     </doc:example>
     */
    var ngClassDirective = classDirective('', true);

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-class-odd
     *
     * @description
     * The `ng-class-odd` and `ng-class-even` works exactly as
     * {@link angular.module.ng.$compileProvider.directive.ng-class ng-class}, except it works in conjunction with `ng-repeat` and
     * takes affect only on odd (even) rows.
     *
     * This directive can be applied only within a scope of an
     * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat}.
     *
     * @element ANY
     * @param {expression} ng-class-odd {@link guide/dev_guide.expressions Expression} to eval. The result
     *   of the evaluation can be a string representing space delimited class names or an array.
     *
     * @example
     <doc:example>
     <doc:source>
     <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
     <li ng-repeat="name in names">
     <span ng-class-odd="'ng-format-negative'"
     ng-class-even="'ng-invalid'">
     {{name}} &nbsp; &nbsp; &nbsp;
     </span>
     </li>
     </ol>
     </doc:source>
     <doc:scenario>
     it('should check ng-class-odd and ng-class-even', function() {
     expect(element('.doc-example-live li:first span').prop('className')).
     toMatch(/ng-format-negative/);
     expect(element('.doc-example-live li:last span').prop('className')).
     toMatch(/ng-invalid/);
     });
     </doc:scenario>
     </doc:example>
     */
    var ngClassOddDirective = classDirective('Odd', 0);

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-class-even
     *
     * @description
     * The `ng-class-odd` and `ng-class-even` works exactly as
     * {@link angular.module.ng.$compileProvider.directive.ng-class ng-class}, except it works in
     * conjunction with `ng-repeat` and takes affect only on odd (even) rows.
     *
     * This directive can be applied only within a scope of an
     * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat}.
     *
     * @element ANY
     * @param {expression} ng-class-even {@link guide/dev_guide.expressions Expression} to eval. The
     *   result of the evaluation can be a string representing space delimited class names or an array.
     *
     * @example
     <doc:example>
     <doc:source>
     <ol ng-init="names=['John', 'Mary', 'Cate', 'Suz']">
     <li ng-repeat="name in names">
     <span ng-class-odd="'odd'" ng-class-even="'even'">
     {{name}} &nbsp; &nbsp; &nbsp;
     </span>
     </li>
     </ol>
     </doc:source>
     <doc:scenario>
     it('should check ng-class-odd and ng-class-even', function() {
     expect(element('.doc-example-live li:first span').prop('className')).
     toMatch(/odd/);
     expect(element('.doc-example-live li:last span').prop('className')).
     toMatch(/even/);
     });
     </doc:scenario>
     </doc:example>
     */
    var ngClassEvenDirective = classDirective('Even', 1);

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-cloak
     *
     * @description
     * The `ng-cloak` directive is used to prevent the Angular html template from being briefly
     * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this
     * directive to avoid the undesirable flicker effect caused by the html template display.
     *
     * The directive can be applied to the `<body>` element, but typically a fine-grained application is
     * prefered in order to benefit from progressive rendering of the browser view.
     *
     * `ng-cloak` works in cooperation with a css rule that is embedded within `angular.js` and
     *  `angular.min.js` files. Following is the css rule:
     *
     * <pre>
     * [ng\:cloak], .ng-cloak {
     *   display: none;
     * }
     * </pre>
     *
     * When this css rule is loaded by the browser, all html elements (including their children) that
     * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive
     * during the compilation of the template it deletes the `ng-cloak` element attribute, which
     * makes the compiled element visible.
     *
     * For the best result, `angular.js` script must be loaded in the head section of the html file;
     * alternatively, the css rule (above) must be included in the external stylesheet of the
     * application.
     *
     * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they
     * cannot match the `[ng\:cloak]` selector. To work around this limitation, you must add the css
     * class `ng-cloak` in addition to `ng-cloak` directive as shown in the example below.
     *
     * @element ANY
     *
     * @example
     <doc:example>
     <doc:source>
     <div id="template1" ng-cloak>{{ 'hello' }}</div>
     <div id="template2" ng-cloak class="ng-cloak">{{ 'hello IE7' }}</div>
     </doc:source>
     <doc:scenario>
     it('should remove the template directive and css class', function() {
     expect(element('.doc-example-live #template1').attr('ng-cloak')).
     not().toBeDefined();
     expect(element('.doc-example-live #template2').attr('ng-cloak')).
     not().toBeDefined();
     });
     </doc:scenario>
     </doc:example>
     *
     */
    var ngCloakDirective = ngDirective({
        compile: function(element, attr) {
            attr.$set('ngCloak', undefined);
            element.removeClass('ng-cloak');
        }
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-controller
     *
     * @description
     * The `ng-controller` directive assigns behavior to a scope. This is a key aspect of how angular
     * supports the principles behind the Model-View-Controller design pattern.
     *
     * MVC components in angular:
     *
     * * Model — The Model is data in scope properties; scopes are attached to the DOM.
     * * View — The template (HTML with data bindings) is rendered into the View.
     * * Controller — The `ng-controller` directive specifies a Controller class; the class has
     *   methods that typically express the business logic behind the application.
     *
     * Note that an alternative way to define controllers is via the `{@link angular.module.ng.$route}`
     * service.
     *
     * @element ANY
     * @scope
     * @param {expression} ng-controller Name of a globally accessible constructor function or an
     *     {@link guide/dev_guide.expressions expression} that on the current scope evaluates to a
     *     constructor function.
     *
     * @example
     * Here is a simple form for editing user contact information. Adding, removing, clearing, and
     * greeting are methods declared on the controller (see source tab). These methods can
     * easily be called from the angular markup. Notice that the scope becomes the `this` for the
     * controller's instance. This allows for easy access to the view data from the controller. Also
     * notice that any changes to the data are automatically reflected in the View without the need
     * for a manual update.
     <doc:example>
     <doc:source>
     <script type="text/javascript">
     function SettingsController($scope) {
     $scope.name = "John Smith";
     $scope.contacts = [
     {type:'phone', value:'408 555 1212'},
     {type:'email', value:'john.smith@example.org'} ];

     $scope.greet = function() {
     alert(this.name);
     };

     $scope.addContact = function() {
     this.contacts.push({type:'email', value:'yourname@example.org'});
     };

     $scope.removeContact = function(contactToRemove) {
     var index = this.contacts.indexOf(contactToRemove);
     this.contacts.splice(index, 1);
     };

     $scope.clearContact = function(contact) {
     contact.type = 'phone';
     contact.value = '';
     };
     }
     </script>
     <div ng-controller="SettingsController">
     Name: <input type="text" ng-model="name"/>
     [ <a href="" ng-click="greet()">greet</a> ]<br/>
     Contact:
     <ul>
     <li ng-repeat="contact in contacts">
     <select ng-model="contact.type">
     <option>phone</option>
     <option>email</option>
     </select>
     <input type="text" ng-model="contact.value"/>
     [ <a href="" ng-click="clearContact(contact)">clear</a>
     | <a href="" ng-click="removeContact(contact)">X</a> ]
     </li>
     <li>[ <a href="" ng-click="addContact()">add</a> ]</li>
     </ul>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check controller', function() {
     expect(element('.doc-example-live div>:input').val()).toBe('John Smith');
     expect(element('.doc-example-live li:nth-child(1) input').val())
     .toBe('408 555 1212');
     expect(element('.doc-example-live li:nth-child(2) input').val())
     .toBe('john.smith@example.org');

     element('.doc-example-live li:first a:contains("clear")').click();
     expect(element('.doc-example-live li:first input').val()).toBe('');

     element('.doc-example-live li:last a:contains("add")').click();
     expect(element('.doc-example-live li:nth-child(3) input').val())
     .toBe('yourname@example.org');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngControllerDirective = [function() {
        return {
            scope: true,
            controller: '@'
        };
    }];

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-click
     *
     * @description
     * The ng-click allows you to specify custom behavior when
     * element is clicked.
     *
     * @element ANY
     * @param {expression} ng-click {@link guide/dev_guide.expressions Expression} to evaluate upon
     * click. (Event object is available as `$event`)
     *
     * @example
     <doc:example>
     <doc:source>
     <button ng-click="count = count + 1" ng-init="count=0">
     Increment
     </button>
     count: {{count}}
     </doc:source>
     <doc:scenario>
     it('should check ng-click', function() {
     expect(binding('count')).toBe('0');
     element('.doc-example-live :button').click();
     expect(binding('count')).toBe('1');
     });
     </doc:scenario>
     </doc:example>
     */
    /*
     * A directive that allows creation of custom onclick handlers that are defined as angular
     * expressions and are compiled and executed within the current scope.
     *
     * Events that are handled via these handler are always configured not to propagate further.
     */
    var ngEventDirectives = {};
    forEach(
        'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave'.split(' '),
        function(name) {
            var directiveName = directiveNormalize('ng-' + name);
            ngEventDirectives[directiveName] = ['$parse', function($parse) {
                return function(scope, element, attr) {
                    var fn = $parse(attr[directiveName]);
                    element.bind(lowercase(name), function(event) {
                        scope.$apply(function() {
                            fn(scope, {$event:event});
                        });
                    });
                };
            }];
        }
    );

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-dblclick
     *
     * @description
     * The ng-dblclick allows you to specify custom behavior on dblclick event.
     *
     * @element ANY
     * @param {expression} ng-dblclick {@link guide/dev_guide.expressions Expression} to evaluate upon
     * dblclick. (Event object is available as `$event`)
     *
     * @example
     * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-mousedown
     *
     * @description
     * The ng-mousedown allows you to specify custom behavior on mousedown event.
     *
     * @element ANY
     * @param {expression} ng-mousedown {@link guide/dev_guide.expressions Expression} to evaluate upon
     * mousedown. (Event object is available as `$event`)
     *
     * @example
     * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-mouseup
     *
     * @description
     * Specify custom behavior on mouseup event.
     *
     * @element ANY
     * @param {expression} ng-mouseup {@link guide/dev_guide.expressions Expression} to evaluate upon
     * mouseup. (Event object is available as `$event`)
     *
     * @example
     * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}
     */

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-mouseover
     *
     * @description
     * Specify custom behavior on mouseover event.
     *
     * @element ANY
     * @param {expression} ng-mouseover {@link guide/dev_guide.expressions Expression} to evaluate upon
     * mouseover. (Event object is available as `$event`)
     *
     * @example
     * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-mouseenter
     *
     * @description
     * Specify custom behavior on mouseenter event.
     *
     * @element ANY
     * @param {expression} ng-mouseenter {@link guide/dev_guide.expressions Expression} to evaluate upon
     * mouseenter. (Event object is available as `$event`)
     *
     * @example
     * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-mouseleave
     *
     * @description
     * Specify custom behavior on mouseleave event.
     *
     * @element ANY
     * @param {expression} ng-mouseleave {@link guide/dev_guide.expressions Expression} to evaluate upon
     * mouseleave. (Event object is available as `$event`)
     *
     * @example
     * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-mousemove
     *
     * @description
     * Specify custom behavior on mousemove event.
     *
     * @element ANY
     * @param {expression} ng-mousemove {@link guide/dev_guide.expressions Expression} to evaluate upon
     * mousemove. (Event object is available as `$event`)
     *
     * @example
     * See {@link angular.module.ng.$compileProvider.directive.ng-click ng-click}
     */


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-submit
     *
     * @description
     * Enables binding angular expressions to onsubmit events.
     *
     * Additionally it prevents the default action (which for form means sending the request to the
     * server and reloading the current page).
     *
     * @element form
     * @param {expression} ng-submit {@link guide/dev_guide.expressions Expression} to eval.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.list = [];
     $scope.text = 'hello';
     $scope.submit = function() {
     if (this.text) {
     this.list.push(this.text);
     this.text = '';
     }
     };
     }
     </script>
     <form ng-submit="submit()" ng-controller="Ctrl">
     Enter text and hit enter:
     <input type="text" ng-model="text" name="text" />
     <input type="submit" id="submit" value="Submit" />
     <pre>list={{list}}</pre>
     </form>
     </doc:source>
     <doc:scenario>
     it('should check ng-submit', function() {
     expect(binding('list')).toBe('[]');
     element('.doc-example-live #submit').click();
     expect(binding('list')).toBe('["hello"]');
     expect(input('text').val()).toBe('');
     });
     it('should ignore empty strings', function() {
     expect(binding('list')).toBe('[]');
     element('.doc-example-live #submit').click();
     element('.doc-example-live #submit').click();
     expect(binding('list')).toBe('["hello"]');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngSubmitDirective = ngDirective(function(scope, element, attrs) {
        element.bind('submit', function() {
            scope.$apply(attrs.ngSubmit);
        });
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-include
     * @restrict EA
     *
     * @description
     * Fetches, compiles and includes an external HTML fragment.
     *
     * Keep in mind that Same Origin Policy applies to included resources
     * (e.g. ng-include won't work for file:// access).
     *
     * @scope
     *
     * @param {string} ng-include|src angular expression evaluating to URL. If the source is a string constant,
     *                 make sure you wrap it in quotes, e.g. `src="'myPartialTemplate.html'"`.
     * @param {Scope=} [scope=new_child_scope] optional expression which evaluates to an
     *                 instance of angular.module.ng.$rootScope.Scope to set the HTML fragment to.
     * @param {string=} onload Expression to evaluate when a new partial is loaded.
     *
     * @param {string=} autoscroll Whether `ng-include` should call {@link angular.module.ng.$anchorScroll
     *                  $anchorScroll} to scroll the viewport after the content is loaded.
     *
     *                  - If the attribute is not set, disable scrolling.
     *                  - If the attribute is set without value, enable scrolling.
     *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.
     *
     * @example
     <doc:example>
     <doc:source jsfiddle="false">
     <script>
     function Ctrl($scope) {
     $scope.templates =
     [ { name: 'template1.html', url: 'examples/ng-include/template1.html'}
     , { name: 'template2.html', url: 'examples/ng-include/template2.html'} ];
     $scope.template = $scope.templates[0];
     }
     </script>
     <div ng-controller="Ctrl">
     <select ng-model="template" ng-options="t.name for t in templates">
     <option value="">(blank)</option>
     </select>
     url of the template: <tt><a href="{{template.url}}">{{template.url}}</a></tt>
     <hr/>
     <div ng-include src="template.url"></div>
     </div>
     </doc:source>
     <doc:scenario>
     it('should load template1.html', function() {
     expect(element('.doc-example-live [ng-include]').text()).
     toBe('Content of template1.html\n');
     });
     it('should load template2.html', function() {
     select('template').option('1');
     expect(element('.doc-example-live [ng-include]').text()).
     toBe('Content of template2.html\n');
     });
     it('should change to blank', function() {
     select('template').option('');
     expect(element('.doc-example-live [ng-include]').text()).toEqual('');
     });
     </doc:scenario>
     </doc:example>
     */


    /**
     * @ngdoc event
     * @name angular.module.ng.$compileProvider.directive.ng-include#$includeContentLoaded
     * @eventOf angular.module.ng.$compileProvider.directive.ng-include
     * @eventType emit on the current ng-include scope
     * @description
     * Emitted every time the ng-include content is reloaded.
     */
    var ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile',
        function($http,   $templateCache,   $anchorScroll,   $compile) {
            return {
                restrict: 'EA',
                compile: function(element, attr) {
                    var srcExp = attr.ngInclude  || attr.src,
                        scopeExp = attr.scope || '',
                        onloadExp = attr.onload || '',
                        autoScrollExp = attr.autoscroll;

                    return function(scope, element, attr) {
                        var changeCounter = 0,
                            childScope;

                        function incrementChange() { changeCounter++;}
                        scope.$watch(srcExp, incrementChange);
                        scope.$watch(function() {
                            var includeScope = scope.$eval(scopeExp);
                            if (includeScope) return includeScope.$id;
                        }, incrementChange);
                        scope.$watch(function() {return changeCounter;}, function(newChangeCounter) {
                            var src = scope.$eval(srcExp),
                                useScope = scope.$eval(scopeExp);

                            function clearContent() {
                                // if this callback is still desired
                                if (newChangeCounter === changeCounter) {
                                    if (childScope) childScope.$destroy();
                                    childScope = null;
                                    element.html('');
                                }
                            }

                            if (src) {
                                $http.get(src, {cache: $templateCache}).success(function(response) {
                                    // if this callback is still desired
                                    if (newChangeCounter === changeCounter) {
                                        element.html(response);
                                        if (childScope) childScope.$destroy();
                                        childScope = useScope ? useScope : scope.$new();
                                        $compile(element.contents())(childScope);
                                        if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                            $anchorScroll();
                                        }
                                        scope.$emit('$includeContentLoaded');
                                        scope.$eval(onloadExp);
                                    }
                                }).error(clearContent);
                            } else {
                                clearContent();
                            }
                        });
                    };
                }
            }
        }];

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-init
     *
     * @description
     * The `ng-init` attribute specifies initialization tasks to be executed
     *  before the template enters execution mode during bootstrap.
     *
     * @element ANY
     * @param {expression} ng-init {@link guide/dev_guide.expressions Expression} to eval.
     *
     * @example
     <doc:example>
     <doc:source>
     <div ng-init="greeting='Hello'; person='World'">
     {{greeting}} {{person}}!
     </div>
     </doc:source>
     <doc:scenario>
     it('should check greeting', function() {
     expect(binding('greeting')).toBe('Hello');
     expect(binding('person')).toBe('World');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngInitDirective = ngDirective({
        compile: function() {
            return {
                pre: function(scope, element, attrs) {
                    scope.$eval(attrs.ngInit);
                }
            }
        }
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-non-bindable
     * @priority 1000
     *
     * @description
     * Sometimes it is necessary to write code which looks like bindings but which should be left alone
     * by angular. Use `ng-non-bindable` to make angular ignore a chunk of HTML.
     *
     * @element ANY
     *
     * @example
     * In this example there are two location where a simple binding (`{{}}`) is present, but the one
     * wrapped in `ng-non-bindable` is left alone.
     *
     * @example
     <doc:example>
     <doc:source>
     <div>Normal: {{1 + 2}}</div>
     <div ng-non-bindable>Ignored: {{1 + 2}}</div>
     </doc:source>
     <doc:scenario>
     it('should check ng-non-bindable', function() {
     expect(using('.doc-example-live').binding('1 + 2')).toBe('3');
     expect(using('.doc-example-live').element('div:last').text()).
     toMatch(/1 \+ 2/);
     });
     </doc:scenario>
     </doc:example>
     */
    var ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-pluralize
     * @restrict EA
     *
     * @description
     * # Overview
     * ng-pluralize is a directive that displays messages according to en-US localization rules.
     * These rules are bundled with angular.js and the rules can be overridden
     * (see {@link guide/dev_guide.i18n Angular i18n} dev guide). You configure ng-pluralize by
     * specifying the mappings between
     * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
     * plural categories} and the strings to be displayed.
     *
     * # Plural categories and explicit number rules
     * There are two
     * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
     * plural categories} in Angular's default en-US locale: "one" and "other".
     *
     * While a pural category may match many numbers (for example, in en-US locale, "other" can match
     * any number that is not 1), an explicit number rule can only match one number. For example, the
     * explicit number rule for "3" matches the number 3. You will see the use of plural categories
     * and explicit number rules throughout later parts of this documentation.
     *
     * # Configuring ng-pluralize
     * You configure ng-pluralize by providing 2 attributes: `count` and `when`.
     * You can also provide an optional attribute, `offset`.
     *
     * The value of the `count` attribute can be either a string or an {@link guide/dev_guide.expressions
     * Angular expression}; these are evaluated on the current scope for its binded value.
     *
     * The `when` attribute specifies the mappings between plural categories and the actual
     * string to be displayed. The value of the attribute should be a JSON object so that Angular
     * can interpret it correctly.
     *
     * The following example shows how to configure ng-pluralize:
     *
     * <pre>
     * <ng-pluralize count="personCount"
     when="{'0': 'Nobody is viewing.',
     *                      'one': '1 person is viewing.',
     *                      'other': '{} people are viewing.'}">
     * </ng-pluralize>
     *</pre>
     *
     * In the example, `"0: Nobody is viewing."` is an explicit number rule. If you did not
     * specify this rule, 0 would be matched to the "other" category and "0 people are viewing"
     * would be shown instead of "Nobody is viewing". You can specify an explicit number rule for
     * other numbers, for example 12, so that instead of showing "12 people are viewing", you can
     * show "a dozen people are viewing".
     *
     * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted
     * into pluralized strings. In the previous example, Angular will replace `{}` with
     * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder
     * for <span ng-non-bindable>{{numberExpression}}</span>.
     *
     * # Configuring ng-pluralize with offset
     * The `offset` attribute allows further customization of pluralized text, which can result in
     * a better user experience. For example, instead of the message "4 people are viewing this document",
     * you might display "John, Kate and 2 others are viewing this document".
     * The offset attribute allows you to offset a number by any desired value.
     * Let's take a look at an example:
     *
     * <pre>
     * <ng-pluralize count="personCount" offset=2
     *               when="{'0': 'Nobody is viewing.',
     *                      '1': '{{person1}} is viewing.',
     *                      '2': '{{person1}} and {{person2}} are viewing.',
     *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',
     *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
     * </ng-pluralize>
     * </pre>
     *
     * Notice that we are still using two plural categories(one, other), but we added
     * three explicit number rules 0, 1 and 2.
     * When one person, perhaps John, views the document, "John is viewing" will be shown.
     * When three people view the document, no explicit number rule is found, so
     * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.
     * In this case, plural category 'one' is matched and "John, Marry and one other person are viewing"
     * is shown.
     *
     * Note that when you specify offsets, you must provide explicit number rules for
     * numbers from 0 up to and including the offset. If you use an offset of 3, for example,
     * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for
     * plural categories "one" and "other".
     *
     * @param {string|expression} count The variable to be bounded to.
     * @param {string} when The mapping between plural category to its correspoding strings.
     * @param {number=} offset Offset to deduct from the total number.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.person1 = 'Igor';
     $scope.person2 = 'Misko';
     $scope.personCount = 1;
     }
     </script>
     <div ng-controller="Ctrl">
     Person 1:<input type="text" ng-model="person1" value="Igor" /><br/>
     Person 2:<input type="text" ng-model="person2" value="Misko" /><br/>
     Number of People:<input type="text" ng-model="personCount" value="1" /><br/>

     <!--- Example with simple pluralization rules for en locale --->
     Without Offset:
     <ng-pluralize count="personCount"
     when="{'0': 'Nobody is viewing.',
     'one': '1 person is viewing.',
     'other': '{} people are viewing.'}">
     </ng-pluralize><br>

     <!--- Example with offset --->
     With Offset(2):
     <ng-pluralize count="personCount" offset=2
     when="{'0': 'Nobody is viewing.',
     '1': '{{person1}} is viewing.',
     '2': '{{person1}} and {{person2}} are viewing.',
     'one': '{{person1}}, {{person2}} and one other person are viewing.',
     'other': '{{person1}}, {{person2}} and {} other people are viewing.'}">
     </ng-pluralize>
     </div>
     </doc:source>
     <doc:scenario>
     it('should show correct pluralized string', function() {
     expect(element('.doc-example-live ng-pluralize:first').text()).
     toBe('1 person is viewing.');
     expect(element('.doc-example-live ng-pluralize:last').text()).
     toBe('Igor is viewing.');

     using('.doc-example-live').input('personCount').enter('0');
     expect(element('.doc-example-live ng-pluralize:first').text()).
     toBe('Nobody is viewing.');
     expect(element('.doc-example-live ng-pluralize:last').text()).
     toBe('Nobody is viewing.');

     using('.doc-example-live').input('personCount').enter('2');
     expect(element('.doc-example-live ng-pluralize:first').text()).
     toBe('2 people are viewing.');
     expect(element('.doc-example-live ng-pluralize:last').text()).
     toBe('Igor and Misko are viewing.');

     using('.doc-example-live').input('personCount').enter('3');
     expect(element('.doc-example-live ng-pluralize:first').text()).
     toBe('3 people are viewing.');
     expect(element('.doc-example-live ng-pluralize:last').text()).
     toBe('Igor, Misko and one other person are viewing.');

     using('.doc-example-live').input('personCount').enter('4');
     expect(element('.doc-example-live ng-pluralize:first').text()).
     toBe('4 people are viewing.');
     expect(element('.doc-example-live ng-pluralize:last').text()).
     toBe('Igor, Misko and 2 other people are viewing.');
     });

     it('should show data-binded names', function() {
     using('.doc-example-live').input('personCount').enter('4');
     expect(element('.doc-example-live ng-pluralize:last').text()).
     toBe('Igor, Misko and 2 other people are viewing.');

     using('.doc-example-live').input('person1').enter('Di');
     using('.doc-example-live').input('person2').enter('Vojta');
     expect(element('.doc-example-live ng-pluralize:last').text()).
     toBe('Di, Vojta and 2 other people are viewing.');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {
        var BRACE = /{}/g;
        return {
            restrict: 'EA',
            link: function(scope, element, attr) {
                var numberExp = attr.count,
                    whenExp = element.attr(attr.$attr.when), // this is because we have {{}} in attrs
                    offset = attr.offset || 0,
                    whens = scope.$eval(whenExp),
                    whensExpFns = {};

                forEach(whens, function(expression, key) {
                    whensExpFns[key] =
                        $interpolate(expression.replace(BRACE, '{{' + numberExp + '-' + offset + '}}'));
                });

                scope.$watch(function() {
                    var value = parseFloat(scope.$eval(numberExp));

                    if (!isNaN(value)) {
                        //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,
                        //check it against pluralization rules in $locale service
                        if (!whens[value]) value = $locale.pluralCat(value - offset);
                        return whensExpFns[value](scope, element, true);
                    } else {
                        return '';
                    }
                }, function(newVal) {
                    element.text(newVal);
                });
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-repeat
     *
     * @description
     * The `ng-repeat` directive instantiates a template once per item from a collection. Each template
     * instance gets its own scope, where the given loop variable is set to the current collection item,
     * and `$index` is set to the item index or key.
     *
     * Special properties are exposed on the local scope of each template instance, including:
     *
     *   * `$index` – `{number}` – iterator offset of the repeated element (0..length-1)
     *   * `$position` – `{string}` – position of the repeated element in the iterator. One of:
     *        * `'first'`,
     *        * `'middle'`
     *        * `'last'`
     *
     *
     * @element ANY
     * @scope
     * @priority 1000
     * @param {repeat_expression} ng-repeat The expression indicating how to enumerate a collection. Two
     *   formats are currently supported:
     *
     *   * `variable in expression` – where variable is the user defined loop variable and `expression`
     *     is a scope expression giving the collection to enumerate.
     *
     *     For example: `track in cd.tracks`.
     *
     *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,
     *     and `expression` is the scope expression giving the collection to enumerate.
     *
     *     For example: `(name, age) in {'adam':10, 'amalie':12}`.
     *
     * @example
     * This example initializes the scope to a list of names and
     * then uses `ng-repeat` to display every person:
     <doc:example>
     <doc:source>
     <div ng-init="friends = [{name:'John', age:25}, {name:'Mary', age:28}]">
     I have {{friends.length}} friends. They are:
     <ul>
     <li ng-repeat="friend in friends">
     [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.
     </li>
     </ul>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check ng-repeat', function() {
     var r = using('.doc-example-live').repeater('ul li');
     expect(r.count()).toBe(2);
     expect(r.row(0)).toEqual(["1","John","25"]);
     expect(r.row(1)).toEqual(["2","Mary","28"]);
     });
     </doc:scenario>
     </doc:example>
     */
    var ngRepeatDirective = ngDirective({
        transclude: 'element',
        priority: 1000,
        terminal: true,
        compile: function(element, attr, linker) {
            return function(scope, iterStartElement, attr){
                var expression = attr.ngRepeat;
                var match = expression.match(/^\s*(.+)\s+in\s+(.*)\s*$/),
                    lhs, rhs, valueIdent, keyIdent;
                if (! match) {
                    throw Error("Expected ng-repeat in form of '_item_ in _collection_' but got '" +
                        expression + "'.");
                }
                lhs = match[1];
                rhs = match[2];
                match = lhs.match(/^(?:([\$\w]+)|\(([\$\w]+)\s*,\s*([\$\w]+)\))$/);
                if (!match) {
                    throw Error("'item' in 'item in collection' should be identifier or (key, value) but got '" +
                        lhs + "'.");
                }
                valueIdent = match[3] || match[1];
                keyIdent = match[2];

                // Store a list of elements from previous run. This is a hash where key is the item from the
                // iterator, and the value is an array of objects with following properties.
                //   - scope: bound scope
                //   - element: previous element.
                //   - index: position
                // We need an array of these objects since the same object can be returned from the iterator.
                // We expect this to be a rare case.
                var lastOrder = new HashQueueMap();
                scope.$watch(function(scope){
                    var index, length,
                        collection = scope.$eval(rhs),
                        collectionLength = size(collection, true),
                        childScope,
                        // Same as lastOrder but it has the current state. It will become the
                        // lastOrder on the next iteration.
                        nextOrder = new HashQueueMap(),
                        key, value, // key/value of iteration
                        array, last,       // last object information {scope, element, index}
                        cursor = iterStartElement;     // current position of the node

                    if (!isArray(collection)) {
                        // if object, extract keys, sort them and use to determine order of iteration over obj props
                        array = [];
                        for(key in collection) {
                            if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {
                                array.push(key);
                            }
                        }
                        array.sort();
                    } else {
                        array = collection || [];
                    }

                    // we are not using forEach for perf reasons (trying to avoid #call)
                    for (index = 0, length = array.length; index < length; index++) {
                        key = (collection === array) ? index : array[index];
                        value = collection[key];
                        last = lastOrder.shift(value);
                        if (last) {
                            // if we have already seen this object, then we need to reuse the
                            // associated scope/element
                            childScope = last.scope;
                            nextOrder.push(value, last);

                            if (index === last.index) {
                                // do nothing
                                cursor = last.element;
                            } else {
                                // existing item which got moved
                                last.index = index;
                                // This may be a noop, if the element is next, but I don't know of a good way to
                                // figure this out,  since it would require extra DOM access, so let's just hope that
                                // the browsers realizes that it is noop, and treats it as such.
                                cursor.after(last.element);
                                cursor = last.element;
                            }
                        } else {
                            // new item which we don't know about
                            childScope = scope.$new();
                        }

                        childScope[valueIdent] = value;
                        if (keyIdent) childScope[keyIdent] = key;
                        childScope.$index = index;
                        childScope.$position = index === 0 ?
                            'first' :
                            (index == collectionLength - 1 ? 'last' : 'middle');

                        if (!last) {
                            linker(childScope, function(clone){
                                cursor.after(clone);
                                last = {
                                    scope: childScope,
                                    element: (cursor = clone),
                                    index: index
                                };
                                nextOrder.push(value, last);
                            });
                        }
                    }

                    //shrink children
                    for (key in lastOrder) {
                        if (lastOrder.hasOwnProperty(key)) {
                            array = lastOrder[key];
                            while(array.length) {
                                value = array.pop();
                                value.element.remove();
                                value.scope.$destroy();
                            }
                        }
                    }

                    lastOrder = nextOrder;
                });
            };
        }
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-show
     *
     * @description
     * The `ng-show` and `ng-hide` directives show or hide a portion of the DOM tree (HTML)
     * conditionally.
     *
     * @element ANY
     * @param {expression} ng-show If the {@link guide/dev_guide.expressions expression} is truthy
     *     then the element is shown or hidden respectively.
     *
     * @example
     <doc:example>
     <doc:source>
     Click me: <input type="checkbox" ng-model="checked"><br/>
     Show: <span ng-show="checked">I show up when your checkbox is checked.</span> <br/>
     Hide: <span ng-hide="checked">I hide when your checkbox is checked.</span>
     </doc:source>
     <doc:scenario>
     it('should check ng-show / ng-hide', function() {
     expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);
     expect(element('.doc-example-live span:last:visible').count()).toEqual(1);

     input('checked').check();

     expect(element('.doc-example-live span:first:visible').count()).toEqual(1);
     expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);
     });
     </doc:scenario>
     </doc:example>
     */
//TODO(misko): refactor to remove element from the DOM
    var ngShowDirective = ngDirective(function(scope, element, attr){
        scope.$watch(attr.ngShow, function(value){
            element.css('display', toBoolean(value) ? '' : 'none');
        });
    });


    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-hide
     *
     * @description
     * The `ng-hide` and `ng-show` directives hide or show a portion
     * of the HTML conditionally.
     *
     * @element ANY
     * @param {expression} ng-hide If the {@link guide/dev_guide.expressions expression} truthy then
     *     the element is shown or hidden respectively.
     *
     * @example
     <doc:example>
     <doc:source>
     Click me: <input type="checkbox" ng-model="checked"><br/>
     Show: <span ng-show="checked">I show up when you checkbox is checked?</span> <br/>
     Hide: <span ng-hide="checked">I hide when you checkbox is checked?</span>
     </doc:source>
     <doc:scenario>
     it('should check ng-show / ng-hide', function() {
     expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);
     expect(element('.doc-example-live span:last:visible').count()).toEqual(1);

     input('checked').check();

     expect(element('.doc-example-live span:first:visible').count()).toEqual(1);
     expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);
     });
     </doc:scenario>
     </doc:example>
     */
//TODO(misko): refactor to remove element from the DOM
    var ngHideDirective = ngDirective(function(scope, element, attr){
        scope.$watch(attr.ngHide, function(value){
            element.css('display', toBoolean(value) ? 'none' : '');
        });
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-style
     *
     * @description
     * The ng-style allows you to set CSS style on an HTML element conditionally.
     *
     * @element ANY
     * @param {expression} ng-style {@link guide/dev_guide.expressions Expression} which evals to an
     *      object whose keys are CSS style names and values are corresponding values for those CSS
     *      keys.
     *
     * @example
     <doc:example>
     <doc:source>
     <input type="button" value="set" ng-click="myStyle={color:'red'}">
     <input type="button" value="clear" ng-click="myStyle={}">
     <br/>
     <span ng-style="myStyle">Sample Text</span>
     <pre>myStyle={{myStyle}}</pre>
     </doc:source>
     <doc:scenario>
     it('should check ng-style', function() {
     expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
     element('.doc-example-live :button[value=set]').click();
     expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');
     element('.doc-example-live :button[value=clear]').click();
     expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');
     });
     </doc:scenario>
     </doc:example>
     */
    var ngStyleDirective = ngDirective(function(scope, element, attr) {
        scope.$watch(attr.ngStyle, function(newStyles, oldStyles) {
            if (oldStyles && (newStyles !== oldStyles)) {
                forEach(oldStyles, function(val, style) { element.css(style, '');});
            }
            if (newStyles) element.css(newStyles);
        }, true);
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-switch
     * @restrict EA
     *
     * @description
     * Conditionally change the DOM structure.
     *
     * @usageContent
     * <any ng-switch-when="matchValue1">...</any>
     *   <any ng-switch-when="matchValue2">...</any>
     *   ...
     *   <any ng-switch-default>...</any>
     *
     * @scope
     * @param {*} ng-switch|on expression to match against <tt>ng-switch-when</tt>.
     * @paramDescription
     * On child elments add:
     *
     * * `ng-switch-when`: the case statement to match against. If match then this
     *   case will be displayed.
     * * `ng-switch-default`: the default case when no other casses match.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.items = ['settings', 'home', 'other'];
     $scope.selection = $scope.items[0];
     }
     </script>
     <div ng-controller="Ctrl">
     <select ng-model="selection" ng-options="item for item in items">
     </select>
     <tt>selection={{selection}}</tt>
     <hr/>
     <div ng-switch on="selection" >
     <div ng-switch-when="settings">Settings Div</div>
     <span ng-switch-when="home">Home Span</span>
     <span ng-switch-default>default</span>
     </div>
     </div>
     </doc:source>
     <doc:scenario>
     it('should start in settings', function() {
     expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);
     });
     it('should change to home', function() {
     select('selection').option('home');
     expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);
     });
     it('should select deafault', function() {
     select('selection').option('other');
     expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);
     });
     </doc:scenario>
     </doc:example>
     */
    var NG_SWITCH = 'ng-switch';
    var ngSwitchDirective = valueFn({
        restrict: 'EA',
        compile: function(element, attr) {
            var watchExpr = attr.ngSwitch || attr.on,
                cases = {};

            element.data(NG_SWITCH, cases);
            return function(scope, element){
                var selectedTransclude,
                    selectedElement,
                    selectedScope;

                scope.$watch(watchExpr, function(value) {
                    if (selectedElement) {
                        selectedScope.$destroy();
                        selectedElement.remove();
                        selectedElement = selectedScope = null;
                    }
                    if ((selectedTransclude = cases['!' + value] || cases['?'])) {
                        scope.$eval(attr.change);
                        selectedScope = scope.$new();
                        selectedTransclude(selectedScope, function(caseElement) {
                            selectedElement = caseElement;
                            element.append(caseElement);
                        });
                    }
                });
            };
        }
    });

    var ngSwitchWhenDirective = ngDirective({
        transclude: 'element',
        priority: 500,
        compile: function(element, attrs, transclude) {
            var cases = element.inheritedData(NG_SWITCH);
            assertArg(cases);
            cases['!' + attrs.ngSwitchWhen] = transclude;
        }
    });

    var ngSwitchDefaultDirective = ngDirective({
        transclude: 'element',
        priority: 500,
        compile: function(element, attrs, transclude) {
            var cases = element.inheritedData(NG_SWITCH);
            assertArg(cases);
            cases['?'] = transclude;
        }
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-transclude
     *
     * @description
     * Insert the transcluded DOM here.
     *
     * @element ANY
     *
     * @example
     <doc:example module="transclude">
     <doc:source>
     <script>
     function Ctrl($scope) {
     $scope.title = 'Lorem Ipsum';
     $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';
     }

     angular.module('transclude', [])
     .directive('pane', function(){
     return {
     restrict: 'E',
     transclude: true,
     scope: 'isolate',
     locals: { title:'bind' },
     template: '<div style="border: 1px solid black;">' +
     '<div style="background-color: gray">{{title}}</div>' +
     '<div ng-transclude></div>' +
     '</div>'
     };
     });
     </script>
     <div ng-controller="Ctrl">
     <input ng-model="title"><br>
     <textarea ng-model="text"></textarea> <br/>
     <pane title="{{title}}">{{text}}</pane>
     </div>
     </doc:source>
     <doc:scenario>
     it('should have transcluded', function() {
     input('title').enter('TITLE');
     input('text').enter('TEXT');
     expect(binding('title')).toEqual('TITLE');
     expect(binding('text')).toEqual('TEXT');
     });
     </doc:scenario>
     </doc:example>
     *
     */
    var ngTranscludeDirective = ngDirective({
        controller: ['$transclude', '$element', function($transclude, $element) {
            $transclude(function(clone) {
                $element.append(clone);
            });
        }]
    });

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.ng-view
     * @restrict ECA
     *
     * @description
     * # Overview
     * `ng-view` is a directive that complements the {@link angular.module.ng.$route $route} service by
     * including the rendered template of the current route into the main layout (`index.html`) file.
     * Every time the current route changes, the included view changes with it according to the
     * configuration of the `$route` service.
     *
     * @scope
     * @example
     <doc:example module="ngView">
     <doc:source>
     <script type="text/ng-template" id="examples/book.html">
     controller: {{name}}<br />
     Book Id: {{params.bookId}}<br />
     </script>

     <script type="text/ng-template" id="examples/chapter.html">
     controller: {{name}}<br />
     Book Id: {{params.bookId}}<br />
     Chapter Id: {{params.chapterId}}
     </script>

     <script>
     angular.module('ngView', [], function($routeProvider, $locationProvider) {
     $routeProvider.when('/Book/:bookId', {
     template: 'examples/book.html',
     controller: BookCntl
     });
     $routeProvider.when('/Book/:bookId/ch/:chapterId', {
     template: 'examples/chapter.html',
     controller: ChapterCntl
     });

     // configure html5 to get links working on jsfiddle
     $locationProvider.html5Mode(true);
     });

     function MainCntl($scope, $route, $routeParams, $location) {
     $scope.$route = $route;
     $scope.$location = $location;
     $scope.$routeParams = $routeParams;
     }

     function BookCntl($scope, $routeParams) {
     $scope.name = "BookCntl";
     $scope.params = $routeParams;
     }

     function ChapterCntl($scope, $routeParams) {
     $scope.name = "ChapterCntl";
     $scope.params = $routeParams;
     }
     </script>

     <div ng-controller="MainCntl">
     Choose:
     <a href="/Book/Moby">Moby</a> |
     <a href="/Book/Moby/ch/1">Moby: Ch1</a> |
     <a href="/Book/Gatsby">Gatsby</a> |
     <a href="/Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
     <a href="/Book/Scarlet">Scarlet Letter</a><br/>

     <div ng-view></div>
     <hr />

     <pre>$location.path() = {{$location.path()}}</pre>
     <pre>$route.current.template = {{$route.current.template}}</pre>
     <pre>$route.current.params = {{$route.current.params}}</pre>
     <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>
     <pre>$routeParams = {{$routeParams}}</pre>
     </div>
     </doc:source>
     <doc:scenario>
     it('should load and compile correct template', function() {
     element('a:contains("Moby: Ch1")').click();
     var content = element('.doc-example-live [ng-view]').text();
     expect(content).toMatch(/controller\: ChapterCntl/);
     expect(content).toMatch(/Book Id\: Moby/);
     expect(content).toMatch(/Chapter Id\: 1/);

     element('a:contains("Scarlet")').click();
     content = element('.doc-example-live [ng-view]').text();
     expect(content).toMatch(/controller\: BookCntl/);
     expect(content).toMatch(/Book Id\: Scarlet/);
     });
     </doc:scenario>
     </doc:example>
     */


    /**
     * @ngdoc event
     * @name angular.module.ng.$compileProvider.directive.ng-view#$viewContentLoaded
     * @eventOf angular.module.ng.$compileProvider.directive.ng-view
     * @eventType emit on the current ng-view scope
     * @description
     * Emitted every time the ng-view content is reloaded.
     */
    var ngViewDirective = ['$http', '$templateCache', '$route', '$anchorScroll', '$compile',
        '$controller',
        function($http,   $templateCache,   $route,   $anchorScroll,   $compile,
                 $controller) {
            return {
                restrict: 'ECA',
                terminal: true,
                link: function(scope, element, attr) {
                    var changeCounter = 0,
                        lastScope,
                        onloadExp = attr.onload || '';

                    scope.$on('$afterRouteChange', function(event, next, previous) {
                        changeCounter++;
                    });

                    scope.$watch(function() {return changeCounter;}, function(newChangeCounter) {
                        var template = $route.current && $route.current.template;

                        function destroyLastScope() {
                            if (lastScope) {
                                lastScope.$destroy();
                                lastScope = null;
                            }
                        }

                        function clearContent() {
                            // ignore callback if another route change occured since
                            if (newChangeCounter == changeCounter) {
                                element.html('');
                            }
                            destroyLastScope();
                        }

                        if (template) {
                            $http.get(template, {cache: $templateCache}).success(function(response) {
                                // ignore callback if another route change occured since
                                if (newChangeCounter == changeCounter) {
                                    element.html(response);
                                    destroyLastScope();

                                    var link = $compile(element.contents()),
                                        current = $route.current;

                                    lastScope = current.scope = scope.$new();
                                    if (current.controller) {
                                        element.contents().
                                            data('$ngControllerController', $controller(current.controller, {$scope: lastScope}));
                                    }

                                    link(lastScope);
                                    lastScope.$emit('$viewContentLoaded');
                                    lastScope.$eval(onloadExp);

                                    // $anchorScroll might listen on event...
                                    $anchorScroll();
                                }
                            }).error(clearContent);
                        } else {
                            clearContent();
                        }
                    });
                }
            };
        }];

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.script
     *
     * @description
     * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the
     * template can be used by `ng-include`, `ng-view` or directive templates.
     *
     * @restrict E
     * @param {'text/ng-template'} type must be set to `'text/ng-template'`
     *
     * @example
     <doc:example>
     <doc:source>
     <script type="text/ng-template" id="/tpl.html">
     Content of the template.
     </script>

     <a ng-click="currentTpl='/tpl.html'" id="tpl-link">Load inlined template</a>
     <div id="tpl-content" ng-include src="currentTpl"></div>
     </doc:source>
     <doc:scenario>
     it('should load template defined inside script tag', function() {
     element('#tpl-link').click();
     expect(element('#tpl-content').text()).toMatch(/Content of the template/);
     });
     </doc:scenario>
     </doc:example>
     */
    var scriptDirective = ['$templateCache', function($templateCache) {
        return {
            restrict: 'E',
            terminal: true,
            compile: function(element, attr) {
                if (attr.type == 'text/ng-template') {
                    var templateUrl = attr.id;
                    $templateCache.put(templateUrl, element.text());
                }
            }
        };
    }];

    /**
     * @ngdoc directive
     * @name angular.module.ng.$compileProvider.directive.select
     * @restrict E
     *
     * @description
     * HTML `SELECT` element with angular data-binding.
     *
     * # `ng-options`
     *
     * Optionally `ng-options` attribute can be used to dynamically generate a list of `<option>`
     * elements for a `<select>` element using an array or an object obtained by evaluating the
     * `ng-options` expression.
     *˝˝
     * When an item in the select menu is select, the value of array element or object property
     * represented by the selected option will be bound to the model identified by the `ng-model` attribute
     * of the parent select element.
     *
     * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can
     * be nested into the `<select>` element. This element will then represent `null` or "not selected"
     * option. See example below for demonstration.
     *
     * Note: `ng-options` provides iterator facility for `<option>` element which must be used instead
     * of {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat}. `ng-repeat` is not suitable for use with
     * `<option>` element because of the following reasons:
     *
     *   * value attribute of the option element that we need to bind to requires a string, but the
     *     source of data for the iteration might be in a form of array containing objects instead of
     *     strings
     *   * {@link angular.module.ng.$compileProvider.directive.ng-repeat ng-repeat} unrolls after the select binds causing
     *     incorect rendering on most browsers.
     *   * binding to a value not in list confuses most browsers.
     *
     * @param {string} name assignable expression to data-bind to.
     * @param {string=} required The control is considered valid only if value is entered.
     * @param {comprehension_expression=} ng-options in one of the following forms:
     *
     *   * for array data sources:
     *     * `label` **`for`** `value` **`in`** `array`
     *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`
     *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`
     *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array`
     *   * for object data sources:
     *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
     *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`
     *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`
     *     * `select` **`as`** `label` **`group by`** `group`
     *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`
     *
     * Where:
     *
     *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.
     *   * `value`: local variable which will refer to each item in the `array` or each property value
     *      of `object` during iteration.
     *   * `key`: local variable which will refer to a property name in `object` during iteration.
     *   * `label`: The result of this expression will be the label for `<option>` element. The
     *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).
     *   * `select`: The result of this expression will be bound to the model of the parent `<select>`
     *      element. If not specified, `select` expression will default to `value`.
     *   * `group`: The result of this expression will be used to group options using the `<optgroup>`
     *      DOM element.
     *
     * @example
     <doc:example>
     <doc:source>
     <script>
     function MyCntrl($scope) {
     $scope.colors = [
     {name:'black', shade:'dark'},
     {name:'white', shade:'light'},
     {name:'red', shade:'dark'},
     {name:'blue', shade:'dark'},
     {name:'yellow', shade:'light'}
     ];
     $scope.color = $scope.colors[2]; // red
     }
     </script>
     <div ng-controller="MyCntrl">
     <ul>
     <li ng-repeat="color in colors">
     Name: <input ng-model="color.name">
     [<a href ng-click="colors.$remove(color)">X</a>]
     </li>
     <li>
     [<a href ng-click="colors.push({})">add</a>]
     </li>
     </ul>
     <hr/>
     Color (null not allowed):
     <select ng-model="color" ng-options="c.name for c in colors"></select><br>

     Color (null allowed):
     <div  class="nullable">
     <select ng-model="color" ng-options="c.name for c in colors">
     <option value="">-- chose color --</option>
     </select>
     </div><br/>

     Color grouped by shade:
     <select ng-model="color" ng-options="c.name group by c.shade for c in colors">
     </select><br/>


     Select <a href ng-click="color={name:'not in list'}">bogus</a>.<br>
     <hr/>
     Currently selected: {{ {selected_color:color}  }}
     <div style="border:solid 1px black; height:20px"
     ng-style="{'background-color':color.name}">
     </div>
     </div>
     </doc:source>
     <doc:scenario>
     it('should check ng-options', function() {
     expect(binding('{selected_color:color}')).toMatch('red');
     select('color').option('0');
     expect(binding('{selected_color:color}')).toMatch('black');
     using('.nullable').select('color').option('');
     expect(binding('{selected_color:color}')).toMatch('null');
     });
     </doc:scenario>
     </doc:example>
     */

    var ngOptionsDirective = valueFn({ terminal: true });
    var selectDirective = ['$compile', '$parse', function($compile,   $parse) {
        //00001111100000000000222200000000000000000000003333000000000000044444444444444444000000000555555555555555550000000666666666666666660000000000000007777
        var NG_OPTIONS_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?(?:\s+group\s+by\s+(.*))?\s+for\s+(?:([\$\w][\$\w\d]*)|(?:\(\s*([\$\w][\$\w\d]*)\s*,\s*([\$\w][\$\w\d]*)\s*\)))\s+in\s+(.*)$/;

        return {
            restrict: 'E',
            require: '?ngModel',
            link: function(scope, element, attr, ctrl) {
                if (!ctrl) return;

                var multiple = attr.multiple,
                    optionsExp = attr.ngOptions;

                // required validator
                if (multiple && (attr.required || attr.ngRequired)) {
                    var requiredValidator = function(value) {
                        ctrl.$setValidity('required', !attr.required || (value && value.length));
                        return value;
                    };

                    ctrl.$parsers.push(requiredValidator);
                    ctrl.$formatters.unshift(requiredValidator);

                    attr.$observe('required', function() {
                        requiredValidator(ctrl.$viewValue);
                    });
                }

                if (optionsExp) Options(scope, element, ctrl);
                else if (multiple) Multiple(scope, element, ctrl);
                else Single(scope, element, ctrl);


                ////////////////////////////



                function Single(scope, selectElement, ctrl) {
                    ctrl.$render = function() {
                        selectElement.val(ctrl.$viewValue);
                    };

                    selectElement.bind('change', function() {
                        scope.$apply(function() {
                            ctrl.$setViewValue(selectElement.val());
                        });
                    });
                }

                function Multiple(scope, selectElement, ctrl) {
                    var lastView;
                    ctrl.$render = function() {
                        var items = new HashMap(ctrl.$viewValue);
                        forEach(selectElement.children(), function(option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };

                    // we have to do it on each watch since ng-model watches reference, but
                    // we need to work of an array, so we need to see if anything was inserted/removed
                    scope.$watch(function() {
                        if (!equals(lastView, ctrl.$viewValue)) {
                            lastView = copy(ctrl.$viewValue);
                            ctrl.$render();
                        }
                    });

                    selectElement.bind('change', function() {
                        scope.$apply(function() {
                            var array = [];
                            forEach(selectElement.children(), function(option) {
                                if (option.selected) {
                                    array.push(option.value);
                                }
                            });
                            ctrl.$setViewValue(array);
                        });
                    });
                }

                function Options(scope, selectElement, ctrl) {
                    var match;

                    if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {
                        throw Error(
                            "Expected ng-options in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_'" +
                                " but got '" + optionsExp + "'.");
                    }

                    var displayFn = $parse(match[2] || match[1]),
                        valueName = match[4] || match[6],
                        keyName = match[5],
                        groupByFn = $parse(match[3] || ''),
                        valueFn = $parse(match[2] ? match[1] : valueName),
                        valuesFn = $parse(match[7]),
                        // we can't just jqLite('<option>') since jqLite is not smart enough
                        // to create it in <select> and IE barfs otherwise.
                        optionTemplate = jqLite(document.createElement('option')),
                        optGroupTemplate = jqLite(document.createElement('optgroup')),
                        nullOption = false, // if false then user will not be able to select it
                        // This is an array of array of existing option groups in DOM. We try to reuse these if possible
                        // optionGroupsCache[0] is the options with no option group
                        // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element
                        optionGroupsCache = [[{element: selectElement, label:''}]];

                    // find existing special options
                    forEach(selectElement.children(), function(option) {
                        if (option.value == '') {
                            // developer declared null option, so user should be able to select it
                            nullOption = jqLite(option).remove();
                            // compile the element since there might be bindings in it
                            $compile(nullOption)(scope);
                        }
                    });
                    selectElement.html(''); // clear contents

                    selectElement.bind('change', function() {
                        scope.$apply(function() {
                            var optionGroup,
                                collection = valuesFn(scope) || [],
                                locals = {},
                                key, value, optionElement, index, groupIndex, length, groupLength;

                            if (multiple) {
                                value = [];
                                for (groupIndex = 0, groupLength = optionGroupsCache.length;
                                     groupIndex < groupLength;
                                     groupIndex++) {
                                    // list of options for that group. (first item has the parent)
                                    optionGroup = optionGroupsCache[groupIndex];

                                    for(index = 1, length = optionGroup.length; index < length; index++) {
                                        if ((optionElement = optionGroup[index].element)[0].selected) {
                                            key = optionElement.val();
                                            if (keyName) locals[keyName] = key;
                                            locals[valueName] = collection[key];
                                            value.push(valueFn(scope, locals));
                                        }
                                    }
                                }
                            } else {
                                key = selectElement.val();
                                if (key == '?') {
                                    value = undefined;
                                } else if (key == ''){
                                    value = null;
                                } else {
                                    locals[valueName] = collection[key];
                                    if (keyName) locals[keyName] = key;
                                    value = valueFn(scope, locals);
                                }
                            }
                            ctrl.$setViewValue(value);
                        });
                    });

                    ctrl.$render = render;

                    // TODO(vojta): can't we optimize this ?
                    scope.$watch(render);

                    function render() {
                        var optionGroups = {'':[]}, // Temporary location for the option groups before we render them
                            optionGroupNames = [''],
                            optionGroupName,
                            optionGroup,
                            option,
                            existingParent, existingOptions, existingOption,
                            modelValue = ctrl.$modelValue,
                            values = valuesFn(scope) || [],
                            keys = keyName ? sortedKeys(values) : values,
                            groupLength, length,
                            groupIndex, index,
                            locals = {},
                            selected,
                            selectedSet = false, // nothing is selected yet
                            lastElement,
                            element;

                        if (multiple) {
                            selectedSet = new HashMap(modelValue);
                        } else if (modelValue === null || nullOption) {
                            // if we are not multiselect, and we are null then we have to add the nullOption
                            optionGroups[''].push({selected:modelValue === null, id:'', label:''});
                            selectedSet = true;
                        }

                        // We now build up the list of options we need (we merge later)
                        for (index = 0; length = keys.length, index < length; index++) {
                            locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];
                            optionGroupName = groupByFn(scope, locals) || '';
                            if (!(optionGroup = optionGroups[optionGroupName])) {
                                optionGroup = optionGroups[optionGroupName] = [];
                                optionGroupNames.push(optionGroupName);
                            }
                            if (multiple) {
                                selected = selectedSet.remove(valueFn(scope, locals)) != undefined;
                            } else {
                                selected = modelValue === valueFn(scope, locals);
                                selectedSet = selectedSet || selected; // see if at least one item is selected
                            }
                            optionGroup.push({
                                id: keyName ? keys[index] : index,   // either the index into array or key from object
                                label: displayFn(scope, locals) || '', // what will be seen by the user
                                selected: selected                   // determine if we should be selected
                            });
                        }
                        if (!multiple && !selectedSet) {
                            // nothing was selected, we have to insert the undefined item
                            optionGroups[''].unshift({id:'?', label:'', selected:true});
                        }

                        // Now we need to update the list of DOM nodes to match the optionGroups we computed above
                        for (groupIndex = 0, groupLength = optionGroupNames.length;
                             groupIndex < groupLength;
                             groupIndex++) {
                            // current option group name or '' if no group
                            optionGroupName = optionGroupNames[groupIndex];

                            // list of options for that group. (first item has the parent)
                            optionGroup = optionGroups[optionGroupName];

                            if (optionGroupsCache.length <= groupIndex) {
                                // we need to grow the optionGroups
                                existingParent = {
                                    element: optGroupTemplate.clone().attr('label', optionGroupName),
                                    label: optionGroup.label
                                };
                                existingOptions = [existingParent];
                                optionGroupsCache.push(existingOptions);
                                selectElement.append(existingParent.element);
                            } else {
                                existingOptions = optionGroupsCache[groupIndex];
                                existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element

                                // update the OPTGROUP label if not the same.
                                if (existingParent.label != optionGroupName) {
                                    existingParent.element.attr('label', existingParent.label = optionGroupName);
                                }
                            }

                            lastElement = null;  // start at the begining
                            for(index = 0, length = optionGroup.length; index < length; index++) {
                                option = optionGroup[index];
                                if ((existingOption = existingOptions[index+1])) {
                                    // reuse elements
                                    lastElement = existingOption.element;
                                    if (existingOption.label !== option.label) {
                                        lastElement.text(existingOption.label = option.label);
                                    }
                                    if (existingOption.id !== option.id) {
                                        lastElement.val(existingOption.id = option.id);
                                    }
                                    if (existingOption.element.selected !== option.selected) {
                                        lastElement.prop('selected', (existingOption.selected = option.selected));
                                    }
                                } else {
                                    // grow elements

                                    // if it's a null option
                                    if (option.id === '' && nullOption) {
                                        // put back the pre-compiled element
                                        element = nullOption;
                                    } else {
                                        // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but
                                        // in this version of jQuery on some browser the .text() returns a string
                                        // rather then the element.
                                        (element = optionTemplate.clone())
                                            .val(option.id)
                                            .attr('selected', option.selected)
                                            .text(option.label);
                                    }

                                    existingOptions.push(existingOption = {
                                        element: element,
                                        label: option.label,
                                        id: option.id,
                                        selected: option.selected
                                    });
                                    if (lastElement) {
                                        lastElement.after(element);
                                    } else {
                                        existingParent.element.append(element);
                                    }
                                    lastElement = element;
                                }
                            }
                            // remove any excessive OPTIONs in a group
                            index++; // increment since the existingOptions[0] is parent element not OPTION
                            while(existingOptions.length > index) {
                                existingOptions.pop().element.remove();
                            }
                        }
                        // remove any excessive OPTGROUPs from select
                        while(optionGroupsCache.length > groupIndex) {
                            optionGroupsCache.pop()[0].element.remove();
                        }
                    };
                }
            }
        }
    }];

    var optionDirective = ['$interpolate', function($interpolate) {
        return {
            restrict: 'E',
            priority: 100,
            compile: function(element, attr) {
                if (isUndefined(attr.value)) {
                    var interpolateFn = $interpolate(element.text(), true);
                    if (interpolateFn) {
                        return function (scope, element, attr) {
                            scope.$watch(interpolateFn, function(value) {
                                attr.$set('value', value);
                            });
                        }
                    } else {
                        attr.$set('value', element.text());
                    }
                }
            }
        }
    }];

    var styleDirective = valueFn({
        restrict: 'E',
        terminal: true
    });
    //try to bind to jquery now so that one can write angular.element().read()
    //but we will rebind on bootstrap again.
    bindJQuery();

    publishExternalAPI(angular);

    jqLite(document).ready(function() {
        angularInit(document, bootstrap);
    });

})(window, document);
angular.element(document).find('head').append('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak{display:none;}ng\\:form{display:block;}</style>');

/**
 * Simple implementation of require/define assuming all
 * modules are named, in one file and in the correct order.
 */
(function (window) {

    var defined = [];
    var def;
    var jqmng = window.jqmng = {};
    jqmng.define = def = function(name, deps, value) {
        var dotJs = name.indexOf('.js');
        if (dotJs!==-1) {
            name = name.substring(0, dotJs);
        }
        if (arguments.length==2) {
            // No deps...
            value = deps;
            deps = [];
        }
        if (typeof value === 'function') {
            var args = [];
            for (var i=0; i<deps.length; i++) {
                var dep = deps[i];
                args.push(defined[dep]);
            }
            value = value.apply(this, args);
        }
        defined[name] = value;
    };

    jqmng.require = function(deps, callback) {
        if (typeof callback === 'function') {
            var args = [];
            for (var i=0; i<deps.length; i++) {
                var dep = deps[i];
                args.push(defined[dep]);
            }
            callback.apply(this, args);
        }

    }
})(window);


jqmng.define('angular', function() {
    if (typeof angular !== "undefined") {
        return angular;
    }
});
jqmng.define('jquery', function() {
    if (typeof $ !== "undefined") {
        return $;
    }
});
jqmng.define('jqmng/scopeReconnect', ['angular'], function (angular) {

    var ng = angular.module('ng');
    ng.config(['$provide', function($provide) {
        $provide.decorator('$rootScope', ['$delegate', function($rootScope) {
            var _$destroy = $rootScope.$destroy;
            $rootScope.$destroy = function() {
                this.$$destroyed = true;
                var res = _$destroy.apply(this, arguments);
                this.$$nextSibling = this.$$prevSibling = null;
            };
            $rootScope.$reconnect = function() {
                var child = this;
                if (child===$rootScope) {
                    // Nothing to do here.
                    return;
                }
                if (!child.$$destroyed) {
                    return;
                }
                var parent = child.$parent;
                child.$$destroyed = false;
                // See Scope.$new for this logic...
                child.$$prevSibling = parent.$$childTail;
                if (parent.$$childHead) {
                    parent.$$childTail.$$nextSibling = child;
                    parent.$$childTail = child;
                } else {
                    parent.$$childHead = parent.$$childTail = child;
                }

            };
            return $rootScope;
        }]);
    }]);
});
jqmng.define('jqmng/event', ['angular'], function (angular) {
    var mod = angular.module('ng');

    /**
     * A widget to bind general events like touches, ....
     */
    mod.directive("ngmEvent", function () {
        return {
            compile:function (element, attrs) {
                var eventHandlers = angular.fromJson(attrs.ngmEvent);
                return function (scope, element, attrs) {
                    for (var eventType in eventHandlers) {
                        registerEventHandler(scope, element, eventType, eventHandlers[eventType]);
                    }
                }
            }
        }
    });

    function registerEventHandler(scope, element, eventType, handler) {
        element.bind(eventType, function (event) {
            var res = scope.$apply(handler, element);
            if (eventType.charAt(0) == 'v') {
                // This is required to prevent a second
                // click event, see
                // https://github.com/jquery/jquery-mobile/issues/1787
                event.preventDefault();
            }
        });
    }

    function createEventDirective(directive, eventType) {
        mod.directive(directive, function () {
            return function (scope, element,attrs) {
                var eventHandler = attrs[directive];
                registerEventHandler(scope, element, eventType, eventHandler);
            };
        });
    }

    var eventDirectives = {ngmTaphold:'taphold', ngmSwipe:'swipe', ngmSwiperight:'swiperight',
        ngmSwipeleft:'swipeleft',
        ngmPagebeforeshow:'pagebeforeshow',
        ngmPagebeforehide:'pagebeforehide',
        ngmPageshow:'pageshow',
        ngmPagehide:'pagehide',
        ngmClick:'vclick'
    };
    for (var directive in eventDirectives) {
        createEventDirective(directive, eventDirectives[directive])
    }

});
/*
 * Defines the ng:if tag. This is useful if jquery mobile does not allow
 * an ng:switch element in the dom, e.g. between ul and li.
 * Uses ng:repeat and angular.Object.iff under the hood.
 */
jqmng.define('jqmng/if', ['angular'], function (angular) {
    var mod = angular.module('ng');
    var ngIfDirective = {
        transclude: 'element',
        priority: 1000,
        terminal: true,
        compile: function(element, attr, linker) {
            return function(scope, iterStartElement, attr){
                var expression = attr.ngmIf;

                var lastElement;
                var lastScope;
                scope.$watch(expression, function(newValue){
                        if (newValue) {
                            lastScope = scope.$new();
                            linker(lastScope, function(clone){
                                lastElement = clone;
                                iterStartElement.after(clone);
                            });
                        } else {
                            lastElement && lastElement.remove();
                            lastScope && lastScope.$destroy();
                        }
                    });
            };
        }
    };
    mod.directive('ngmIf', function() { return ngIfDirective; });
});

jqmng.define('jqmng/navigate', ['jquery', 'angular'], function($, angular) {
    function splitAtFirstColon(value) {
        var pos = value.indexOf(':');
        if (pos===-1) {
            return [value];
        }
        return [
            value.substring(0, pos),
            value.substring(pos+1)
        ];
    }

    function callActivateFnOnPageChange(fnName, params) {
        if (fnName) {
            $(document).one("pagebeforechange", function(event, data) {
                var toPageUrl = $.mobile.path.parseUrl( data.toPage );
                var page = $("#"+toPageUrl.hash.substring(1));
                function executeCall() {
                    var scope = page.scope();
                    scope[fnName].apply(scope, params);
                }
                if (!page.data("page")) {
                    page.one("pagecreate", executeCall);
                    return;
                }
                executeCall();
            });
        }
    }

    /*
     * Service for page navigation.
     * @param target has the syntax: [<transition>:]pageId
     * @param activateFunctionName Function to call in the target scope.
     * @param further params Parameters for the function that should be called in the target scope.
     */
    function navigate(target, activateFunctionName) {
        var activateParams = Array.prototype.slice.call(arguments, 2);
        var navigateOptions, pageId;
        callActivateFnOnPageChange(activateFunctionName, activateParams);
        if (typeof target === 'object') {
            navigateOptions = target;
            pageId = navigateOptions.target;
        } else {
            var parts = splitAtFirstColon(target);
            if (parts.length === 2 && parts[0] === 'back') {
                var pageId = parts[1];
                var relativeIndex = getIndexInStack(pageId);
                if (relativeIndex === undefined) {
                    pageId = jqmChangePage(pageId, {reverse: true});
                } else {
                    window.history.go(relativeIndex);
                }
                return;
            } else if (parts.length === 2) {
                navigateOptions = { transition: parts[0] };
                pageId = parts[1];
            } else {
                pageId = parts[0];
                navigateOptions = undefined;
            }
        }
        if (pageId === 'back') {
            window.history.go(-1);
        } else {
            jqmChangePage(pageId, navigateOptions);
        }
    }

    function jqmChangePage(pageId, navigateOptions) {
        var callArgs = [pageId];
        if (navigateOptions) {
            callArgs.push(navigateOptions);
        }
        $.mobile.changePage.apply($.mobile, callArgs);
        return pageId;
    }


    var mod = angular.module('ng');
    mod.factory('$navigate', function() {
        return navigate;
    });

    function getIndexInStack(pageId) {
        var stack = $.mobile.urlHistory.stack;
        var res = 0;
        var pageUrl;
        for (var i = stack.length - 2; i >= 0; i--) {
            pageUrl = stack[i].pageUrl;
            if (pageUrl === pageId) {
                return i - stack.length + 1;
            }
        }
        return undefined;
    }

    mod.run(['$rootScope', '$navigate', function($rootScope, $navigate) {
        $rootScope.$navigate = function() {
            var args = Array.prototype.slice.call(arguments);
            args.unshift($navigate);
            return navigateExpression.apply(this, args);
        }
    }]);

    mod.filter('navigate', ['$navigate', function($navigateService) {
        return function(test) {
            // parse the arguments...
            var outcomes = {};
            var parts;
            for (var i = 1; i < arguments.length; i++) {
                parts = splitAtFirstColon(arguments[i]);
                outcomes[parts[0]] = parts[1];
            }
            if (test && test.then) {
                // test is a promise.
                test.then(function(test) {
                    if (outcomes[test]) {
                        $navigateService(outcomes[test]);
                    } else if (outcomes.success) {
                        $navigateService(outcomes.success);
                    }
                }, function(test) {
                    if (outcomes[test]) {
                        $navigateService(outcomes[test]);
                    } else if (outcomes.failure) {
                        $navigateService(outcomes.failure);
                    }
                });
            } else {
                if (outcomes[test]) {
                    $navigateService(outcomes[test]);
                } else if (test !== false && outcomes.success) {
                    $navigateService(outcomes.success);
                } else if (test === false && outcomes.failure) {
                    $navigateService(outcomes.failure);
                }
            }
        };
    }]);

    return navigate;

});
jqmng.define('jqmng/sharedController', ['angular'], function(angular) {
    var storageName = '$$sharedControllers';

    function storage(rootScope) {
        return rootScope[storageName] = rootScope[storageName] || {};
    }

    function sharedCtrl(rootScope, controllerName, $controller, usedInPage) {
        var store = storage(rootScope);
        var scopeInstance = store[controllerName];
        if (!scopeInstance) {
            scopeInstance = rootScope.$new();
            $controller(controllerName, {$scope: scopeInstance});
            store[controllerName] = scopeInstance;
            scopeInstance.$$referenceCount = 0;
        }
        scopeInstance.$$referenceCount++;
        usedInPage.bind("$destroy", function() {
            scopeInstance.$$referenceCount--;
            if (scopeInstance.$$referenceCount===0) {
                scopeInstance.$destroy();
                delete store[controllerName];
            }
        });
        return scopeInstance;
    }

    function parseSharedControllersExpression(expression) {
        var pattern = /([^\s,:]+)\s*:\s*([^\s,:]+)/g;
        var match;
        var hasData = false;
        var controllers = {};
        while (match = pattern.exec(expression)) {
            hasData = true;
            controllers[match[1]] = match[2];
        }
        if (!hasData) {
            throw "Expression " + expression + " needs to have the syntax <name>:<controller>,...";
        }
        return controllers;
    }

    var mod = angular.module('ng');
    mod.directive('ngmSharedController', ['$controller', function($controller) {
        return {
            scope: true,
            compile: function(element, attrs) {
                var expression = attrs.ngmSharedController;
                var controllers = parseSharedControllersExpression(expression);
                var preLink = function(scope) {
                    for (var name in controllers) {
                        scope[name] = sharedCtrl(scope.$root, controllers[name], $controller, element);
                    }
                };
                return {
                    pre: preLink
                }
            }
        };
    }]);
});
/*
 * waitdialog service.
 */
jqmng.define('jqmng/waitDialog', ['jquery'], function($) {
    var showCalls = [];

    function onClick(event) {
        var lastCall = showCalls[showCalls.length - 1];
        if (lastCall.callback) {
            rootScope.$apply(function() {
                lastCall.callback.apply(this, arguments);
            });
        }
        // This is required to prevent a second
        // click event, see
        // https://github.com/jquery/jquery-mobile/issues/1787
        event.preventDefault();
    }

    var loadDialog;

    function initIfNeeded() {
        if (!loadDialog || loadDialog.length == 0) {
            loadDialog = $(".ui-loader");
            loadDialog.bind('vclick', onClick);
        }
    }

    if (!$.mobile.loadingMessageWithCancel) {
        $.mobile.loadingMessageWithCancel = 'Loading. Click to cancel.';
    }

    function updateUi() {
        initIfNeeded();
        if (showCalls.length > 0) {
            var lastCall = showCalls[showCalls.length - 1];
            var msg = lastCall.msg;
            var oldMessage = $.mobile.loadingMessage;
            var oldTextVisible = $.mobile.loadingMessageTextVisible;
            if (msg) {
                $.mobile.loadingMessage = msg;
                $.mobile.loadingMessageTextVisible = true;
            }
            $.mobile.showPageLoadingMsg();
            $.mobile.loadingMessageTextVisible = oldTextVisible;
            $.mobile.loadingMessage = oldMessage;
        } else {
            $.mobile.hidePageLoadingMsg();
        }
    }

    /**
     * jquery mobile hides the wait dialog when pages are transitioned.
     * This immediately closes wait dialogs that are opened in the pagebeforeshow event.
     */
    $('div').live('pageshow', function(event, ui) {
        updateUi();
    });

    /**
     *
     * @param msg (optional)
     * @param tapCallback (optional)
     */
    function show() {
        var msg, tapCallback;
        if (typeof arguments[0] == 'string') {
            msg = arguments[0];
        }
        if (typeof arguments[0] == 'function') {
            tapCallback = arguments[0];
        }
        if (typeof arguments[1] == 'function') {
            tapCallback = arguments[1];
        }

        showCalls.push({msg: msg, callback: tapCallback});
        updateUi();
    }

    function hide() {
        showCalls.pop();
        updateUi();
    }

    function always(promise, callback) {
        promise.then(callback, callback);
    }

    /**
     *
     * @param promise
     * @param msg (optional)
     */
    function waitFor(promise, msg) {
        show(msg);
        always(promise, function() {
            hide();
        });
    }

    /**
     *
     * @param deferred
     * @param cancelData
     * @param msg (optional)
     */
    function waitForWithCancel(deferred, cancelData, msg) {
        if (!msg) {
            msg = $.mobile.loadingMessageWithCancel;
        }
        show(msg, function() {
            deferred.reject(cancelData);
        });
        always(deferred.promise, function() {
            hide();
        });
    }

    var res = {
        show: show,
        hide: hide,
        waitFor: waitFor,
        waitForWithCancel:waitForWithCancel
    };

    var mod = angular.module('ng');
    var rootScope;
    mod.factory('$waitDialog', ['$rootScope', function($rootScope) {
        rootScope = $rootScope;
        return res;
    }]);

    return res;
});
jqmng.define('jqmng/widgets/angularInput', ['jquery', 'angular'], function ($, angular) {
    function isCheckboxRadio(element) {
        return element.filter($.mobile.checkboxradio.prototype.options.initSelector)
            .not(":jqmData(role='none'), :jqmData(role='nojs')").length > 0;

    }

    function isTextInput(element) {
        return element.filter($.mobile.textinput.prototype.options.initSelector)
            .not(":jqmData(role='none'), :jqmData(role='nojs')").length > 0;
    }

    var mod = angular.module('ng');
    mod.directive("input", function () {
        return {
            restrict: 'E',
            require: '?ngModel',
            compile:function (tElement, tAttrs) {
                var textinput = isTextInput(tElement);
                var checkboxRadio = isCheckboxRadio(tElement);

                var name = tElement.attr('name');
                var type = tElement.attr('type');

                return {
                    pre:function (scope, iElement, iAttrs, ctrl) {
                        if (!ctrl) {
                            return;
                        }
                        var _bind = iElement.bind;
                        if (checkboxRadio) {
                            // Angular binds to the click event for radio and check boxes,
                            // but jquery mobile fires a change event. So be sure that angular only listens to the change event,
                            // and no more to the click event, as the click event is too early / jqm has not updated
                            // the checked status.

                            iElement.bind = function (events, callback) {
                                if (events.indexOf('click') != -1) {
                                    events = "change";
                                }
                                return _bind.call(this, events, callback);
                            };
                        }
                    },
                    post:function (scope, iElement, iAttrs, ctrl) {
                        if (!ctrl) {
                            return;
                        }
                        var _$render = ctrl.$render;
                        ctrl.$render = function() {
                            var res = _$render.apply(this, arguments);
                            // Angular only sets the checked property on the dom element,
                            // but not explicitly the css attribute. However, the later is checked by jquery mobile.
                            if (checkboxRadio) {
                                iElement.attr('checked', iElement[0].checked);
                            }
                            var data = iElement.data();
                            for (var key in data) {
                                var widget = data[key];
                                if (widget.refresh) {
                                    iElement[key]("refresh");
                                }
                            }

                            return res;
                        };
                    }

                }
            }
        };

    });
});

jqmng.define('jqmng/widgets/angularRepeat', ['jquery', 'angular'], function ($, angular) {

    /**
     * Modify the original repeat: Make sure that all elements are added under the same parent.
     * This is important, as some jquery mobile widgets wrap the elements into new elements,
     * and angular just uses element.after().
     */
    function instrumentNodeFunction(parent, node, fnName) {
        var _old = node[fnName];
        node[fnName] = function (otherNode) {
            var target = this;
            while (target.parent()[0] !== parent) {
                target = target.parent();
                if (target.length === 0) {
                    throw new Error("Could not find the expected parent in the node path", this, parent);
                }
            }
            instrumentNode(parent, otherNode);
            return _old.call(target, otherNode);
        };
    }

    function instrumentNode(parent, node) {
        var fns = ['after', 'before'];
        for (var i = 0; i < fns.length; i++) {
            instrumentNodeFunction(parent, node, fns[i]);
        }
    }

    var mod = angular.module('ng');
    mod.directive('ngRepeat', function () {
        return {
            priority:1000, // same as original repeat
            compile:function (element, attr, linker) {
                return {
                    pre:function (scope, iterStartElement, attr) {
                        instrumentNode(iterStartElement.parent()[0], iterStartElement);
                    }
                };
            }
        };
    });

});
jqmng.define('jqmng/widgets/angularSelect', ['jquery', 'angular'], function ($, angular) {
    var mod = angular.module('ng');
    mod.directive("select", function () {
        return {
            restrict:'E',
            require:'?ngModel',
            compile:function (tElement, tAttrs) {
                return {
                    post:function (scope, iElement, iAttrs, ctrl) {
                        if (!ctrl) {
                            return;
                        }
                        var _$render = ctrl.$render;
                        ctrl.$render = function () {
                            var res = _$render.apply(this, arguments);
                            var data = iElement.data();
                            for (var key in data) {
                                var widget = data[key];
                                if (widget.refresh) {
                                    iElement[key]("refresh");
                                }
                            }

                            return res;
                        };
                    }
                }

            }
        }
    });
});
jqmng.define('jqmng/widgets/disabledHandling', ['jquery', 'angular'], function ($, angular) {
        var mod = angular.module('ng');

        function instrumentAttrSetter(element, attr) {
            // Note: We cannot use attr.$observe here, as we also want to
            // be able to listen to ng-bind-attr!
            var _$set = attr.$set;
            if (_$set.instrumented) {
                return;
            }
            attr.$set = function (key, value) {
                var res = _$set.apply(this, arguments);
                if (key === 'disabled') {
                    var jqmOperation = 'enable';
                    if (value === 'disabled' || value == 'true') {
                        jqmOperation = 'disable';
                    }
                    var data = element.data();
                    for (var key in data) {
                        var widget = data[key];
                        if (widget[jqmOperation]) {
                            element[key](jqmOperation);
                        }
                    }
                }
                return res;
            };
            attr.$set.instrumented = true;
        }

        mod.directive('ngBindAttr', function () {
            return {
                compile:function () {
                    return {
                        post:function (scope, element, attr) {
                            instrumentAttrSetter(element, attr);
                        }
                    }
                }
            }
        });

        mod.directive('disabled', function () {
            return {
                compile:function () {
                    return {
                        post:function (scope, element, attr) {
                            instrumentAttrSetter(element, attr);
                        }
                    }
                }
            }
        });

        mod.directive('ngDisabled', function () {
            return {
                compile:function () {
                    return {
                        post:function (scope, element, attr) {
                            instrumentAttrSetter(element, attr);
                        }
                    }
                }
            }
        });
    }
);
jqmng.define('jqmng/widgets/jqmButton', [
    'jquery'
], function($) {
    // Button wraps the actual button into another div that is stored in the
    // "button" property.
    var fn = $.mobile.button.prototype;
    var oldDestroy = fn.destroy;
    fn.destroy = function() {
        // Destroy the widget instance first to prevent
        // a stack overflow.
        oldDestroy.apply(this, arguments);
        this.button.remove();
    };

});
jqmng.define('jqmng/widgets/jqmListView', [
    'jquery'
], function($) {
    // Listview may create subpages that need to be removed when the widget is destroyed.
    var fn = $.mobile.listview.prototype;
    var oldDestroy = fn.destroy;
    fn.destroy = function() {
        // Destroy the widget instance first to prevent
        // a stack overflow.
        // Note: If there are more than 1 listview on the page, childPages will return
        // the child pages of all listviews.
        var id = this.element.attr('id');
        var childPageRegex = new RegExp($.mobile.subPageUrlKey + "=" +id+"-");
        var childPages = this.childPages();
        oldDestroy.apply(this, arguments);
        for (var i=0; i<childPages.length; i++) {
            var childPage = $(childPages[i]);
            var dataUrl = childPage.attr('data-url');
            if (dataUrl.match(childPageRegex)) {
                childPage.remove();
            }
        }
    };
    var oldCreate = fn._create;
    fn._create = function() {
        var self = this;
        var res = oldCreate.apply(this, arguments);
        // refresh the list when the children change.
        this.element.bind('create', function(event) {
            self.refresh();
            // register listeners when the children are destroyed.
            // Do this only once per child.
            var children = self.element.children('li');
            var child, i;
            for (i=0; i<children.length; i++) {
                child = children.eq(i);
                if (!child.data('listlistener')) {
                    child.data('listlistener', true);
                    child.bind("remove", function() {
                        self.refresh();
                    });
                }
            }
        });
    };
});

jqmng.define('jqmng/widgets/jqmSelectMenu', ['jquery'], function($) {

    // selectmenu may create parent element and extra pages
    var fn = $.mobile.selectmenu.prototype;
    var oldDestroy = fn.destroy;
    fn.destroy = function() {
        // Destroy the widget instance first to prevent
        // a stack overflow.
        var parent = this.element.closest(".ui-select");
        var menuPage = this.menuPage;
        var screen = this.screen;
        var listbox = this.listbox;
        oldDestroy.apply(this, arguments);
        parent && parent.remove();
        menuPage && menuPage.remove();
        screen && screen.remove();
        listbox && listbox.remove();
    };
    var oldCreate = fn._create;
    fn._create = function() {
        var res = oldCreate.apply(this, arguments);
        var self = this;

        // Note: We cannot use the prototype here,
        // as there is a plugin in jquery mobile that overwrites
        // the open functions...
        var oldOpen = self.open;
        self.open = function() {
            this.refresh();
            return oldOpen.apply(this, arguments);
        };
    };
});
jqmng.define('jqmng/widgets/jqmSlider', ['jquery'], function($) {
    // Slider wraps the actual input into another div that is stored in the
    // "slider" property.
    var fn = $.mobile.slider.prototype;
    var oldDestroy = fn.destroy;
    fn.destroy = function() {
        // Destroy the widget instance first to prevent
        // a stack overflow.
        oldDestroy.apply(this, arguments);
        this.slider.remove();
    };
});
jqmng.define('jqmng/widgets/pageCompile', ['jquery', 'angular'], function ($, angular) {
    /**
     * For refreshing widgets we implement a new strategy for jquery mobile:
     * When new elements are added or removed to the dom, the requestrefresh event is fired on those elements.
     * All elements that have a refresh event and through which the event passes are marked.
     * During the next page create event those widgets automatically refresh themselves.
     * The page create event is automatically fired at the end of every $%digest, when at least one requestrefresh
     * event happened.
     */
    function listenTojQueryFunction(fnName) {
        var oldFn = $.fn[fnName];
        $.fn[fnName] = function () {
            this.parent().trigger('requestrefresh');
            return oldFn.apply(this, arguments);
        };
    }

    function fireRequestrefreshWhenDomIsManipulatedWithjQuery() {
        var changeFns = ['domManip', 'html', 'remove'];
        for (var i = 0; i < changeFns.length; i++) {
            listenTojQueryFunction(changeFns[i]);
        }
    }

    fireRequestrefreshWhenDomIsManipulatedWithjQuery();



    function instrumentRefreshOnInit(widget) {
        var _create = widget.prototype._create;
        widget.prototype._create = function () {
            var res = _create.apply(this, arguments);
            var self = this;
            this.element.bind("requestrefresh", function () {
                self.requestrefresh = true;
            });

            return res;
        };
        // the _init function is called whenever the widget is
        // called like this: element.widget().
        // This happens every time the create event is fired through jquery mobile.
        var _init = widget.prototype._init;
        widget.prototype._init = function () {
            var res = _init.apply(this, arguments);
            if (this.requestrefresh) {
                this.requestrefresh = false;
                this.refresh();
            }
            return res;
        };

    }

    function instrumentWidgetsWithRefreshFunction() {
        for (var name in $.mobile) {
            var val = $.mobile[name];
            if (typeof val === 'function') {
                if (val.prototype.refresh) {
                    instrumentRefreshOnInit(val);
                }
            }
        }
    }

    instrumentWidgetsWithRefreshFunction();

    $('div').live('pagebeforeshow', function (event, data) {
        var page = $(event.target);
        var currPageScope = page.scope();
        if (page.data('angularLinked') && currPageScope) {
            // We only need to trigger the digest for pages
            // creates by angular, and not for those that are dynamically created by jquery mobile.
            currPageScope.$reconnect();
            currPageScope.$root.$digest();
        }
    });

    $('div').live('pagebeforehide', function (event, data) {
        var page = $(event.target);
        var currPageScope = page.scope();
        if (page.data('angularLinked') && currPageScope) {
            currPageScope.$destroy();
        }
    });

    var ng = angular.module('ng');
    ng.run(patchRootDigest);
    ng.run(deactivateAngularLocationService);

    var _page = $.fn.page;
    ng.run(['$rootScope', '$compile', function($rootScope, $compile) {
        $.fn.page = function() {
            var element = this;
            if (!element.data('angularLinked')) {
                var scope = $rootScope.$new();
                // trigger a separate page compile...
                $compile(element)(scope);
                $rootScope.$digest();
            }
            return _page.apply(this, arguments);
        };
    }]);

    /**
     * Deactivate the url changing capabilities
     * of angular, so we do not get into trouble with
     * jquery mobile: angular saves the current url before a $digest
     * and updates the url after the $digest.
     * <p>
     * This also replaces the hashListen implementation
     * of angular by the jquery mobile impementation,
     * so we do not have two polling functions, ...
     * <p>
     * Attention: By this, urls can no more be changed via angular's $location service!
     */
    function deactivateAngularLocationService($browser) {
            $browser.onHashChange = function(handler) {
                $(window).bind('hashchange', handler);
                return handler;
            };
            var lastUrl = location.href;
            $browser.url = function(url) {
                if (url) {
                    lastUrl = url;
                }
                return lastUrl;
            };
    }
    deactivateAngularLocationService.$inject = ['$browser'];

    var jqmCompilePages = [];
    var jqmRefreshPages = {};

    function patchRootDigest($rootScope) {
        var _apply = $rootScope.$apply;
        $rootScope.$apply = function() {
            if ($rootScope.$$phase) {
                return $rootScope.$eval.apply(this, arguments);
            }
            return _apply.apply(this, arguments);
        };
        var refreshing = false;
        var _digest = $rootScope.$digest;
        $rootScope.$digest = function() {
            if ($rootScope.$$phase) {
                return;
            }
            var res = _digest.apply(this, arguments);
            if (refreshing) {
                return;
            }
            refreshing = true;
            // run the jquery mobile page compiler
            // AFTER the angular compiler or any linking function is completely finished.
            // (Cannot be done in an angular directive, as this would lead to
            // interaction problems between angular and jqm modifying the dom...)
            if (this===$rootScope) {
                if (jqmCompilePages.length>0) {
                    var pages = jqmCompilePages;
                    jqmCompilePages = [];
                    if (!$rootScope.jqmInitialized) {
                        $rootScope.jqmInitialized = true;
                        $.mobile.initializePage();
                    }
                    for (var i=0; i<pages.length; i++) {
                        pages[i].page();
                    }
                }
                var pages = jqmRefreshPages;
                jqmRefreshPages = {};
                for (var id in pages) {
                    pages[id].trigger("create");
                }
                // Ignore all refresh requests that were created during the refreshing...
                jqmRefreshPages = {};
            }
            refreshing = false;
            return res;
        };
    }
    patchRootDigest.$inject = ['$rootScope'];

    /**
     * This is a copy of the degrade inputs plugin of jquery
     * mobile. We need it here to execute this replacement
     * at the right time, i.e. before we do the compile with angular.
     * @param targetPage
     */
    function degradeInputs(targetPage) {
        var options = $.mobile.page.prototype.options;

        // degrade inputs to avoid poorly implemented native functionality
        targetPage.find( "input" ).not( options.keepNativeDefault ).each(function() {
            var $this = $( this ),
                type = this.getAttribute( "type" ),
                optType = options.degradeInputs[ type ] || "text";

            if ( options.degradeInputs[ type ] ) {
                var html = $( "<div>" ).html( $this.clone() ).html(),
                    // In IE browsers, the type sometimes doesn't exist in the cloned markup, so we replace the closing tag instead
                    hasType = html.indexOf( " type=" ) > -1,
                    findstr = hasType ? /\s+type=["']?\w+['"]?/ : /\/?>/,
                    repstr = " type=\"" + optType + "\" data-" + $.mobile.ns + "type=\"" + type + "\"" + ( hasType ? "" : ">" );

                $this.replaceWith( html.replace( findstr, repstr ) );
            }
        });
    }

    $.mobile.autoInitializePage = false;

    // We want to create a special directive that matched data-role="page" and data-role="dialog",
    // but none of the other data-role="..." elements of jquery mobile. As we want to create a new
    // scope for that directive, this is only possible, if we preprocess the dom and add a new attribute
    // that is unique for pages and dialogs.
    ng.config(['$provide', function($provide) {
        $provide.decorator('$compile', ['$delegate', function($delegate) {
            var selector = ':jqmData(role="page"), :jqmData(role="dialog")';
            var rolePageAttr = 'data-role-page';
            return function(element) {
                element.filter(selector).add(element.find(selector)).attr(rolePageAttr, true);
                degradeInputs(element);
                return $delegate.apply(this, arguments);
            }
        }]);
    }]);

    // Directive for jquery mobile pages. Refreshes the jquery mobile widgets
    // when the page changes.
    ng.directive('rolePage', function () {
        return {
            restrict:'A',
            scope:true,
            compile:function compile(tElement, tAttrs) {
                var id = tAttrs.id;
                return {
                    pre:function preLink(scope, iElement, iAttrs) {
                        jqmCompilePages.push(iElement);
                        iElement.data('angularLinked', true);
                        // Detatch the scope for the normal $digest cycle
                        scope.$destroy();
                        iElement.bind('requestrefresh', function () {
                            jqmRefreshPages[id] = iElement;
                        });
                    }
                }
            }
        };
    });
});
jqmng.define('jqmng/paging', ['jquery', 'angular'], function ($, angular) {

    function pagedListFilterFactory(defaultListPageSize, filterFilter, orderByFilter) {

        function createPagedList(list) {
            var enhanceFunctions = {
                refreshIfNeeded:refreshIfNeeded,
                setFilter:setFilter,
                setOrderBy:setOrderBy,
                setPageSize:setPageSize,
                loadNextPage:loadNextPage,
                hasMorePages:hasMorePages,
                reset:reset,
                refreshCount:0
            };

            var pagedList = [];
            var pageSize, originalList, originalListClone, refreshNeeded, filter, orderBy, loadedCount, availableCount;

            for (var fnName in enhanceFunctions) {
                pagedList[fnName] = enhanceFunctions[fnName];
            }
            init(list);
            var oldHasOwnProperty = pagedList.hasOwnProperty;
            pagedList.hasOwnProperty = function (propName) {
                if (propName in enhanceFunctions) {
                    return false;
                }
                return oldHasOwnProperty.apply(this, arguments);
            };
            return pagedList;

            function init(list) {
                setPageSize(-1);
                originalList = list;
                originalListClone = [];
                refreshNeeded = true;
                reset();
            }

            function refresh() {
                var list = originalList;
                originalListClone = [].concat(list);
                if (filter) {
                    list = filterFilter(list, filter);
                }
                if (orderBy) {
                    list = orderByFilter(list, orderBy);
                }
                if (loadedCount < pageSize) {
                    loadedCount = pageSize;
                }
                if (loadedCount > list.length) {
                    loadedCount = list.length;
                }
                availableCount = list.length;
                var newData = list.slice(0, loadedCount);
                var spliceArgs = [0, pagedList.length].concat(newData);
                pagedList.splice.apply(pagedList, spliceArgs);
                pagedList.refreshCount++;
            }

            function refreshIfNeeded() {
                if (originalList.length != originalListClone.length) {
                    refreshNeeded = true;
                } else {
                    for (var i = 0; i < originalList.length; i++) {
                        if (originalList[i] !== originalListClone[i]) {
                            refreshNeeded = true;
                            break;
                        }
                    }
                }
                if (refreshNeeded) {
                    refresh();
                    refreshNeeded = false;
                }
                return pagedList;
            }

            function setPageSize(newPageSize) {
                if (!newPageSize || newPageSize < 0) {
                    newPageSize = defaultListPageSize;
                }
                if (newPageSize !== pageSize) {
                    pageSize = newPageSize;
                    refreshNeeded = true;
                }
            }

            function setFilter(newFilter) {
                if (!angular.equals(filter, newFilter)) {
                    filter = newFilter;
                    refreshNeeded = true;
                }
            }

            function setOrderBy(newOrderBy) {
                if (!angular.equals(orderBy, newOrderBy)) {
                    orderBy = newOrderBy;
                    refreshNeeded = true;
                }
            }

            function loadNextPage() {
                loadedCount = loadedCount + pageSize;
                refreshNeeded = true;
            }

            function hasMorePages() {
                refreshIfNeeded();
                return loadedCount < availableCount;
            }

            function reset() {
                loadedCount = 0;
                refreshNeeded = true;
            }
        }

        return function (list, param) {
            if (!list) {
                return list;
            }
            var pagedList = list.pagedList;
            if (typeof param === 'string') {
                if (!pagedList) {
                    return;
                }
                // commands do not create a new paged list nor do they change the attributes of the list.
                if (param === 'loadMore') {
                    pagedList.loadNextPage();
                } else if (param === 'hasMore') {
                    return pagedList.hasMorePages();
                }
                return;
            }
            if (!pagedList) {
                pagedList = createPagedList(list);
                list.pagedList = pagedList;
            }
            if (param) {
                pagedList.setPageSize(param.pageSize);
                pagedList.setFilter(param.filter);
                pagedList.setOrderBy(param.orderBy);
            }
            pagedList.refreshIfNeeded();
            return pagedList;
        };
    }

    pagedListFilterFactory.$inject = ['defaultListPageSize', 'filterFilter', 'orderByFilter'];
    var mod = angular.module(['ng']);
    mod.constant('defaultListPageSize', 10);
    mod.filter('paged', pagedListFilterFactory);
});
jqmng.define('jqmng/fadein',['angular'], function(angular) {
    /*
     * Directive that fades in an element when angular
     * uses it. Useful in templating when the underlying template changed.
     */
    angular.module(["ng"]).directive("ngmFadein", function() {
        return {
            compile: function(element) {
                element.css({opacity:0.1});
                return function(scope, element, attrs) {
                    element.animate({opacity:1.0}, parseInt(attrs.ngmFadein));
                }
            }
        };
    });
});
